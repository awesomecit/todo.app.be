# Guida Completa alle Classes ES6 e Inheritance

Le classi in JavaScript rappresentano una delle innovazioni più significative introdotte con ES6, non tanto perché abbiano cambiato il funzionamento interno del linguaggio, quanto perché hanno trasformato il modo in cui gli sviluppatori pensano e strutturano il codice orientato agli oggetti. Prima di immergerci nella sintassi delle classi moderne, è fondamentale comprendere il percorso evolutivo che ha portato a questa innovazione e, soprattutto, i problemi concreti che le classi ES6 risolvono.

JavaScript è sempre stato un linguaggio orientato agli oggetti, ma utilizzava un approccio basato sui prototipi che spesso confondeva gli sviluppatori provenienti da linguaggi come Java, C#, o Python. Questo approccio prototipale, pur essendo potente e flessibile, richiedeva una comprensione profonda di concetti come function constructors, prototype chain, e context binding. Le classi ES6 non hanno eliminato questo sistema sottostante, ma hanno fornito una sintassi più familiare e intuitiva che nasconde gran parte della complessità, permettendo agli sviluppatori di concentrarsi sulla logica applicativa piuttosto che sui dettagli implementativi.

## L'Evoluzione: Da Function Constructors alle Modern Classes

Per apprezzare pienamente il valore delle classi ES6, iniziamo esaminando come si creava codice orientato agli oggetti in JavaScript prima della loro introduzione. Questo confronto non è solo accademico, ma ti aiuterà a comprendere perché certe scelte di design sono state fatte e come le classi moderne semplificano drammaticamente la scrittura di codice maintainable.

Considera questo scenario tipico: vogliamo modellare un sistema di gestione di una libreria digitale. Nell'approccio pre-ES6, dovevamo utilizzare function constructors e manipolazione diretta del prototype:

```javascript
// Approccio pre-ES6: Function Constructor pattern
function Libro(titolo, autore, anno, genere) {
  // Proprietà dell'istanza assegnate tramite 'this'
  this.titolo = titolo;
  this.autore = autore;
  this.anno = anno;
  this.genere = genere;
  this.prestito = null; // Informazioni sul prestito corrente
  this.disponibile = true;
}

// Metodi aggiunti al prototype per condivisione tra istanze
Libro.prototype.prestaSe = function (utente, dataScadenza) {
  if (!this.disponibile) {
    throw new Error('Libro non disponibile per il prestito');
  }

  this.prestito = {
    utente: utente,
    dataInizio: new Date(),
    dataScadenza: dataScadenza,
  };
  this.disponibile = false;

  return `Libro "${this.titolo}" prestato a ${utente}`;
};

Libro.prototype.restituisci = function () {
  if (this.disponibile) {
    throw new Error('Il libro non è attualmente in prestito');
  }

  const informazioniPrestito = this.prestito;
  this.prestito = null;
  this.disponibile = true;

  return `Libro "${this.titolo}" restituito da ${informazioniPrestito.utente}`;
};

Libro.prototype.ottieniInfo = function () {
  return `"${this.titolo}" di ${this.autore} (${this.anno}) - Genere: ${this.genere}`;
};

// Metodo "statico" simulato attraverso proprietà della funzione constructor
Libro.creaRaccoltaClassici = function () {
  return [
    new Libro('1984', 'George Orwell', 1949, 'Distopia'),
    new Libro('Il Signore degli Anelli', 'J.R.R. Tolkien', 1954, 'Fantasy'),
    new Libro('Orgoglio e Pregiudizio', 'Jane Austen', 1813, 'Romance'),
  ];
};

// Per creare ereditarietà, dovevamo manipolare manualmente la prototype chain
function LibroDigitale(
  titolo,
  autore,
  anno,
  genere,
  formatoFile,
  dimensioneFile,
) {
  // Chiamare il constructor padre con call per impostare le proprietà base
  Libro.call(this, titolo, autore, anno, genere);

  // Proprietà specifiche del libro digitale
  this.formatoFile = formatoFile;
  this.dimensioneFile = dimensioneFile;
  this.downloadCount = 0;
}

// Impostare la prototype chain manualmente per l'ereditarietà
LibroDigitale.prototype = Object.create(Libro.prototype);
LibroDigitale.prototype.constructor = LibroDigitale;

// Aggiungere metodi specifici per LibroDigitale
LibroDigitale.prototype.download = function () {
  if (!this.disponibile) {
    throw new Error('File non disponibile per download');
  }

  this.downloadCount++;
  return `Download di "${this.titolo}" completato. Formato: ${this.formatoFile}`;
};

LibroDigitale.prototype.ottieniInfoTecniche = function () {
  return `${this.formatoFile.toUpperCase()} - ${this.dimensioneFile}MB - Downloads: ${this.downloadCount}`;
};
```

Questo codice, pur funzionando perfettamente, presenta diversi problemi evidenti che rendevano lo sviluppo più lento e soggetto a errori. La separazione tra proprietà (definite nel constructor) e metodi (aggiunti al prototype) creava una disconnessione mentale che rendeva difficile visualizzare la struttura completa della classe. La gestione dell'ereditarietà richiedeva una conoscenza profonda della prototype chain e la manipolazione manuale di oggetti prototype. Inoltre, non esisteva un modo nativo per creare metodi privati o statici, costringendo gli sviluppatori a utilizzare convenzioni o workaround.

Ora osserviamo come lo stesso sistema può essere implementato utilizzando le classi ES6, notando immediatamente la differenza in termini di chiarezza e organizzazione del codice:

```javascript
// Approccio ES6: Class syntax moderna e pulita
class Libro {
  // Constructor centralizza l'inizializzazione dell'istanza
  constructor(titolo, autore, anno, genere) {
    this.titolo = titolo;
    this.autore = autore;
    this.anno = anno;
    this.genere = genere;
    this.prestito = null;
    this.disponibile = true;
  }

  // Metodi dell'istanza definiti direttamente nella classe
  prestaA(utente, dataScadenza) {
    if (!this.disponibile) {
      throw new Error('Libro non disponibile per il prestito');
    }

    this.prestito = {
      utente: utente,
      dataInizio: new Date(),
      dataScadenza: dataScadenza,
    };
    this.disponibile = false;

    return `Libro "${this.titolo}" prestato a ${utente}`;
  }

  restituisci() {
    if (this.disponibile) {
      throw new Error('Il libro non è attualmente in prestito');
    }

    const informazioniPrestito = this.prestito;
    this.prestito = null;
    this.disponibile = true;

    return `Libro "${this.titolo}" restituito da ${informazioniPrestito.utente}`;
  }

  ottieniInfo() {
    return `"${this.titolo}" di ${this.autore} (${this.anno}) - Genere: ${this.genere}`;
  }

  // Metodi statici definiti con keyword 'static'
  static creaRaccoltaClassici() {
    return [
      new Libro('1984', 'George Orwell', 1949, 'Distopia'),
      new Libro('Il Signore degli Anelli', 'J.R.R. Tolkien', 1954, 'Fantasy'),
      new Libro('Orgoglio e Pregiudizio', 'Jane Austen', 1813, 'Romance'),
    ];
  }
}

// Ereditarietà semplificata con extends e super
class LibroDigitale extends Libro {
  constructor(titolo, autore, anno, genere, formatoFile, dimensioneFile) {
    // Super() chiama automaticamente il constructor della classe padre
    super(titolo, autore, anno, genere);

    // Proprietà specifiche della classe figlio
    this.formatoFile = formatoFile;
    this.dimensioneFile = dimensioneFile;
    this.downloadCount = 0;
  }

  download() {
    if (!this.disponibile) {
      throw new Error('File non disponibile per download');
    }

    this.downloadCount++;
    return `Download di "${this.titolo}" completato. Formato: ${this.formatoFile}`;
  }

  ottieniInfoTecniche() {
    return `${this.formatoFile.toUpperCase()} - ${this.dimensioneFile}MB - Downloads: ${this.downloadCount}`;
  }

  // Override di un metodo padre con comportamento esteso
  ottieniInfo() {
    // Chiamiamo il metodo padre con super
    const infoBase = super.ottieniInfo();
    const infoTecniche = this.ottieniInfoTecniche();
    return `${infoBase} | ${infoTecniche}`;
  }
}
```

La differenza è immediata e drammatica. La sintassi delle classi ES6 crea una struttura visivamente più coerente dove proprietà e metodi sono chiaramente raggruppati e organizzati. L'ereditarietà diventa intuitiva con le keyword `extends` e `super`, eliminando la necessità di manipolare manualmente la prototype chain. I metodi statici sono chiaramente identificati, e l'override di metodi dalla classe padre risulta semplice e comprensibile.

## Anatomia di una Classe ES6: Comprendere ogni Componente

Ora che hai visto i benefici delle classi moderne, approfondiamo ogni aspetto della loro struttura per costruire una comprensione solida di come utilizzarle efficacemente. Ogni elemento di una classe ES6 ha un ruolo specifico e comprendere questi ruoli ti permetterà di progettare sistemi orientati agli oggetti eleganti e maintainable.

Una classe è essenzialmente un template che definisce le caratteristiche comuni che condivideranno tutte le istanze create da quella classe. Pensala come un blueprint architettonico: definisce la struttura, ma ogni casa costruita da quel blueprint sarà un'istanza unica con i suoi specifici dettagli.

```javascript
// Esempio dettagliato che mostra tutti i componenti di una classe moderna
class GestoreTaskPersonali {
  // Proprieta statiche: condivise tra tutte le istanze della classe
  static PRIORITA_BASSA = 'bassa';
  static PRIORITA_MEDIA = 'media';
  static PRIORITA_ALTA = 'alta';
  static PRIORITA_CRITICA = 'critica';

  // Il constructor è il metodo speciale chiamato quando si crea una nuova istanza
  constructor(nomeUtente) {
    // Validazione input nel constructor
    if (!nomeUtente || typeof nomeUtente !== 'string') {
      throw new Error('Il nome utente deve essere una stringa non vuota');
    }

    // Proprietà dell'istanza: ogni istanza ha i suoi valori unici
    this.nomeUtente = nomeUtente;
    this.tasks = [];
    this.taskCompletati = 0;
    this.dataCreazione = new Date();

    console.log(`Gestore task creato per l'utente: ${nomeUtente}`);
  }

  // Metodi dell'istanza: operazioni che ogni istanza può eseguire
  aggiungiTask(descrizione, priorita = GestoreTaskPersonali.PRIORITA_MEDIA) {
    // Validazione dei parametri
    if (!descrizione || typeof descrizione !== 'string') {
      throw new Error(
        'La descrizione del task deve essere una stringa non vuota',
      );
    }

    // Validazione della priorità usando le costanti statiche
    const prioritaValide = [
      GestoreTaskPersonali.PRIORITA_BASSA,
      GestoreTaskPersonali.PRIORITA_MEDIA,
      GestoreTaskPersonali.PRIORITA_ALTA,
      GestoreTaskPersonali.PRIORITA_CRITICA,
    ];

    if (!prioritaValide.includes(priorita)) {
      throw new Error(
        `Priorità non valida. Usa una delle costanti: ${prioritaValide.join(', ')}`,
      );
    }

    // Creazione del task con ID univoco
    const nuovoTask = {
      id: this._generaIdUnico(),
      descrizione: descrizione,
      priorita: priorita,
      completato: false,
      dataCreazione: new Date(),
      dataCompletamento: null,
    };

    this.tasks.push(nuovoTask);

    console.log(`Task aggiunto: "${descrizione}" con priorità ${priorita}`);
    return nuovoTask.id;
  }

  completaTask(taskId) {
    const task = this.tasks.find(t => t.id === taskId);

    if (!task) {
      throw new Error(`Task con ID ${taskId} non trovato`);
    }

    if (task.completato) {
      console.log(`Task "${task.descrizione}" è già completato`);
      return false;
    }

    task.completato = true;
    task.dataCompletamento = new Date();
    this.taskCompletati++;

    console.log(`Task completato: "${task.descrizione}"`);
    return true;
  }

  ottieniTaskPerPriorita(priorita) {
    return this.tasks.filter(
      task => task.priorita === priorita && !task.completato,
    );
  }

  ottieniStatistiche() {
    const totaliTask = this.tasks.length;
    const taskAttivi = this.tasks.filter(t => !t.completato).length;
    const percentualeCompletamento =
      totaliTask > 0
        ? ((this.taskCompletati / totaliTask) * 100).toFixed(1)
        : 0;

    return {
      utente: this.nomeUtente,
      totaliTask: totaliTask,
      taskCompletati: this.taskCompletati,
      taskAttivi: taskAttivi,
      percentualeCompletamento: `${percentualeCompletamento}%`,
      dataCreazione: this.dataCreazione,
    };
  }

  // Metodo privato (convenzione con underscore - non veramente privato in ES6 standard)
  _generaIdUnico() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
  }

  // Metodo statico: appartiene alla classe, non alle singole istanze
  static confrontaPerformance(gestore1, gestore2) {
    const stats1 = gestore1.ottieniStatistiche();
    const stats2 = gestore2.ottieniStatistiche();

    const perf1 = parseFloat(stats1.percentualeCompletamento);
    const perf2 = parseFloat(stats2.percentualeCompletamento);

    if (perf1 > perf2) {
      return `${stats1.utente} ha performance migliore (${stats1.percentualeCompletamento} vs ${stats2.percentualeCompletamento})`;
    } else if (perf2 > perf1) {
      return `${stats2.utente} ha performance migliore (${stats2.percentualeCompletamento} vs ${stats1.percentualeCompletamento})`;
    } else {
      return `${stats1.utente} e ${stats2.utente} hanno performance equivalenti (${stats1.percentualeCompletamento})`;
    }
  }

  static creaGestoreDemo() {
    const gestore = new GestoreTaskPersonali('Demo User');

    // Aggiungiamo alcuni task di esempio
    gestore.aggiungiTask(
      'Completare progetto JavaScript',
      GestoreTaskPersonali.PRIORITA_ALTA,
    );
    gestore.aggiungiTask(
      'Leggere documentazione ES6',
      GestoreTaskPersonali.PRIORITA_MEDIA,
    );
    gestore.aggiungiTask(
      'Organizzare scrivania',
      GestoreTaskPersonali.PRIORITA_BASSA,
    );

    console.log('Gestore demo creato con task di esempio');
    return gestore;
  }
}

// Esempio di utilizzo che dimostra tutti i componenti
console.log('=== Test Completo della Classe GestoreTaskPersonali ===');

// Creazione di istanze
const gestoreMario = new GestoreTaskPersonali('Mario');
const gestoreAnna = new GestoreTaskPersonali('Anna');

// Utilizzo delle costanti statiche
gestoreMario.aggiungiTask(
  'Preparare presentazione',
  GestoreTaskPersonali.PRIORITA_ALTA,
);
gestoreMario.aggiungiTask(
  'Rispondere alle email',
  GestoreTaskPersonali.PRIORITA_MEDIA,
);

gestoreAnna.aggiungiTask(
  'Review del codice',
  GestoreTaskPersonali.PRIORITA_CRITICA,
);
gestoreAnna.aggiungiTask(
  'Meeting con il team',
  GestoreTaskPersonali.PRIORITA_ALTA,
);

// Completamento di alcuni task
const taskIds = [];
taskIds.push(
  gestoreMario.aggiungiTask(
    'Testing nuove feature',
    GestoreTaskPersonali.PRIORITA_MEDIA,
  ),
);
gestoreMario.completaTask(taskIds[0]);

// Utilizzo di metodi statici
console.log('\n=== Confronto Performance ===');
console.log(
  GestoreTaskPersonali.confrontaPerformance(gestoreMario, gestoreAnna),
);

console.log('\n=== Statistiche Finali ===');
console.log('Mario:', gestoreMario.ottieniStatistiche());
console.log('Anna:', gestoreAnna.ottieniStatistiche());

// Creazione gestore demo usando metodo statico
const gestoreDemo = GestoreTaskPersonali.creaGestoreDemo();
console.log('\nDemo:', gestoreDemo.ottieniStatistiche());
```

Questo esempio completo illustra come ogni componente di una classe ES6 abbia un ruolo specifico nell'architettura del nostro sistema. Le proprietà statiche fungono da costanti condivise che garantiscono coerenza in tutta l'applicazione. Il constructor gestisce l'inizializzazione e la validazione dei dati, assicurando che ogni istanza parta da uno stato valido. I metodi dell'istanza implementano la logica specifica di ogni oggetto, mentre i metodi statici forniscono utility che operano sulla classe nel suo complesso.

## Ereditarietà e la Keyword Extends: Costruire Gerarchie Robuste

L'ereditarietà è uno dei pilastri fondamentali della programmazione orientata agli oggetti, e le classi ES6 rendono questo concetto incredibilmente più accessibile e potente. Quando parliamo di ereditarietà, stiamo essenzialmente creando una relazione "è un tipo di" tra classi, dove una classe figlio eredita tutte le caratteristiche della classe padre, ma può anche aggiungere le proprie specifiche funzionalità o modificare comportamenti esistenti.

Per comprendere profondamente come funziona l'ereditarietà nelle classi ES6, costruiamo insieme un sistema di gestione di diversi tipi di veicoli, partendo da una classe base e specializzandola gradualmente:

```javascript
// Classe base: definisce le caratteristiche comuni a tutti i veicoli
class Veicolo {
  constructor(marca, modello, anno, colore) {
    // Validazione dei parametri essenziali
    if (!marca || !modello || !anno) {
      throw new Error('Marca, modello e anno sono obbligatori');
    }

    this.marca = marca;
    this.modello = modello;
    this.anno = anno;
    this.colore = colore || 'non specificato';
    this.chilometraggio = 0;
    this.acceso = false;
    this.velocitaCorrente = 0;
    this.storicoMantenimento = [];
  }

  // Metodi comuni che ogni veicolo dovrebbe avere
  accendi() {
    if (this.acceso) {
      return `${this.marca} ${this.modello} è già acceso`;
    }

    this.acceso = true;
    return `${this.marca} ${this.modello} acceso con successo`;
  }

  spegni() {
    if (!this.acceso) {
      return `${this.marca} ${this.modello} è già spento`;
    }

    if (this.velocitaCorrente > 0) {
      return 'Non puoi spegnere il veicolo mentre è in movimento';
    }

    this.acceso = false;
    return `${this.marca} ${this.modello} spento`;
  }

  accelera(incremento = 10) {
    if (!this.acceso) {
      return 'Devi prima accendere il veicolo';
    }

    this.velocitaCorrente += incremento;
    return `Velocità aumentata a ${this.velocitaCorrente} km/h`;
  }

  frena(decremento = 10) {
    this.velocitaCorrente = Math.max(0, this.velocitaCorrente - decremento);
    return `Velocità ridotta a ${this.velocitaCorrente} km/h`;
  }

  aggiungiMantenimento(descrizione, costo, data = new Date()) {
    const intervento = {
      id: Date.now(),
      descrizione,
      costo,
      data,
      chilometraggioAttuale: this.chilometraggio,
    };

    this.storicomantenimento.push(intervento);
    return `Intervento registrato: ${descrizione} - €${costo}`;
  }

  ottieniInfo() {
    return `${this.marca} ${this.modello} (${this.anno}) - Colore: ${this.colore} - Km: ${this.chilometraggio}`;
  }

  // Metodo che può essere sovrascritto dalle classi figlio
  calcolaConsumoCarburante(distanza) {
    // Calcolo generico: consumo base di 8 litri per 100km
    return (distanza / 100) * 8;
  }

  // Metodo statico per confrontare veicoli
  static confrontaAnni(veicolo1, veicolo2) {
    return veicolo1.anno - veicolo2.anno;
  }
}

// Prima specializzazione: Auto che estende Veicolo
class Auto extends Veicolo {
  constructor(
    marca,
    modello,
    anno,
    colore,
    numeroPorte,
    tipoCarburante,
    cilindrata,
  ) {
    // Super() deve essere la prima chiamata nel constructor della classe figlio
    super(marca, modello, anno, colore);

    // Proprietà specifiche delle auto
    this.numeroPorte = numeroPorte || 4;
    this.tipoCarburante = tipoCarburante || 'benzina';
    this.cilindrata = cilindrata;
    this.bagagliOccupato = 0;
    this.capacitaBagagli = 400; // litri
    this.assicurazione = null;
  }

  // Metodi specifici per le auto
  caricaBagagli(volume) {
    if (this.bagagliOccupato + volume > this.capacitaBagagli) {
      return `Spazio insufficiente. Disponibili ${this.capacitaBagagli - this.bagagliOccupato} litri`;
    }

    this.bagagliOccupato += volume;
    return `Caricati ${volume} litri. Spazio residuo: ${this.capacitaBagagli - this.bagagliOccupato} litri`;
  }

  scaricaBagagli(volume = this.bagagliOccupato) {
    const volumeEffettivo = Math.min(volume, this.bagagliOccupato);
    this.bagagliOccupato -= volumeEffettivo;
    return `Scaricati ${volumeEffettivo} litri. Spazio occupato: ${this.bagagliOccupato} litri`;
  }

  // Override del metodo padre con calcolo più specifico per le auto
  calcolaConsumoCarburante(distanza) {
    let consumoBase;

    switch (this.tipoCarburante) {
      case 'diesel':
        consumoBase = 6; // litri per 100km
        break;
      case 'ibrido':
        consumoBase = 4;
        break;
      case 'elettrico':
        return `${(distanza / 100) * 15} kWh`; // Per auto elettriche usiamo kWh
      default:
        consumoBase = 7;
    }

    // Aggiustiamo il consumo in base alla cilindrata
    if (this.cilindrata) {
      const fattoreCilindrata = this.cilindrata / 1600; // 1600cc come riferimento
      consumoBase *= fattoreCilindrata;
    }

    return `${(distanza / 100) * consumoBase} litri di ${this.tipoCarburante}`;
  }

  // Estende il metodo info del padre aggiungendo informazioni specifiche
  ottieniInfo() {
    const infoBase = super.ottieniInfo(); // Chiamiamo il metodo del padre
    return `${infoBase} - ${this.numeroPorte} porte - ${this.tipoCarburante} - ${this.cilindrata || 'N/A'}cc`;
  }

  // Metodo statico specifico per le auto
  static calcolaEtaVeicolo(auto, dataCorrente = new Date()) {
    return dataCorrente.getFullYear() - auto.anno;
  }
}

// Seconda specializzazione: Motocicletta che estende Veicolo
class Motocicletta extends Veicolo {
  constructor(marca, modello, anno, colore, cilindrata, tipoMotore) {
    super(marca, modello, anno, colore);

    // Proprietà specifiche delle motociclette
    this.cilindrata = cilindrata;
    this.tipoMotore = tipoMotore || 'quattro tempi';
    this.cascoObbligatorio = true;
    this.passeggeroABordo = false;
  }

  // Metodi specifici per le motociclette
  salitaPasseggero() {
    if (this.passeggeroABordo) {
      return "C'è già un passeggero a bordo";
    }

    this.passeggeroABordo = true;
    return 'Passeggero salito a bordo';
  }

  discesaPasseggero() {
    if (!this.passeggeroABordo) {
      return "Non c'è nessun passeggero a bordo";
    }

    this.passeggeroABordo = false;
    return 'Passeggero sceso';
  }

  // Override specifico per motociclette
  calcolaConsumoCarburante(distanza) {
    // Le moto consumano generalmente meno delle auto
    const consumoBase = 4; // litri per 100km
    const fattoreCilindrata = this.cilindrata / 600; // 600cc come riferimento
    const consumoEffettivo = consumoBase * fattoreCilindrata;

    return `${(distanza / 100) * consumoEffettivo} litri`;
  }

  // Override del metodo info con informazioni specifiche
  ottieniInfo() {
    const infoBase = super.ottieniInfo();
    const passeggero = this.passeggeroABordo ? 'con passeggero' : 'solo pilota';
    return `${infoBase} - ${this.cilindrata}cc - ${this.tipoMotore} - ${passeggero}`;
  }
}

// Terza specializzazione: ulteriore ereditarietà con AutoSportiva che estende Auto
class AutoSportiva extends Auto {
  constructor(
    marca,
    modello,
    anno,
    colore,
    cilindrata,
    potenzaCV,
    tempoAccelerazione,
  ) {
    // Chiamiamo il constructor della classe padre (Auto)
    super(marca, modello, anno, colore, 2, 'benzina', cilindrata);

    // Proprietà specifiche delle auto sportive
    this.potenzaCV = potenzaCV;
    this.tempoAccelerazione = tempoAccelerazione; // 0-100 km/h in secondi
    this.modalitaSport = false;
    this.velocitaMassima = this._calcolaVelocitaMassima();
  }

  // Metodi specifici delle auto sportive
  attivaMalitaSport() {
    if (this.modalitaSport) {
      return 'Modalità sport già attiva';
    }

    this.modalitaSport = true;
    return 'Modalità sport attivata - Performance massime';
  }

  disattivaMlitaSport() {
    this.modalitaSport = false;
    return 'Modalità sport disattivata - Guida normale';
  }

  // Override del metodo accelera con comportamento specifico per auto sportive
  accelera(incremento = 15) {
    if (!this.acceso) {
      return 'Devi prima accendere il veicolo';
    }

    // In modalità sport l'accelerazione è più rapida
    const incrementoEffettivo = this.modalitaSport
      ? incremento * 1.5
      : incremento;

    if (this.velocitaCorrente + incrementoEffettivo > this.velocitaMassima) {
      this.velocitaCorrente = this.velocitaMassima;
      return `Velocità massima raggiunta: ${this.velocitaMassima} km/h`;
    }

    this.velocitaCorrente += incrementoEffettivo;
    const modalita = this.modalitaSport ? ' (modalità sport)' : '';
    return `Accelerazione sportiva: ${this.velocitaCorrente} km/h${modalita}`;
  }

  // Metodo privato per calcolare la velocità massima teorica
  _calcolaVelocitaMassima() {
    // Formula semplificata basata su potenza e peso stimato
    const pesoStimato = 1200; // kg
    const fattorePotenza = this.potenzaCV / pesoStimato;
    return Math.round(200 + fattorePotenza * 50); // velocità teorica
  }

  // Override con informazioni specifiche dell'auto sportiva
  ottieniInfo() {
    const infoAuto = super.ottieniInfo(); // Chiamiamo il metodo di Auto (che a sua volta chiama quello di Veicolo)
    const modalita = this.modalitaSport ? 'SPORT' : 'Normal';
    return `${infoAuto} - ${this.potenzaCV}CV - 0-100: ${this.tempoAccelerazione}s - Modalità: ${modalita}`;
  }
}

// Dimostriamo l'utilizzo dell'ereditarietà con esempi pratici
console.log('=== Test Sistema Ereditarietà Veicoli ===\n');

// Creiamo istanze di ogni tipo di veicolo
const veicoloGenerico = new Veicolo('Generica', 'Modello Base', 2020, 'bianco');
const miaAuto = new Auto('Toyota', 'Corolla', 2019, 'rosso', 4, 'ibrido', 1800);
const miaMoto = new Motocicletta(
  'Yamaha',
  'MT-07',
  2021,
  'nero',
  689,
  'quattro tempi',
);
const autoSportiva = new AutoSportiva(
  'Ferrari',
  '488 GTB',
  2022,
  'rosso',
  3902,
  670,
  3.0,
);

console.log('=== Informazioni Veicoli ===');
console.log(veicoloGenerico.ottieniInfo());
console.log(miaAuto.ottieniInfo());
console.log(miaMoto.ottieniInfo());
console.log(autoSportiva.ottieniInfo());

console.log('\n=== Test Funzionalità Specifiche ===');
// Test funzionalità auto
console.log(miaAuto.caricaBagagli(200));
console.log('Consumo per 150km:', miaAuto.calcolaConsumoCarburante(150));

// Test funzionalità motocicletta
console.log(miaMoto.salitaPasseggero());
console.log('Consumo moto per 150km:', miaMoto.calcolaConsumoCarburante(150));

// Test funzionalità auto sportiva
console.log(autoSportiva.attivaMalitaSport());
console.log(autoSportiva.accelera(30));

console.log('\n=== Test Metodi Ereditati ===');
// Tutti i veicoli hanno i metodi base
console.log(miaAuto.accendi());
console.log(miaMoto.accendi());
console.log(autoSportiva.spegni()); // Dovrebbe fallire perché ha velocità > 0

console.log('\n=== Test Polimorfismo ===');
// Array di veicoli diversi che rispondono tutti al metodo ottieniInfo()
const flotta = [veicoloGenerico, miaAuto, miaMoto, autoSportiva];
flotta.forEach((veicolo, indice) => {
  console.log(`Veicolo ${indice + 1}: ${veicolo.ottieniInfo()}`);
});
```

Questo esempio complesso dimostra la potenza dell'ereditarietà nelle classi ES6. Ogni classe figlio mantiene tutte le funzionalità del padre ma può aggiungerne di nuove o modificare quelle esistenti. Il polimorfismo permette di trattare oggetti di classi diverse attraverso un'interfaccia comune, mentre l'override dei metodi consente comportamenti specializzati per ogni tipo di veicolo.

## La Keyword Super: Comunicare con la Classe Padre

La keyword `super` rappresenta uno degli aspetti più eleganti e potenti dell'ereditarietà nelle classi ES6. Essa fornisce un ponte di comunicazione diretto tra una classe figlio e la sua classe padre, permettendo di accedere a proprietà, metodi e constructor della classe genitore in modo pulito e intuitivo.

Comprendere `super` significa comprendere come le classi figlio possano estendere e personalizzare il comportamento delle classi padre senza duplicare codice o rompere l'incapsulamento. Esploriamo questo concetto attraverso un sistema di gestione di prodotti e-commerce che mostrerà tutte le sfaccettature di `super`:

```javascript
// Classe base per tutti i prodotti
class Prodotto {
  constructor(nome, prezzo, categoria, descrizione) {
    this.nome = nome;
    this.prezzo = prezzo;
    this.categoria = categoria;
    this.descrizione = descrizione;
    this.dataCreazione = new Date();
    this.recensioni = [];
    this.disponibile = true;
    this.codiceBarrediritto = this._generaCodice();
  }

  aggiungiRecensione(voto, commento, autore) {
    if (voto < 1 || voto > 5) {
      throw new Error('Il voto deve essere compreso tra 1 e 5');
    }

    const recensione = {
      id: Date.now(),
      voto: voto,
      commento: commento,
      autore: autore,
      data: new Date(),
      verificata: false,
    };

    this.recensioni.push(recensione);
    console.log(`Recensione aggiunta al prodotto "${this.nome}" da ${autore}`);
    return recensione.id;
  }

  calcolaMediaVoti() {
    if (this.recensioni.length === 0) return 0;

    const sommaVoti = this.recensioni.reduce(
      (somma, recensione) => somma + recensione.voto,
      0,
    );
    return (sommaVoti / this.recensioni.length).toFixed(1);
  }

  applicaSconto(percentuale, motivazione = 'Offerta speciale') {
    if (percentuale < 0 || percentuale > 100) {
      throw new Error('La percentuale di sconto deve essere tra 0 e 100');
    }

    const vecchioPrezzo = this.prezzo;
    this.prezzo = this.prezzo * (1 - percentuale / 100);

    console.log(`Sconto del ${percentuale}% applicato a "${this.nome}"`);
    console.log(
      `Prezzo: €${vecchioPrezzo.toFixed(2)} → €${this.prezzo.toFixed(2)}`,
    );
    console.log(`Motivazione: ${motivazione}`);

    return {
      prezzoOriginale: vecchioPrezzo,
      prezzoScontato: this.prezzo,
      risparmiato: vecchioPrezzo - this.prezzo,
    };
  }

  ottieniDettagli() {
    return {
      nome: this.nome,
      prezzo: this.prezzo,
      categoria: this.categoria,
      descrizione: this.descrizione,
      mediaVoti: this.calcolaMediaVoti(),
      numeroRecensioni: this.recensioni.length,
      disponibile: this.disponibile,
      codiceBarre: this.codiceBarre,
    };
  }

  _generaCodice() {
    return 'PROD-' + Math.random().toString(36).substring(2, 15).toUpperCase();
  }
}

// Classe specializzata per prodotti elettronici
class ProdottoElettronico extends Prodotto {
  constructor(
    nome,
    prezzo,
    descrizione,
    marca,
    modello,
    garanziaMesi,
    specificheTecniche,
  ) {
    // super() deve essere chiamato PRIMA di utilizzare 'this'
    super(nome, prezzo, 'Elettronica', descrizione);

    // Proprietà specifiche per elettronica
    this.marca = marca;
    this.modello = modello;
    this.garanziaMesi = garanziaMesi || 24;
    this.specificheTecniche = specificheTecniche || {};
    this.dataScadenzaGaranzia = this._calcolaScadenzaGaranzia();
    this.registratoInGaranzia = false;
  }

  registraGaranzia(nomeCliente, emailCliente) {
    if (this.registratoInGaranzia) {
      return 'Prodotto già registrato in garanzia';
    }

    this.registratoInGaranzia = true;
    this.informazioniGaranzia = {
      cliente: nomeCliente,
      email: emailCliente,
      dataRegistrazione: new Date(),
    };

    console.log(
      `Garanzia registrata per "${this.nome}" a nome di ${nomeCliente}`,
    );
    return 'Registrazione garanzia completata';
  }

  // Estende il metodo padre applicando sconti specifici per l'elettronica
  applicaSconto(percentuale, motivazione = 'Offerta tecnologia') {
    // Chiamiamo il metodo della classe padre per la logica base
    const risultatoSconto = super.applicaSconto(percentuale, motivazione);

    // Aggiungiamo comportamento specifico per prodotti elettronici
    if (percentuale >= 20) {
      console.log(
        '🎁 BONUS: Sconto importante! Garanzia estesa automaticamente di 6 mesi',
      );
      this.garanziaMesi += 6;
      this.dataScadenzaGaranzia = this._calcolaScadenzaGaranzia();
    }

    // Se il prodotto è molto scontato, potrebbe essere un modello in uscita
    if (percentuale >= 50) {
      console.log(
        'ℹ️  Attenzione: Questo potrebbe essere un modello in dismissione',
      );
      this.descrizione += ' - MODELLO IN USCITA';
    }

    return {
      ...risultatoSconto,
      garanzia: `${this.garanziaMesi} mesi`,
      scadenzaGaranzia: this.dataScadenzaGaranzia,
    };
  }

  // Override del metodo padre con informazioni aggiuntive
  ottieniDettagli() {
    // Otteniamo prima i dettagli base dal padre
    const dettagliBase = super.ottieniDettagli();

    // Aggiungiamo informazioni specifiche per l'elettronica
    return {
      ...dettagliBase,
      marca: this.marca,
      modello: this.modello,
      garanziaMesi: this.garanziaMesi,
      garanziScadenza: this.dataScadenzaGaranzia,
      registratoInGaranzia: this.registratoInGaranzia,
      specificheTecniche: this.specificheTecniche,
    };
  }

  _calcolaScadenzaGaranzia() {
    const scadenza = new Date(this.dataCreazione);
    scadenza.setMonth(scadenza.getMonth() + this.garanziaMesi);
    return scadenza;
  }
}

// Ulteriore specializzazione: Smartphone che estende ProdottoElettronico
class Smartphone extends ProdottoElettronico {
  constructor(
    nome,
    prezzo,
    descrizione,
    marca,
    modello,
    sistemaOperativo,
    memoriaGB,
    fotocamerMP,
  ) {
    // Chiamiamo il constructor della classe padre con specifiche tecniche predefinite
    const specifiche = {
      sistema_operativo: sistemaOperativo,
      memoria_storage: `${memoriaGB}GB`,
      fotocamera_principale: `${fotocamerMP}MP`,
      tipo_dispositivo: 'Smartphone',
    };

    super(nome, prezzo, descrizione, marca, modello, 24, specifiche);

    // Proprietà specifiche dello smartphone
    this.sistemaOperativo = sistemaOperativo;
    this.memoriaGB = memoriaGB;
    this.fotocamerMP = fotocamerMP;
    this.appInstallate = [];
    this.batteria = 100; // Percentuale carica
  }

  installaApp(nomeApp, dimensioneMB) {
    const memoriaOccupata = this.appInstallate.reduce(
      (totale, app) => totale + app.dimensione,
      0,
    );
    const memoriaDisponibile = this.memoriaGB * 1024 - memoriaOccupata; // Conversione in MB

    if (dimensioneMB > memoriaDisponibile) {
      return `Memoria insufficiente. Disponibili ${memoriaDisponibile}MB, richiesti ${dimensioneMB}MB`;
    }

    const app = {
      nome: nomeApp,
      dimensione: dimensioneMB,
      dataInstallazione: new Date(),
    };

    this.appInstallate.push(app);
    console.log(`App "${nomeApp}" installata (${dimensioneMB}MB)`);
    return `Installazione completata. Memoria residua: ${memoriaDisponibile - dimensioneMB}MB`;
  }

  // Estende il metodo di applicazione sconto con logiche specifiche per smartphone
  applicaSconto(percentuale, motivazione = 'Offerta smartphone') {
    // Prima chiamiamo il metodo della classe padre (ProdottoElettronico)
    const risultatoSconto = super.applicaSconto(percentuale, motivazione);

    // Logica specifica per smartphone
    if (percentuale >= 30) {
      console.log('📱 BONUS SMARTPHONE: Protezione schermo gratuita inclusa!');
      this.accessoriInclusi = this.accessoriInclusi || [];
      this.accessoriInclusi.push('Protezione schermo premium');
    }

    if (percentuale >= 40 && this.memoriaGB <= 64) {
      console.log('💾 BONUS MEMORIA: Cloud storage gratuito per 1 anno!');
      this.serviziInclusi = this.serviziInclusi || [];
      this.serviziInclusi.push('Cloud storage 100GB - 1 anno');
    }

    return {
      ...risultatoSconto,
      accessoriInclusi: this.accessoriInclusi || [],
      serviziInclusi: this.serviziInclusi || [],
    };
  }

  // Override che combina informazioni da tutte le classi della gerarchia
  ottieniDettagli() {
    // Chiamiamo il metodo del padre che a sua volta chiama il nonno
    const dettagliElettronico = super.ottieniDettagli();

    // Calcoliamo informazioni specifiche dello smartphone
    const memoriaOccupata = this.appInstallate.reduce(
      (totale, app) => totale + app.dimensione,
      0,
    );
    const memoriaLibera = this.memoriaGB * 1024 - memoriaOccupata;

    return {
      ...dettagliElettronico,
      sistemaOperativo: this.sistemaOperativo,
      memoria: {
        totale: `${this.memoriaGB}GB`,
        occupata: `${(memoriaOccupata / 1024).toFixed(2)}GB`,
        libera: `${(memoriaLibera / 1024).toFixed(2)}GB`,
      },
      fotocamera: `${this.fotocamerMP}MP`,
      appInstallate: this.appInstallate.length,
      batteria: `${this.batteria}%`,
      accessoriInclusi: this.accessoriInclusi || [],
      serviziInclusi: this.serviziInclusi || [],
    };
  }
}

// Esempio completo che dimostra l'uso di super in tutti i contesti
console.log('=== Test Sistema Prodotti con Super ===\n');

// Creiamo prodotti di diversi tipi
const libro = new Prodotto(
  'Il Signore degli Anelli',
  15.99,
  'Libri',
  'Fantasy epic',
);
const laptop = new ProdottoElettronico(
  'MacBook Pro 14"',
  2499.99,
  'Laptop professionale per creativi',
  'Apple',
  'MacBook Pro 2023',
  36,
  { processore: 'M2 Pro', ram: '16GB', ssd: '512GB' },
);

const iPhone = new Smartphone(
  'iPhone 15 Pro',
  1199.99,
  'Smartphone premium con fotocamera avanzata',
  'Apple',
  'iPhone 15 Pro',
  'iOS 17',
  256,
  48,
);

console.log('=== Test Metodi Base (da Prodotto) ===');
libro.aggiungiRecensione(5, 'Capolavoro assoluto!', 'Mario');
laptop.aggiungiRecensione(4, 'Ottimo per il lavoro', 'Anna');
iPhone.aggiungiRecensione(5, 'Camera incredibile', 'Luca');

console.log('\n=== Test Metodi Specializzati ===');
laptop.registraGaranzia('Anna Bianchi', 'anna@email.com');
iPhone.installaApp('Instagram', 250);
iPhone.installaApp('Photoshop Mobile', 500);

console.log('\n=== Test Super in applicaSconto ===');
console.log('--- Sconto Libro (solo metodo base) ---');
libro.applicaSconto(20, 'Saldi estivi');

console.log('\n--- Sconto Laptop (base + elettronico) ---');
laptop.applicaSconto(25, 'Black Friday');

console.log('\n--- Sconto Smartphone (base + elettronico + smartphone) ---');
iPhone.applicaSconto(35, 'Lancio nuovo modello');

console.log('\n=== Test Super in ottieniDettagli ===');
console.log('--- Dettagli Libro ---');
console.log(JSON.stringify(libro.ottieniDettagli(), null, 2));

console.log('\n--- Dettagli Laptop ---');
console.log(JSON.stringify(laptop.ottieniDettagli(), null, 2));

console.log('\n--- Dettagli Smartphone ---');
console.log(JSON.stringify(iPhone.ottieniDettagli(), null, 2));

console.log('\n=== Dimostrazione Polimorfismo con Super ===');
const catalogo = [libro, laptop, iPhone];

console.log('Applicazione sconto del 15% a tutto il catalogo:');
catalogo.forEach(prodotto => {
  console.log(`\n--- ${prodotto.nome} ---`);
  prodotto.applicaSconto(15, 'Sconto fedeltà cliente');
});
```

Questo esempio approfondito mostra come `super` funzioni a diversi livelli della gerarchia di ereditarietà. Ogni classe può chiamare metodi della propria classe padre, che a loro volta possono chiamare metodi della classe nonno, creando una catena di comportamenti che si combinano armoniosamente. L'importante è comprendere che `super` si riferisce sempre alla classe immediatamente superiore nella gerarchia, non necessariamente alla classe radice.

## Metodi e Proprietà Statiche: Funzionalità a Livello di Classe

I metodi e le proprietà statiche rappresentano uno strumento potente per organizzare funzionalità che appartengono alla classe nel suo complesso piuttosto che alle singole istanze. Quando dichiari un metodo o una proprietà come `static`, stai essenzialmente creando qualcosa che esiste a livello della classe e può essere accessibile senza creare un'istanza di quella classe.

Questo concetto è fondamentale per implementare pattern come Factory Methods, Utility Functions, costanti condivise, e contatori globali. Esploriamo questi concetti attraverso un sistema di gestione di una libreria che mostrerà tutti gli aspetti pratici dei membri statici:

```javascript
class BibliotecaDigitale {
  // Proprietà statiche: condivise tra tutte le istanze e accessibili dalla classe
  static contatoreTotaleLibri = 0;
  static bibliotecheCreate = 0;
  static GENERI_SUPPORTATI = [
    'Fiction', 'Saggistica', 'Scienze', 'Storia',
    'Biografie', 'Tecnologia', 'Arte', 'Cucina'
  ];
  static LIMITE_PRESTITI_DEFAULT = 5;
  static DURATA_PRESTITO_GIORNI = 14;

  // Registry statico per tenere traccia di tutte le biblioteche create
  static registryBiblioteche = new Map();

  constructor(nome, indirizzo, capacitaMassima = 10000) {
    this.id = BibliotecaDigitale._generaIdBiblioteca();
    this.nome = nome;
    this.indirizzo = indirizzo;
    this.capacitaMassima = capacitaMassima;
    this.libri = [];
    this.utentiRegistrati = [];
    this.prestitiAttivi = [];
    this.dataCreazione = new Date();

    // Aggiorniamo i contatori statici
    BibliotecaDigitale.bibliotecheCreate++;

    // Registriamo questa biblioteca nel registry statico
    BibliotecaDigitale.registryBiblioteche.set(this.id, this);

    console.log(`Biblioteca "${nome}" creata con ID: ${this.id}`);
  }

  aggiungiLibro(titolo, autore, genere, isbn) {
    // Validazione usando proprietà statiche
    if (!BibliotecaDigitale.GENERI_SUPPORTATI.includes(genere)) {
      throw new Error(`Genere non supportato. Generi validi: ${BibliotecaDigitale.GENERI_SUPPORTATI.join(', ')}`);
    }

    if (this.libri.length >= this.capacitaMassima) {
      throw new Error('Capacità massima della biblioteca raggiunta');
    }

    const libro = {
      id: BibliotecaDigitale._generaIdLibro(),
      titolo,
      autore,
      genere,
      isbn,
      bibliotecaId: this.id,
      disponibile: true,
      dataAggiunta: new Date(),
      numeroPrestitiTotali: 0
    };

    this.libri.push(libro);
    BibliotecaDigitale.contatoreTotaleLibri++;

    console.log(`Libro "${titolo}" aggiunto alla biblioteca ${this.nome}`);
    return libro.id;
  }

  registraUtente(nome, email, tipoAbbonamento = 'base') {
    const utente = {
      id: BibliotecaDigitale._generaIdUtente(),
      nome,
      email,
      tipoAbbonamento,
      dataRegistrazione: new Date(),
      bibliotecaId: this.id,
      limitePrestiti: BibliotecaDigitale._calcolaLimitePrestiti(tipoAbbonamento),
      prestitiAttivi: 0
    };

    this.utentiRegistrati.push(utente);
    console.log(`Utente ${nome} registrato con abbonamento ${tipoAbbonamento}`);
    return utente.id;
  }

  // Metodi statici per operazioni a livello di classe
  static trovaLibroInTutteLeBiblioteche(criterioRicerca, valoreCerca) {
    const risultati = [];

    // Iteriamo attraverso tutte le biblioteche registrate
    for (const biblioteca of BibliotecaDigitale.registryBiblioteche.values()) {
      const libriTrovati = biblioteca.libri.filter(libro => {
        switch(criterioRicerca.toLowerCase()) {
          case 'titolo':
            return libro.titolo.toLowerCase().includes(valoreCerca.toLowerCase());
          case 'autore':
            return libro.autore.toLowerCase().includes(valoreCerca.toLowerCase());
          case 'genere':
            return libro.genere.toLowerCase() === valoreCerca.toLowerCase();
          case 'isbn':
            return libro.isbn === valoreCerca;
          default:
            return false;
        }
      });

      // Aggiungiamo informazioni sulla biblioteca ai risultati
      libriTrovati.forEach(libro => {
        risultati.push({
          ...libro,
          nomeBiblioteca: biblioteca.nome,
          indirizzoBiblioteca: biblioteca.indirizzo
        });
      });
    }

    return risultati;
  }

  static ottieniStatisticheGlobali() {
    let totaleUtenti = 0;
    let totalePrestitiAttivi = 0;
    let distribuzione GeneriMap = new Map();

    for (const biblioteca of BibliotecaDigitale.registryBiblioteche.values()) {
      totaleUtenti += biblioteca.utentiRegistrati.length;
      totalePrestitiAttivi += biblioteca.prestitiAttivi.length;

      // Calcoliamo la distribuzione dei generi
      biblioteca.libri.forEach(libro => {
        const count = distribuzioneGeneri.get(libro.genere) || 0;
        distribuzioneGeneri.set(libro.genere, count + 1);
      });
    }

    return {
      bibliotecheTotali: BibliotecaDigitale.bibliotecheCreate,
      libriTotali: BibliotecaDigitale.contatoreTotaleLibri,
      utentiTotali: totaleUtenti,
      prestitiAttiviTotali: totalePrestitiAttivi,
      distribuzioneGeneri: Object.fromEntries(distribuzioneGeneri),
      generiSupportati: BibliotecaDigitale.GENERI_SUPPORTATI.length
    };
  }

  // Factory method statico per creare biblioteche con configurazioni predefinite
  static creaBibliotecaUniversitaria(nomeUniversita, indirizzo) {
    const biblioteca = new BibliotecaDigitale(
      `Biblioteca ${nomeUniversita}`,
      indirizzo,
      50000 // Capacità maggiore per università
    );

    // Aggiungiamo alcuni libri di base per biblioteche universitarie
    const libriBase = [
      ['Fondamenti di Informatica', 'Autore Vario', 'Tecnologia', '978-1234567890'],
      ['Storia Contemporanea', 'Storico Famoso', 'Storia', '978-1234567891'],
      ['Matematica Discreta', 'Matematico Esperto', 'Scienze', '978-1234567892']
    ];

    libriBase.forEach(([titolo, autore, genere, isbn]) => {
      biblioteca.aggiungiLibro(titolo, autore, genere, isbn);
    });

    console.log(`✅ Biblioteca universitaria creata per ${nomeUniversita} con ${libriBase.length} libri di base`);
    return biblioteca;
  }

  static creaBibliotecaComunale(nomeComune, indirizzo) {
    const biblioteca = new BibliotecaDigitale(
      `Biblioteca Comunale di ${nomeComune}`,
      indirizzo,
      15000
    );

    // Libri più generali per biblioteche comunali
    const libriComunali = [
      ['Ricette della Nonna', 'Chef Tradizionale', 'Cucina', '978-2234567890'],
      ['Arte Rinascimentale', 'Storico Arte', 'Arte', '978-2234567891'],
      ['Biografia di un Leader', 'Biografo Noto', 'Biografie', '978-2234567892']
    ];

    libriComunali.forEach(([titolo, autore, genere, isbn]) => {
      biblioteca.aggiungiLibro(titolo, autore, genere, isbn);
    });

    console.log(`🏛️ Biblioteca comunale creata per ${nomeComune} con ${libriComunali.length} libri di base`);
    return biblioteca;
  }

  // Utiliry method statico per validazione
  static validaIsbn(isbn) {
    // Rimuove trattini e spazi
    const isbnPulito = isbn.replace(/[-\s]/g, '');

    // Controlla lunghezza (ISBN-10 o ISBN-13)
    if (isbnPulito.length !== 10 && isbnPulito.length !== 13) {
      return false;
    }

    // Controllo base: tutti caratteri numerici
    return /^\d+$/.test(isbnPulito);
  }

  static confrontaBiblioteche(idBiblioteca1, idBiblioteca2) {
    const bib1 = BibliotecaDigitale.registryBiblioteche.get(idBiblioteca1);
    const bib2 = BibliotecaDigitale.registryBiblioteche.get(idBiblioteca2);

    if (!bib1 || !bib2) {
      throw new Error('Una o entrambe le biblioteche non esistono');
    }

    return {
      biblioteca1: {
        nome: bib1.nome,
        libri: bib1.libri.length,
        utenti: bib1.utentiRegistrati.length,
        capacita: bib1.capacitaMassima
      },
      biblioteca2: {
        nome: bib2.nome,
        libri: bib2.libri.length,
        utenti: bib2.utentiRegistrati.length,
        capacita: bib2.capacitaMassima
      },
      migliorePerLibri: bib1.libri.length > bib2.libri.length ? bib1.nome : bib2.nome,
      migliorePerUtenti: bib1.utentiRegistrati.length > bib2.utentiRegistrati.length ? bib1.nome : bib2.nome
    };
  }

  // Metodi statici privati (convenzione con _)
  static _generaIdBiblioteca() {
    return `BIB-${Date.now()}-${Math.random().toString(36).substring(2, 7).toUpperCase()}`;
  }

  static _generaIdLibro() {
    return `BOOK-${Date.now()}-${Math.random().toString(36).substring(2, 7).toUpperCase()}`;
  }

  static _generaIdUtente() {
    return `USER-${Date.now()}-${Math.random().toString(36).substring(2, 7).toUpperCase()}`;
  }

  static _calcolaLimitePrestiti(tipoAbbonamento) {
    switch(tipoAbbonamento.toLowerCase()) {
      case 'premium':
        return BibliotecaDigitale.LIMITE_PRESTITI_DEFAULT * 2;
      case 'studente':
        return BibliotecaDigitale.LIMITE_PRESTITI_DEFAULT + 3;
      case 'base':
      default:
        return BibliotecaDigitale.LIMITE_PRESTITI_DEFAULT;
    }
  }

  // Metodo statico per cleanup (utile per testing)
  static resetGlobalState() {
    BibliotecaDigitale.contatoreTotaleLibri = 0;
    BibliotecaDigitale.bibliotecheCreate = 0;
    BibliotecaDigitale.registryBiblioteche.clear();
    console.log('🔄 Stato globale delle biblioteche resettato');
  }
}

// Esempi pratici di utilizzo dei metodi e proprietà statiche
console.log('=== Demo Sistema Biblioteca con Membri Statici ===\n');

console.log('=== Creazione Biblioteche con Factory Methods ===');
const bibUniBocconi = BibliotecaDigitale.creaBibliotecaUniversitaria('Bocconi', 'Via Bocconi 1, Milano');
const bibComuneMilano = BibliotecaDigitale.creaBibliotecaComunale('Milano', 'Piazza Duomo, Milano');
const bibManuale = new BibliotecaDigitale('Biblioteca Personale', 'Via Casa Mia 1', 1000);

console.log('\n=== Test Proprietà Statiche ===');
console.log('Generi supportati:', BibliotecaDigitale.GENERI_SUPPORTATI);
console.log('Limite prestiti default:', BibliotecaDigitale.LIMITE_PRESTITI_DEFAULT);
console.log('Contatore totale libri:', BibliotecaDigitale.contatoreTotaleLibri);
console.log('Biblioteche create:', BibliotecaDigitale.bibliotecheCreate);

console.log('\n=== Aggiunta Libri e Utenti ===');
bibManuale.aggiungiLibro('Design Patterns', 'Gang of Four', 'Tecnologia', '978-0123456789');
bibManuale.aggiungiLibro('Clean Code', 'Robert Martin', 'Tecnologia', '978-0123456788');
bibUniBocconi.aggiungiLibro('Economia Aziendale', 'Esperto Economia', 'Saggistica', '978-0987654321');

bibManuale.registraUtente('Marco Sviluppatore', 'marco@email.com', 'premium');
bibUniBocconi.registraUtente('Anna Studentessa', 'anna@university.com', 'studente');

console.log('\n=== Test Ricerca Globale (Metodo Statico) ===');
const libriTecnologia = BibliotecaDigitale.trovaLibroInTutteLeBiblioteche('genere', 'Tecnologia');
console.log('Libri di tecnologia trovati in tutte le biblioteche:');
libriTecnologia.forEach(libro => {
  console.log(`- "${libro.titolo}" presso ${libro.nomeBiblioteca}`);
});

console.log('\n=== Statistiche Globali (Metodo Statico) ===');
const statistiche = BibliotecaDigitale.ottieniStatisticheGlobali();
console.log('Statistiche del sistema:');
console.log(JSON.stringify(statistiche, null, 2));

console.log('\n=== Confronto Biblioteche (Metodo Statico) ===');
try {
  const confronto = BibliotecaDigitale.confrontaBiblioteche(bibUniBocconi.id, bibManuale.id);
  console.log('Confronto biblioteche:');
  console.log(JSON.stringify(confronto, null, 2));
} catch (error) {
  console.log('Errore nel confronto:', error.message);
}

console.log('\n=== Test Utility Statiche ===');
console.log('ISBN valido 978-0123456789?', BibliotecaDigitale.validaIsbn('978-0123456789'));
console.log('ISBN valido 123?', BibliotecaDigitale.validaIsbn('123'));

console.log('\n=== Accesso Registry Statico ===');
console.log('Biblioteche nel registry:');
for (const [id, biblioteca] of BibliotecaDigitale.registryBiblioteche) {
  console.log(`${id}: ${biblioteca.nome} (${biblioteca.libri.length} libri)`);
}

// Dimostrazione che i metodi statici non possono accedere a 'this'
console.log('\n=== Test Indipendenza Metodi Statici ===');
// I metodi statici possono essere chiamati anche senza istanze
const statisticheSenzaIstanza = BibliotecaDigitale.ottieniStatisticheGlobali();
console.log('Statistiche accessibili senza istanza:', statisticheSenzaIstanza.bibliotecheTotali > 0);
```

I metodi e le proprietà statiche forniscono un modo elegante per organizzare funzionalità che appartengono concettualmente alla classe ma non a singole istanze specifiche. Sono particolarmente utili per implementare pattern come Singleton, Factory, Registry, e per fornire utility functions che operano su dati globali o che non necessitano di accesso allo stato dell'istanza.

## Getters e Setters: Controllo Elegante dell'Accesso ai Dati

I getters e setters rappresentano uno dei meccanismi più eleganti per implementare l'incapsulamento nelle classi ES6. Essi permettono di definire proprietà che si comportano come semplici variabili dall'esterno, ma che internamente eseguono logica personalizzata per la lettura o la scrittura dei valori. Questo approccio offre un perfetto equilibrio tra semplicità d'uso e controllo fine sul comportamento degli oggetti.

La potenza dei getters e setters risiede nella loro capacità di nascondere la complessità implementativa dietro un'interfaccia semplice e intuitiva. Possono validare input, calcolare valori derivati, implementare lazy loading, mantenere coerenza tra proprietà correlate, e molto altro. Esploriamo questi concetti attraverso un sistema di gestione finanziaria personale:

```javascript
class ContoCorrente {
  // Proprietà private (convenzione con underscore)
  constructor(titolare, saldoIniziale = 0, tipoConto = 'standard') {
    this._titolare = titolare;
    this._saldo = 0; // Inizializzato a zero, poi impostato tramite setter
    this._tipoConto = tipoConto;
    this._transazioni = [];
    this._limitePrelievoGiornaliero = this._calcolaLimitePrelievo(tipoConto);
    this._prelieviOggi = 0;
    this._dataUltimoPrelievo = null;
    this._contoBloccato = false;
    this._dataCreazioneString = new Date().toISOString();

    // Usiamo il setter per impostare il saldo iniziale (con tutte le validazioni)
    if (saldoIniziale > 0) {
      this.saldo = saldoIniziale;
    }

    console.log(
      `Conto corrente creato per ${titolare} con saldo iniziale di €${this._saldo}`,
    );
  }

  // Getter per il saldo: accesso semplice ma con possibilità di logica aggiuntiva
  get saldo() {
    // Possiamo aggiungere logging, controlli di sicurezza, etc.
    if (this._contoBloccato) {
      throw new Error('Impossibile accedere al saldo: conto bloccato');
    }

    return this._saldo;
  }

  // Setter per il saldo: controllo completo su come il valore viene impostato
  set saldo(nuovoSaldo) {
    // Validazione del tipo
    if (typeof nuovoSaldo !== 'number' || isNaN(nuovoSaldo)) {
      throw new Error('Il saldo deve essere un numero valido');
    }

    // Validazione del valore
    if (nuovoSaldo < 0 && this._tipoConto !== 'premium') {
      throw new Error('Saldo negativo non permesso per conti standard');
    }

    if (nuovoSaldo < -1000 && this._tipoConto === 'premium') {
      throw new Error(
        'Saldo non può essere inferiore a -€1000 anche per conti premium',
      );
    }

    // Registriamo la transazione se c'è una variazione
    const variazione = nuovoSaldo - this._saldo;
    if (variazione !== 0) {
      this._registraTransazione(
        variazione > 0 ? 'deposito' : 'prelievo',
        Math.abs(variazione),
        `Regolazione saldo${variazione > 0 ? ' (deposito)' : ' (prelievo)'}`,
      );
    }

    this._saldo = nuovoSaldo;

    // Controlli automatici basati sul nuovo saldo
    this._verificaStatoConto();
  }

  // Getter per proprietà calcolate/derivate
  get saldoFormattato() {
    const segno = this._saldo >= 0 ? '' : '-';
    const valore = Math.abs(this._saldo);
    return `€${segno}${valore.toLocaleString('it-IT', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
  }

  get bilanciaMensile() {
    const oggi = new Date();
    const inizioMese = new Date(oggi.getFullYear(), oggi.getMonth(), 1);

    const transazioniMese = this._transazioni.filter(
      t => new Date(t.data) >= inizioMese,
    );

    const entrate = transazioniMese
      .filter(t => t.tipo === 'deposito')
      .reduce((totale, t) => totale + t.importo, 0);

    const uscite = transazioniMese
      .filter(t => t.tipo === 'prelievo')
      .reduce((totale, t) => totale + t.importo, 0);

    return {
      periodo: `${inizioMese.toLocaleDateString('it-IT')} - ${oggi.toLocaleDateString('it-IT')}`,
      entrate: entrate,
      uscite: uscite,
      bilancio: entrate - uscite,
      numeroTransazioni: transazioniMese.length,
    };
  }

  get statusConto() {
    if (this._contoBloccato) {
      return 'BLOCCATO';
    } else if (this._saldo < 0) {
      return 'IN ROSSO';
    } else if (this._saldo > 10000) {
      return 'ELEVATO';
    } else if (this._saldo < 100) {
      return 'BASSO';
    } else {
      return 'NORMALE';
    }
  }

  // Getter per dati read-only
  get titolare() {
    return this._titolare;
  }

  get numeroTransazioni() {
    return this._transazioni.length;
  }

  get dataCreazione() {
    return new Date(this._dataCreazioneString);
  }

  // Setter per il tipo di conto con logica di validazione complessa
  get tipoConto() {
    return this._tipoConto;
  }

  set tipoConto(nuovoTipo) {
    const tipiValidi = ['standard', 'premium', 'business'];

    if (!tipiValidi.includes(nuovoTipo)) {
      throw new Error(
        `Tipo di conto non valido. Tipi supportati: ${tipiValidi.join(', ')}`,
      );
    }

    if (nuovoTipo === this._tipoConto) {
      console.log(`Il conto è già di tipo ${nuovoTipo}`);
      return;
    }

    const vecchioTipo = this._tipoConto;
    this._tipoConto = nuovoTipo;

    // Aggiorniamo il limite di prelievo in base al nuovo tipo
    this._limitePrelievoGiornaliero = this._calcolaLimitePrelievo(nuovoTipo);

    // Se passiamo da premium a standard, controlliamo se il saldo è valido
    if (
      vecchioTipo === 'premium' &&
      nuovoTipo === 'standard' &&
      this._saldo < 0
    ) {
      console.log(
        '⚠️  Attenzione: passando a conto standard con saldo negativo, il conto verrà bloccato',
      );
      this._contoBloccato = true;
    }

    this._registraTransazione(
      'sistema',
      0,
      `Tipo conto cambiato da ${vecchioTipo} a ${nuovoTipo}`,
    );

    console.log(`Tipo di conto aggiornato da ${vecchioTipo} a ${nuovoTipo}`);
    console.log(
      `Nuovo limite prelievo giornaliero: €${this._limitePrelievoGiornaliero}`,
    );
  }

  // Getter e setter per controllo avanzato del limite prelievo
  get limitePrelievoGiornaliero() {
    return this._limitePrelievoGiornaliero;
  }

  set limitePrelievoGiornaliero(nuovoLimite) {
    if (typeof nuovoLimite !== 'number' || nuovoLimite <= 0) {
      throw new Error('Il limite deve essere un numero positivo');
    }

    const limiteStandard = this._calcolaLimitePrelievo(this._tipoConto);

    // Solo i conti premium e business possono avere limiti personalizzati
    if (this._tipoConto === 'standard' && nuovoLimite > limiteStandard) {
      throw new Error(
        'I conti standard non possono avere limiti superiori a quelli predefiniti',
      );
    }

    if (nuovoLimite > 5000) {
      console.log(
        '⚠️  Limite molto elevato: potrebbe richiedere approvazione manuale',
      );
    }

    const vecchioLimite = this._limitePrelievoGiornaliero;
    this._limitePrelievoGiornaliero = nuovoLimite;

    this._registraTransazione(
      'sistema',
      0,
      `Limite prelievo cambiato da €${vecchioLimite} a €${nuovoLimite}`,
    );

    console.log(`Limite prelievo giornaliero aggiornato: €${nuovoLimite}`);
  }

  // Metodi pubblici che utilizzano getters e setters internamente
  deposita(importo, descrizione = 'Deposito') {
    if (typeof importo !== 'number' || importo <= 0) {
      throw new Error("L'importo deve essere un numero positivo");
    }

    // Usiamo il setter per beneficiare di tutte le validazioni
    this.saldo += importo;

    console.log(`Depositato ${importo}€. Nuovo saldo: ${this.saldoFormattato}`);
    return this.saldo;
  }

  preleva(importo, descrizione = 'Prelievo') {
    if (typeof importo !== 'number' || importo <= 0) {
      throw new Error("L'importo deve essere un numero positivo");
    }

    // Controlli specifici per i prelievi
    this._verificaLimitePrelievoGiornaliero(importo);

    // Controllo se il prelievo è possibile
    const nuovoSaldo = this.saldo - importo;
    if (this._tipoConto === 'standard' && nuovoSaldo < 0) {
      throw new Error('Saldo insufficiente per conti standard');
    }

    if (this._tipoConto === 'premium' && nuovoSaldo < -1000) {
      throw new Error('Limite di scoperto raggiunto');
    }

    // Usiamo il setter per il saldo
    this.saldo = nuovoSaldo;

    // Aggiorniamo il tracker dei prelievi giornalieri
    this._aggiornaPrelievoGiornaliero(importo);

    console.log(`Prelevato ${importo}€. Nuovo saldo: ${this.saldoFormattato}`);
    return this.saldo;
  }

  // Metodi privati di supporto
  _calcolaLimitePrelievo(tipoConto) {
    switch (tipoConto) {
      case 'premium':
        return 2000;
      case 'business':
        return 5000;
      default:
        return 500;
    }
  }

  _verificaLimitePrelievoGiornaliero(importoPrelievo) {
    const oggi = new Date().toDateString();

    // Reset del contatore se è un nuovo giorno
    if (!this._dataUltimoPrelievo || this._dataUltimoPrelievo !== oggi) {
      this._prelieviOggi = 0;
      this._dataUltimoPrelievo = oggi;
    }

    if (
      this._prelieviOggi + importoPrelievo >
      this._limitePrelievoGiornaliero
    ) {
      throw new Error(
        `Limite prelievo giornaliero superato. ` +
          `Disponibili: €${this._limitePrelievoGiornaliero - this._prelieviOggi}, ` +
          `richiesti: €${importoPrelievo}`,
      );
    }
  }

  _aggiornaPrelievoGiornaliero(importo) {
    this._prelieviOggi += importo;
  }

  _registraTransazione(tipo, importo, descrizione) {
    const transazione = {
      id: Date.now() + Math.random().toString(36).substring(2),
      tipo: tipo,
      importo: importo,
      descrizione: descrizione,
      data: new Date().toISOString(),
      saldoDopoTransazione: this._saldo,
    };

    this._transazioni.push(transazione);
  }

  _verificaStatoConto() {
    // Logica automatica basata sul saldo
    if (this._saldo < -500 && this._tipoConto === 'premium') {
      console.log('⚠️  Attenzione: saldo molto basso, considera un deposito');
    }

    if (this._saldo > 50000) {
      console.log('💡 Suggerimento: considera investimenti per saldi elevati');
    }
  }

  // Metodo per ottenere un report completo che usa tutti i getters
  ottieniReportCompleto() {
    return {
      titolare: this.titolare,
      tipoConto: this.tipoConto,
      saldo: this.saldo,
      saldoFormattato: this.saldoFormattato,
      statusConto: this.statusConto,
      limitePrelievoGiornaliero: this.limitePrelievoGiornaliero,
      bilanciaMensile: this.bilanciaMensile,
      numeroTransazioni: this.numeroTransazioni,
      dataCreazione: this.dataCreazione,
      prelieviOggiRemaining:
        this._limitePrelievoGiornaliero - this._prelieviOggi,
    };
  }
}

// Test completo del sistema con getters e setters
console.log('=== Demo Sistema Conto Corrente con Getters/Setters ===\n');

console.log('=== Creazione Conto e Test Getters Base ===');
const contoMario = new ContoCorrente('Mario Rossi', 1000, 'standard');

console.log(`Titolare: ${contoMario.titolare}`);
console.log(`Saldo: ${contoMario.saldo}€`);
console.log(`Saldo formattato: ${contoMario.saldoFormattato}`);
console.log(`Status: ${contoMario.statusConto}`);
console.log(`Tipo conto: ${contoMario.tipoConto}`);

console.log('\n=== Test Setters con Validazione ===');
try {
  console.log('Tentativo di impostare saldo negativo su conto standard...');
  contoMario.saldo = -100; // Dovrebbe fallire
} catch (error) {
  console.log(`❌ Errore previsto: ${error.message}`);
}

try {
  console.log('Tentativo di impostare tipo conto non valido...');
  contoMario.tipoConto = 'platinum'; // Dovrebbe fallire
} catch (error) {
  console.log(`❌ Errore previsto: ${error.message}`);
}

console.log('\n=== Upgrade a Conto Premium ===');
contoMario.tipoConto = 'premium';
console.log(`Nuovo limite prelievo: €${contoMario.limitePrelievoGiornaliero}`);

// Ora possiamo andare in rosso
contoMario.saldo = -200;
console.log(`Saldo dopo modifica: ${contoMario.saldoFormattato}`);
console.log(`Status conto: ${contoMario.statusConto}`);

console.log('\n=== Test Operazioni e Getters Calcolati ===');
contoMario.deposita(1500, 'Stipendio');
contoMario.preleva(300, 'Spesa supermercato');
contoMario.preleva(150, 'Benzina');

console.log('\nBilancia mensile:');
const bilancia = contoMario.bilanciaMensile;
console.log(`Periodo: ${bilancia.periodo}`);
console.log(`Entrate: €${bilancia.entrate}`);
console.log(`Uscite: €${bilancia.uscite}`);
console.log(`Bilancio: €${bilancia.bilancio}`);

console.log('\n=== Test Limite Prelievo Personalizzato ===');
console.log(`Limite attuale: €${contoMario.limitePrelievoGiornaliero}`);
contoMario.limitePrelievoGiornaliero = 3000;
console.log(`Nuovo limite: €${contoMario.limitePrelievoGiornaliero}`);

console.log('\n=== Report Completo (usa tutti i getters) ===');
const report = contoMario.ottieniReportCompleto();
console.log(JSON.stringify(report, null, 2));

console.log('\n=== Test Conto Business ===');
const contoBusiness = new ContoCorrente('Azienda ABC', 10000, 'business');
contoBusiness.limitePrelievoGiornaliero = 4500;

console.log(
  `Conto business - Limite: €${contoBusiness.limitePrelievoGiornaliero}`,
);
console.log(`Status: ${contoBusiness.statusConto}`);
console.log(`Saldo formattato: ${contoBusiness.saldoFormattato}`);
```

I getters e setters forniscono un meccanismo potente per implementare un'interfaccia semplice che nasconde complessità implementativa. Permettono di mantenere il codice client pulito e intuitivo mentre garantiscono che tutte le invarianti dell'oggetto siano sempre rispettate. Questo approccio è fondamentale per creare classi robuste e maintainable in JavaScript moderno.

## Esercizi Pratici per Consolidare l'Apprendimento

Per padroneggiare completamente le classi ES6 e l'ereditarietà, è essenziale applicare tutti i concetti appresi in scenari realistici e complessi. I seguenti tre esercizi sono progettati per sfidare la tua comprensione a livelli crescenti di complessità, coprendo tutti gli aspetti delle classi moderne che abbiamo esplorato.

### Esercizio 1 (Livello Base): Sistema di Gestione Biblioteca Scolastica

Questo primo esercizio ti guiderà nella creazione di un sistema completo per gestire una biblioteca scolastica, implementando i concetti fondamentali delle classi ES6.

```javascript
/**
 * Esercizio 1: Sistema di Gestione Biblioteca Scolastica
 *
 * Crea un sistema per gestire una biblioteca scolastica con le seguenti specifiche:
 *
 * CLASSE BASE: Risorsa
 * - Proprietà: id, titolo, autore/creatore, annoPublicazione, genere, disponibile
 * - Metodi: prenotare(), restituire(), ottieniInfo(), calcolaAntichia()
 * - Proprietà statiche: contatoreTotaleRisorse, GENERI_DISPONIBILI
 * - Metodi statici: trovaPerGenere(), ottieniStatistiche()
 *
 * CLASSI DERIVATE:
 * - Libro (estende Risorsa): pagine, isbn, casaEditrice
 * - Rivista (estende Risorsa): numeroEdizione, frequenzaPublicazione
 * - MaterialeMultimediale (estende Risorsa): formato, durata, tipoContenuto
 *
 * OBIETTIVI DI APPRENDIMENTO:
 * - Constructor e super()
 * - Ereditarietà e override di metodi
 * - Proprietà e metodi statici
 * - Getters e setters per proprietà calcolate
 * - Gestione dello stato interno
 */

// Inizia qui la tua implementazione...

class Risorsa {
  // Proprietà statiche per tenere traccia di tutte le risorse
  static contatoreTotaleRisorse = 0;
  static GENERI_DISPONIBILI = [
    'Fiction',
    'Saggistica',
    'Scienze',
    'Storia',
    'Arte',
    'Tecnologia',
    'Sport',
    'Cucina',
    'Viaggi',
  ];
  static _registroRisorse = []; // Array per tenere traccia di tutte le risorse

  constructor(titolo, autoreCreatore, annoPublicazione, genere) {
    // Il tuo compito: implementa il constructor
    // - Valida i parametri (titolo e autore/creatore non possono essere vuoti)
    // - Verifica che il genere sia in GENERI_DISPONIBILI
    // - Genera un ID unico per la risorsa
    // - Inizializza disponibile a true
    // - Incrementa contatoreTotaleRisorse
    // - Aggiungi questa risorsa al registro statico
    // Implementa qui...
  }

  prenotare(nomeUtente) {
    // Il tuo compito: implementa la logica di prenotazione
    // - Controlla se la risorsa è disponibile
    // - Se disponibile, imposta disponibile a false e registra chi l'ha prenotata
    // - Registra la data di prenotazione
    // - Restituisce un messaggio di successo o errore
    // Implementa qui...
  }

  restituire() {
    // Il tuo compito: implementa la logica di restituzione
    // - Controlla se la risorsa era effettivamente prenotata
    // - Rimette disponibile a true
    // - Cancella le informazioni di prenotazione
    // - Restituisce un messaggio di successo o errore
    // Implementa qui...
  }

  ottieniInfo() {
    // Il tuo compito: restituisci un oggetto con tutte le informazioni della risorsa
    // Includi anche l'antichità calcolata
    // Implementa qui...
  }

  calcolaAntichita() {
    // Il tuo compito: calcola quanti anni ha la risorsa
    // Restituisci il numero di anni dalla pubblicazione
    // Implementa qui...
  }

  // Getters e setters
  get etichettaCompleta() {
    // Il tuo compito: restituisci una stringa nel formato:
    // "TITOLO di AUTORE (ANNO) - Genere: GENERE"
    // Implementa qui...
  }

  get statusPrenotazione() {
    // Il tuo compito: restituisci "Disponibile" o "Prenotato da NOME_UTENTE"
    // Implementa qui...
  }

  // Metodi statici
  static trovaPerGenere(genere) {
    // Il tuo compito: filtra tutte le risorse per genere
    // Restituisci un array di risorse che corrispondono al genere specificato
    // Implementa qui...
  }

  static ottieniStatistiche() {
    // Il tuo compito: calcola e restituisci statistiche globali:
    // - Totale risorse
    // - Risorse disponibili vs prenotate
    // - Distribuzione per genere
    // - Risorsa più vecchia e più recente
    // Implementa qui...
  }

  static _generaId() {
    return (
      'RES-' +
      Date.now() +
      '-' +
      Math.random().toString(36).substring(2, 7).toUpperCase()
    );
  }
}

class Libro extends Risorsa {
  constructor(
    titolo,
    autore,
    annoPublicazione,
    genere,
    pagine,
    isbn,
    casaEditrice,
  ) {
    // Il tuo compito:
    // - Chiama super() con i parametri appropriati
    // - Inizializza le proprietà specifiche del libro
    // - Valida che pagine sia un numero positivo
    // - Valida il formato dell'ISBN (deve essere una stringa di 10 o 13 caratteri numerici)
    // Implementa qui...
  }

  // Override del metodo padre
  ottieniInfo() {
    // Il tuo compito:
    // - Chiama super.ottieniInfo() per ottenere le informazioni base
    // - Aggiungi le informazioni specifiche del libro (pagine, isbn, casa editrice)
    // - Calcola e aggiungi la "densità" (pagine per anno di età)
    // Implementa qui...
  }

  get categoriaSpessore() {
    // Il tuo compito: restituisci una categoria basata sul numero di pagine
    // - Meno di 100: "Opuscolo"
    // - 100-300: "Libro normale"
    // - 300-500: "Libro corposo"
    // - Oltre 500: "Libro voluminoso"
    // Implementa qui...
  }

  get tempoLetturaStimato() {
    // Il tuo compito: calcola il tempo di lettura stimato
    // Assumi una velocità di lettura di 250 parole al minuto
    // Stima circa 250 parole per pagina
    // Restituisci il tempo in ore e minuti
    // Implementa qui...
  }
}

class Rivista extends Risorsa {
  constructor(
    titolo,
    editore,
    annoPublicazione,
    genere,
    numeroEdizione,
    frequenzaPublicazione,
  ) {
    // Il tuo compito:
    // - Chiama super() (l'editore sarà il "creatore")
    // - Inizializza numeroEdizione e frequenzaPublicazione
    // - Valida che numeroEdizione sia positivo
    // - Valida che frequenzaPublicazione sia uno dei valori: 'settimanale', 'mensile', 'bimestrale', 'trimestrale'
    // Implementa qui...
  }

  ottieniInfo() {
    // Il tuo compito: estendi le informazioni base con quelle specifiche della rivista
    // Implementa qui...
  }

  get isCurrent() {
    // Il tuo compito: determina se la rivista è "attuale"
    // Una rivista è considerata attuale se è stata pubblicata negli ultimi 2 anni
    // Implementa qui...
  }

  calcolaProssimaEdizione() {
    // Il tuo compito: calcola quando dovrebbe uscire la prossima edizione
    // Basati sulla frequenza di pubblicazione
    // Restituisci una data stimata
    // Implementa qui...
  }
}

class MaterialeMultimediale extends Risorsa {
  constructor(
    titolo,
    creatore,
    annoPublicazione,
    genere,
    formato,
    durata,
    tipoContenuto,
  ) {
    // Il tuo compito:
    // - Chiama super()
    // - Inizializza formato (es: "DVD", "Blu-ray", "Digital"), durata (in minuti), tipoContenuto (es: "Film", "Documentario", "Serie TV")
    // - Valida che durata sia un numero positivo
    // - Valida che formato sia uno dei formati supportati
    // Implementa qui...
  }

  static FORMATI_SUPPORTATI = ['DVD', 'Blu-ray', 'Digital', 'VHS', 'CD'];
  static TIPI_CONTENUTO = [
    'Film',
    'Documentario',
    'Serie TV',
    'Corso',
    'Musica',
  ];

  ottieniInfo() {
    // Il tuo compito: estendi le informazioni base con quelle specifiche del materiale multimediale
    // Includi anche la durata formattata (ore:minuti)
    // Implementa qui...
  }

  get durataFormattata() {
    // Il tuo compito: converte la durata da minuti a formato "Xh Ymin"
    // Esempio: 150 minuti = "2h 30min"
    // Implementa qui...
  }

  get categoriaContenuto() {
    // Il tuo compito: classifica il contenuto in base alla durata
    // - Meno di 30 min: "Contenuto breve"
    // - 30-90 min: "Contenuto standard"
    // - 90-180 min: "Contenuto lungo"
    // - Oltre 180 min: "Contenuto esteso"
    // Implementa qui...
  }
}

// Classe per gestire l'intera biblioteca
class BibliotecaScolastica {
  constructor(nomeBiblioteca, indirizzoScuola) {
    this.nome = nomeBiblioteca;
    this.indirizzo = indirizzoScuola;
    this.dataApertura = new Date();
    this.utentiRegistrati = [];
  }

  registraUtente(nome, classe, email) {
    // Il tuo compito: implementa la registrazione di un nuovo utente
    // - Controlla che non esista già un utente con la stessa email
    // - Crea un oggetto utente con ID unico
    // - Aggiungi alla lista utentiRegistrati
    // Implementa qui...
  }

  cercaRisorsa(criteriocerca, valoreCerca) {
    // Il tuo compito: implementa una funzione di ricerca flessibile
    // Criteri supportati: 'titolo', 'autore', 'genere', 'anno'
    // Restituisci tutte le risorse che corrispondono ai criteri
    // Implementa qui...
  }

  ottieniReportCompleto() {
    // Il tuo compito: genera un report completo della biblioteca
    // - Informazioni generali (nome, indirizzo, data apertura)
    // - Statistiche risorse (usa il metodo statico di Risorsa)
    // - Numero utenti registrati
    // - Top 5 generi più popolari
    // - Risorse attualmente prenotate
    // Implementa qui...
  }
}

// Test del tuo sistema
function testSistemaBiblioteca() {
  console.log('=== Test Sistema Biblioteca Scolastica ===\n');

  // Crea la biblioteca
  const biblioteca = new BibliotecaScolastica(
    'Biblioteca Liceo Da Vinci',
    'Via della Scienza 123',
  );

  // Registra alcuni utenti
  biblioteca.registraUtente('Mario Rossi', '3A', 'mario.rossi@scuola.it');
  biblioteca.registraUtente('Anna Bianchi', '4B', 'anna.bianchi@scuola.it');

  // Aggiungi risorse di diversi tipi
  const libro1 = new Libro(
    'Il Signore degli Anelli',
    'J.R.R. Tolkien',
    1954,
    'Fiction',
    1216,
    '9780007525546',
    'HarperCollins',
  );
  const libro2 = new Libro(
    'Sapiens',
    'Yuval Noah Harari',
    2011,
    'Saggistica',
    443,
    '9780062316097',
    'Harper',
  );

  const rivista1 = new Rivista(
    'National Geographic',
    'National Geographic Society',
    2023,
    'Scienze',
    287,
    'mensile',
  );
  const rivista2 = new Rivista(
    'Focus Storia',
    'Mondadori',
    2023,
    'Storia',
    156,
    'mensile',
  );

  const dvd1 = new MaterialeMultimediale(
    'Cosmos',
    'Carl Sagan',
    1980,
    'Scienze',
    'DVD',
    780,
    'Documentario',
  );
  const bluray1 = new MaterialeMultimediale(
    'Inception',
    'Christopher Nolan',
    2010,
    'Fiction',
    'Blu-ray',
    148,
    'Film',
  );

  // Test delle funzionalità
  console.log('=== Test Informazioni Risorse ===');
  console.log('Libro 1:', libro1.etichettaCompleta);
  console.log('Categoria spessore:', libro1.categoriaSpessore);
  console.log('Tempo lettura stimato:', libro1.tempoLetturaStimato);

  console.log('\nRivista 1:', rivista1.etichettaCompleta);
  console.log('È attuale?', rivista1.isCurrent);

  console.log('\nDVD 1:', dvd1.etichettaCompleta);
  console.log('Durata formattata:', dvd1.durataFormattata);
  console.log('Categoria contenuto:', dvd1.categoriaContenuto);

  console.log('\n=== Test Prenotazioni ===');
  console.log(libro1.prenotare('Mario Rossi'));
  console.log('Status:', libro1.statusPrenotazione);

  console.log(libro1.prenotare('Anna Bianchi')); // Dovrebbe fallire

  console.log(libro1.restituire());
  console.log('Status dopo restituzione:', libro1.statusPrenotazione);

  console.log('\n=== Test Metodi Statici ===');
  const libriFiction = Risorsa.trovaPerGenere('Fiction');
  console.log(`Trovati ${libriFiction.length} risorse di Fiction`);

  const statistiche = Risorsa.ottieniStatistiche();
  console.log('Statistiche globali:', statistiche);

  console.log('\n=== Test Ricerca ===');
  const risultatiRicerca = biblioteca.cercaRisorsa('genere', 'Scienze');
  console.log(`Trovate ${risultatiRicerca.length} risorse di Scienze`);

  console.log('\n=== Report Completo ===');
  const report = biblioteca.ottieniReportCompleto();
  console.log(JSON.stringify(report, null, 2));
}

// Esegui il test quando hai completato l'implementazione
// testSistemaBiblioteca();
```

### Esercizio 2 (Livello Intermedio): Sistema di Gestione E-commerce

Questo esercizio intermedio ti sfiderà con concetti più avanzati come polimorfismo, design patterns, e gestione di stati complessi.

```javascript
/**
 * Esercizio 2: Sistema di Gestione E-commerce Avanzato
 *
 * Crea un sistema e-commerce completo che gestisca prodotti, ordini, utenti e pagamenti.
 *
 * GERARCHIA PRODOTTI:
 * - Classe base Prodotto: id, nome, prezzo, descrizione, categoria, stock, recensioni
 * - ProdottoFisico: peso, dimensioni, costoSpedizione, metodiSpedizione
 * - ProdottoDigitale: dimensioneFile, formatoFile, linkDownload, limitDownload
 * - Abbonamento: durataMesi, rinnovo Automatico, benefici, prezzoMensile
 *
 * SISTEMA UTENTI:
 * - Utente base: dati anagrafici, indirizzi, metodiPagamento, storicoOrdini
 * - UtenteVIP: scontoPercentuale, spedizioneGratuita, supportoPrioritario
 *
 * GESTIONE ORDINI:
 * - Ordine: prodotti, quantità, totale, stato, metodoPagamento, indirizzoSpedizione
 * - Stati: 'in_sospeso', 'confermato', 'in_lavorazione', 'spedito', 'consegnato', 'annullato'
 *
 * OBIETTIVI DI APPRENDIMENTO:
 * - Ereditarietà multipla e polimorfismo avanzato
 * - Getters/setters per logica business complessa
 * - Metodi statici per operazioni globali
 * - Pattern Observer per notifiche
 * - Gestione stati con validazioni
 */

// Inizia qui la tua implementazione...

// Enums simulati per mantenere consistenza
const CATEGORIE_PRODOTTI = {
  ELETTRONICA: 'elettronica',
  ABBIGLIAMENTO: 'abbigliamento',
  LIBRI: 'libri',
  CASA: 'casa',
  SPORT: 'sport',
  DIGITALE: 'digitale'
};

const STATI_ORDINE = {
  IN_SOSPESO: 'in_sospeso',
  CONFERMATO: 'confermato',
  IN_LAVORAZIONE: 'in_lavorazione',
  SPEDITO: 'spedito',
  CONSEGNATO: 'consegnato',
  ANNULLATO: 'annullato'
};

const TIPI_UTENTE = {
  BASE: 'base',
  VIP: 'vip',
  PREMIUM: 'premium'
};

class Prodotto {
  static contatoreTotaleProdotti = 0;
  static catalogoCompleto = [];
  static recensioniTotali = 0;

  constructor(nome, prezzo, descrizione, categoria) {
    // Il tuo compito: implementa il constructor base
    // - Genera ID unico
    // - Valida parametri (prezzo deve essere positivo, categoria deve essere valida)
    // - Inizializza stock a 0, recensioni array vuoto
    // - Aggiungi al catalogo completo
    // - Incrementa contatore

    // Implementa qui...
  }

  aggiungiRecensione(voto, commento, nomeUtente) {
    // Il tuo compito: implementa sistema recensioni
    // - Valida voto (1-5)
    // - Crea oggetto recensione con timestamp
    // - Aggiorna contatori statici
    // - Calcola nuova media voti

    // Implementa qui...
  }

  applicaSconto(percentuale, dataScadenza = null) {
    // Il tuo compito: implementa sistema sconti
    // - Valida percentuale (0-100)
    // - Salva prezzo originale se non già scontato
    // - Applica sconto
    // - Gestisci data scadenza se presente

    // Implementa qui...
  }

  get prezzoFinale() {
    // Il tuo compito: calcola prezzo finale considerando sconti attivi
    // Controlla se lo sconto è ancora valido

    // Implementa qui...
  }

  get mediaVoti() {
    // Il tuo compito: calcola media delle recensioni

    // Implementa qui...
  }

  get disponibilita() {
    // Il tuo compito: restituisci stato disponibilità
    // "Disponibile", "Scorte limitate" (stock < 5), "Non disponibile" (stock = 0)

    // Implementa qui...
  }

  // Metodi astratti da implementare nelle sottoclassi
  calcolaCostoTotale(quantita) {
    throw new Error('Il metodo calcolaCostoTotale deve essere implementato nelle sottoclassi');
  }

  verificaDisponibilita(quantita) {
    throw new Error('Il metodo verificaDisponibilita deve essere implementato nelle sottoclassi');
  }

  // Metodi statici
  static cercaProdotti(criteri) {
    // Il tuo compito: implementa ricerca avanzata
    // Criteri possibili: nome, categoria, prezzoMin, prezzoMax, votoMinimo

    // Implementa qui...
  }

  static ottieniTopProdotti(limite = 10) {
    // Il tuo compito: restituisci i prodotti con voto più alto

    // Implementa qui...
  }
}

class ProdottoFisico extends Prodotto {
  constructor(nome, prezzo, descrizione, categoria, peso, dimensioni) {
    // Il tuo compito:
    // - Chiama super()
    // - Inizializza peso (kg) e dimensioni {lunghezza, larghezza, altezza} (cm)
    // - Valida che peso e dimensioni siano positivi
    // - Inizializza metodiSpedizione disponibili

    // Implementa qui...
  }

  calcolaCostoSpedizione(metodovendi) {
    // Il tuo compito: calcola costo spedizione basato su peso, dimensioni e metodo
    // Metodi: 'standard' (3-5 gg), 'express' (1-2 gg), 'premium' (stesso giorno)
    // Considera anche le dimensioni per calcoli volumetrici

    // Implementa qui...
  }

  calcolaCostoTotale(quantita, metodoSpedizione = 'standard') {
    // Il tuo compito: implementa calcolo costo totale includendo spedizione

    // Implementa qui...
  }

  verificaDisponibilita(quantita) {
    // Il tuo compito: controlla se la quantità richiesta è disponibile

    // Implementa qui...
  }

  get pesoVolumetrico() {
    // Il tuo compito: calcola peso volumetrico (dimensioni / 5000)

    // Implementa qui...
  }

  get pesoBillabile() {
    // Il tuo compito: restituisci il maggiore tra peso reale e peso volumetrico

    // Implementa qui...
  }
}

class ProdottoDigitale extends Prodotto {
  constructor(nome, prezzo, descrizione, categoria, dimensioneFile, formatoFile) {
    // Il tuo compito:
    // - Chiama super()
    // - Inizializza dimensioneFile (MB), formatoFile
    // - Genera linkDownload unico (simulato)
    // - Imposta limitDownload di default a -1 (illimitato)
    // - I prodotti digitali hanno sempre stock infinito

    // Implementa qui...
  }

  generaLinkDownload(utente) {
    // Il tuo compito: genera link download personalizzato per utente
    // Include controlli su limiti download se applicabili

    // Implementa qui...
  }

  calcolaCostoTotale(quantita) {
    // Il tuo compito: per prodotti digitali non c'è costo spedizione

    // Implementa qui...
  }

  verificaDisponibilita(quantita) {
    // Il tuo compito: prodotti digitali sono sempre disponibili

    // Implementa qui...
  }

  get dimensioneFormattata() {
    // Il tuo compito: formatta dimensione file (MB, GB)

    // Implementa qui...
  }
}

class Abbonamento extends Prodotto {
  constructor(nome, prezzoMensile, descrizione, durataMesi, benefici = []) {
    // Il tuo compito:
    // - Chiama super() con prezzo = prezzoMensile * durataMesi
    // - Inizializza proprietà specifiche abbonamento
    // - Imposta rinnovo Automatico default a false

    // Implementa qui...
  }

  calcolaCostoTotale(quantita) {
    // Il tuo compito: calcola costo basato su durata e quantità

    // Implementa qui...
  }

  verificaDisponibilita(quantita) {
    // Il tuo compito: abbonamenti sempre disponibili

    // Implementa qui...
  }

  get prezzoMensileEffettivo() {
    // Il tuo compito: calcola prezzo mensile considerando sconti

    // Implementa qui...
  }

  calcolaRisparmioAnnuale() {
    // Il tuo compito: calcola risparmio dell'abbonamento vs pagamento mensile

    // Implementa qui...
  }
}

class Utente {
  static contatoreTotaleUtenti = 0;
  static registroUtenti = [];

  constructor(nome, cognome, email, tipoUtente = TIPI_UTENTE.BASE) {
    // Il tuo compito: implementa constructor utente
    // - Genera ID unico
    // - Valida email format
    // - Inizializza arrays per indirizzi, metodiPagamento, storicoOrdini
    // - Imposta limiti spesa basati su tipoUtente

    // Implementa qui...
  }

  aggiungiIndirizzo(indirizzo) {
    // Il tuo compito: aggiunge indirizzo validato
    // Formato: { tipo, via, città, cap, provincia, paese, predefinito }

    // Implementa qui...
  }

  aggiungiMetodoPagamento(metodovera) {
    // Il tuo compito: aggiunge metodo pagamento
    // Formato: { tipo, dettagli, predefinito }
    // Tipi: 'carta_credito', 'paypal', 'bonifico', 'contrassegno'

    // Implementa qui...
  }

  calcolaScontoApplicabile(importo) {
    // Il tuo compito: calcola sconto basato su tipo utente e storico acquisti
    // Metodo virtuale - implementazione base restituisce 0

    return 0;
  }

  get spesaTotale() {
    // Il tuo compito: calcola spesa totale da storico ordini

    // Implementa qui...
  }

  get ordiniCompletati() {
    // Il tuo compito: conta ordini con stato 'consegnato'

    // Implementa qui...
  }
}

class UtenteVIP extends Utente {
  constructor(nome, cognome, email, scontoPercentuale = 10) {
    // Il tuo compito: estendi constructor per utenti VIP

    // Implementa qui...
  }

  calcolaScontoApplicabile(importo) {
    // Il tuo compito: override con logica VIP
    // Sconto percentuale + bonus per spese elevate

    // Implementa qui...
  }

  get spedizioneGratuitaAttiva() {
    // Il tuo compito: VIP hanno sempre spedizione gratuita

    return true;
  }
}

class Ordine {
  static contatoreOrdini = 0;
  static storicoOrdini = [];

  constructor(utente, prodotti = []) {
    // Il tuo compito: implementa constructor ordine
    // - Genera numero ordine
    // - Valida utente e prodotti
    // - Inizializza stato a IN_SOSPESO
    // - Calcola totali iniziali

    // Implementa qui...
  }

  aggiungiProdotto(prodotto, quantita = 1, opzioni = {}) {
    // Il tuo compito: aggiunge prodotto all'ordine
    // - Verifica disponibilità
    // - Calcola costi (inclusa spedizione per prodotti fisici)
    // - Aggiorna totali

    // Implementa qui...
  }

  rimuoviProdotto(prodottoId) {
    // Il tuo compito: rimuove prodotto dall'ordine
    // - Solo se ordine non ancora confermato
    // - Ricalcola totali

    // Implementa qui...
  }

  applicaCoupon(codice Coupon) {
    // Il tuo compito: applica coupon di sconto
    // - Valida coupon
    // - Calcola sconto
    // - Aggiorna totali

    // Implementa qui...
  }

  confermaOrdine(metodoPagamento, indirizzoSpedizione) {
    // Il tuo compito: conferma ordine
    // - Cambia stato a CONFERMATO
    // - Processa pagamento (simulato)
    // - Riduce stock prodotti
    // - Genera ricevuta

    // Implementa qui...
  }

  aggiornaStato(nuovoStato, note = '') {
    // Il tuo compito: aggiorna stato ordine
    // - Valida transizione stato
    // - Aggiorna timestamp
    // - Notifica utente (simulato)

    // Implementa qui...
  }

  get subtotale() {
    // Il tuo compito: calcola subtotale prodotti

    // Implementa qui...
  }

  get costoSpedizione() {
    // Il tuo compito: calcola costo spedizione totale

    // Implementa hier...
  }

  get scontiApplicati() {
    // Il tuo compito: calcola sconti totali applicati

    // Implementa hier...
  }

  get totaleFinale() {
    // Il tuo compito: calcola totale finale

    // Implementa heir...
  }

  // Metodi statici
  static ottieniOrdiniPerStato(stato) {
    // Il tuo compito: filtra ordini per stato

    // Implementa hier...
  }

  static calcolaRicaviPeriodo(dataInizio, dataFine) {
    // Il tuo compito: calcola ricavi per periodo

    // Implementa heir...
  }
}

// Sistema principale E-commerce
class SistemaEcommerce {
  constructor(nomeNegozio) {
    this.nome = nomeNegozio;
    this.dataApertura = new Date();
    this.configurazione = {
      valutaBase: 'EUR',
      ivPercentuale: 22,
      spedizioneGratuitaSopra: 50,
      limiteProdottiCarrello: 100
    };
  }

  registraUtente(datiUtente) {
    // Il tuo compito: crea e registra nuovo utente

    // Implementa hier...
  }

  aggiungiProdotto(tipoProdotto, datiProdotto) {
    // Il tuo compito: factory method per creare prodotti
    // Supporta 'fisico', 'digitale', 'abbonamento'

    // Implementa heir...
  }

  creaOrdine(emailUtente) {
    // Il tuo compito: crea nuovo ordine per utente

    // Implementa heir...
  }

  ottieniDashboard() {
    // Il tuo compito: genera dashboard con statistiche complete
    // - Prodotti totali per categoria
    // - Ordini per stato
    // - Ricavi ultimo mese
    // - Top prodotti
    // - Utenti attivi

    // Implementa heir...
  }
}

// Test del sistema
function testSistemaEcommerce() {
  console.log('=== Test Sistema E-commerce Avanzato ===\n');

  const negozio = new SistemaEcommerce('TechStore Pro');

  // Crea prodotti diversi
  const laptop = new ProdottoFisico(
    'MacBook Pro 14"',
    2499.99,
    'Laptop professionale',
    CATEGORIE_PRODOTTI.ELETTRONICA,
    1.6, // peso in kg
    { lunghezza: 31.26, larghezza: 22.12, altezza: 1.55 } // cm
  );

  const ebook = new ProdottoDigitale(
    'Corso JavaScript Avanzato',
    99.99,
    'Corso completo di JavaScript',
    CATEGORIE_PRODOTTI.DIGITALE,
    500, // MB
    'PDF+Video'
  );

  const abbonamentoPremium = new Abbonamento(
    'Premium Membership',
    29.99, // prezzo mensile
    'Accesso illimitato a tutti i contenuti',
    12, // durata mesi
    ['Download illimitati', 'Supporto prioritario', 'Anteprime esclusive']
  );

  // Registra utenti
  const utentePino = negozio.registraUtente({
    nome: 'Mario',
    cognome: 'Rossi',
    email: 'mario@email.com',
    tipo: TIPI_UTENTE.BASE
  });

  const utenteVip = negozio.registraUtente({
    nome: 'Anna',
    cognome: 'Bianchi',
    email: 'anna@email.com',
    tipo: TIPI_UTENTE.VIP
  });

  // Test funzionalità complete...

  console.log('Sistema E-commerce inizializzato con successo!');
}

// testSistemaEcommerce();
```

### Esercizio 3 (Livello Avanzato): Sistema di Gestione Ospedaliera

Questo esercizio finale rappresenta il culmine
