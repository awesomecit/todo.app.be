# Guida Completa alle Classes ES6 e Inheritance

Le classi in JavaScript rappresentano una delle innovazioni pi√π significative introdotte con ES6, non tanto perch√© abbiano cambiato il funzionamento interno del linguaggio, quanto perch√© hanno trasformato il modo in cui gli sviluppatori pensano e strutturano il codice orientato agli oggetti. Prima di immergerci nella sintassi delle classi moderne, √® fondamentale comprendere il percorso evolutivo che ha portato a questa innovazione e, soprattutto, i problemi concreti che le classi ES6 risolvono.

JavaScript √® sempre stato un linguaggio orientato agli oggetti, ma utilizzava un approccio basato sui prototipi che spesso confondeva gli sviluppatori provenienti da linguaggi come Java, C#, o Python. Questo approccio prototipale, pur essendo potente e flessibile, richiedeva una comprensione profonda di concetti come function constructors, prototype chain, e context binding. Le classi ES6 non hanno eliminato questo sistema sottostante, ma hanno fornito una sintassi pi√π familiare e intuitiva che nasconde gran parte della complessit√†, permettendo agli sviluppatori di concentrarsi sulla logica applicativa piuttosto che sui dettagli implementativi.

## L'Evoluzione: Da Function Constructors alle Modern Classes

Per apprezzare pienamente il valore delle classi ES6, iniziamo esaminando come si creava codice orientato agli oggetti in JavaScript prima della loro introduzione. Questo confronto non √® solo accademico, ma ti aiuter√† a comprendere perch√© certe scelte di design sono state fatte e come le classi moderne semplificano drammaticamente la scrittura di codice maintainable.

Considera questo scenario tipico: vogliamo modellare un sistema di gestione di una libreria digitale. Nell'approccio pre-ES6, dovevamo utilizzare function constructors e manipolazione diretta del prototype:

```javascript
// Approccio pre-ES6: Function Constructor pattern
function Libro(titolo, autore, anno, genere) {
  // Propriet√† dell'istanza assegnate tramite 'this'
  this.titolo = titolo;
  this.autore = autore;
  this.anno = anno;
  this.genere = genere;
  this.prestito = null; // Informazioni sul prestito corrente
  this.disponibile = true;
}

// Metodi aggiunti al prototype per condivisione tra istanze
Libro.prototype.prestaSe = function (utente, dataScadenza) {
  if (!this.disponibile) {
    throw new Error('Libro non disponibile per il prestito');
  }

  this.prestito = {
    utente: utente,
    dataInizio: new Date(),
    dataScadenza: dataScadenza,
  };
  this.disponibile = false;

  return `Libro "${this.titolo}" prestato a ${utente}`;
};

Libro.prototype.restituisci = function () {
  if (this.disponibile) {
    throw new Error('Il libro non √® attualmente in prestito');
  }

  const informazioniPrestito = this.prestito;
  this.prestito = null;
  this.disponibile = true;

  return `Libro "${this.titolo}" restituito da ${informazioniPrestito.utente}`;
};

Libro.prototype.ottieniInfo = function () {
  return `"${this.titolo}" di ${this.autore} (${this.anno}) - Genere: ${this.genere}`;
};

// Metodo "statico" simulato attraverso propriet√† della funzione constructor
Libro.creaRaccoltaClassici = function () {
  return [
    new Libro('1984', 'George Orwell', 1949, 'Distopia'),
    new Libro('Il Signore degli Anelli', 'J.R.R. Tolkien', 1954, 'Fantasy'),
    new Libro('Orgoglio e Pregiudizio', 'Jane Austen', 1813, 'Romance'),
  ];
};

// Per creare ereditariet√†, dovevamo manipolare manualmente la prototype chain
function LibroDigitale(
  titolo,
  autore,
  anno,
  genere,
  formatoFile,
  dimensioneFile,
) {
  // Chiamare il constructor padre con call per impostare le propriet√† base
  Libro.call(this, titolo, autore, anno, genere);

  // Propriet√† specifiche del libro digitale
  this.formatoFile = formatoFile;
  this.dimensioneFile = dimensioneFile;
  this.downloadCount = 0;
}

// Impostare la prototype chain manualmente per l'ereditariet√†
LibroDigitale.prototype = Object.create(Libro.prototype);
LibroDigitale.prototype.constructor = LibroDigitale;

// Aggiungere metodi specifici per LibroDigitale
LibroDigitale.prototype.download = function () {
  if (!this.disponibile) {
    throw new Error('File non disponibile per download');
  }

  this.downloadCount++;
  return `Download di "${this.titolo}" completato. Formato: ${this.formatoFile}`;
};

LibroDigitale.prototype.ottieniInfoTecniche = function () {
  return `${this.formatoFile.toUpperCase()} - ${this.dimensioneFile}MB - Downloads: ${this.downloadCount}`;
};
```

Questo codice, pur funzionando perfettamente, presenta diversi problemi evidenti che rendevano lo sviluppo pi√π lento e soggetto a errori. La separazione tra propriet√† (definite nel constructor) e metodi (aggiunti al prototype) creava una disconnessione mentale che rendeva difficile visualizzare la struttura completa della classe. La gestione dell'ereditariet√† richiedeva una conoscenza profonda della prototype chain e la manipolazione manuale di oggetti prototype. Inoltre, non esisteva un modo nativo per creare metodi privati o statici, costringendo gli sviluppatori a utilizzare convenzioni o workaround.

Ora osserviamo come lo stesso sistema pu√≤ essere implementato utilizzando le classi ES6, notando immediatamente la differenza in termini di chiarezza e organizzazione del codice:

```javascript
// Approccio ES6: Class syntax moderna e pulita
class Libro {
  // Constructor centralizza l'inizializzazione dell'istanza
  constructor(titolo, autore, anno, genere) {
    this.titolo = titolo;
    this.autore = autore;
    this.anno = anno;
    this.genere = genere;
    this.prestito = null;
    this.disponibile = true;
  }

  // Metodi dell'istanza definiti direttamente nella classe
  prestaA(utente, dataScadenza) {
    if (!this.disponibile) {
      throw new Error('Libro non disponibile per il prestito');
    }

    this.prestito = {
      utente: utente,
      dataInizio: new Date(),
      dataScadenza: dataScadenza,
    };
    this.disponibile = false;

    return `Libro "${this.titolo}" prestato a ${utente}`;
  }

  restituisci() {
    if (this.disponibile) {
      throw new Error('Il libro non √® attualmente in prestito');
    }

    const informazioniPrestito = this.prestito;
    this.prestito = null;
    this.disponibile = true;

    return `Libro "${this.titolo}" restituito da ${informazioniPrestito.utente}`;
  }

  ottieniInfo() {
    return `"${this.titolo}" di ${this.autore} (${this.anno}) - Genere: ${this.genere}`;
  }

  // Metodi statici definiti con keyword 'static'
  static creaRaccoltaClassici() {
    return [
      new Libro('1984', 'George Orwell', 1949, 'Distopia'),
      new Libro('Il Signore degli Anelli', 'J.R.R. Tolkien', 1954, 'Fantasy'),
      new Libro('Orgoglio e Pregiudizio', 'Jane Austen', 1813, 'Romance'),
    ];
  }
}

// Ereditariet√† semplificata con extends e super
class LibroDigitale extends Libro {
  constructor(titolo, autore, anno, genere, formatoFile, dimensioneFile) {
    // Super() chiama automaticamente il constructor della classe padre
    super(titolo, autore, anno, genere);

    // Propriet√† specifiche della classe figlio
    this.formatoFile = formatoFile;
    this.dimensioneFile = dimensioneFile;
    this.downloadCount = 0;
  }

  download() {
    if (!this.disponibile) {
      throw new Error('File non disponibile per download');
    }

    this.downloadCount++;
    return `Download di "${this.titolo}" completato. Formato: ${this.formatoFile}`;
  }

  ottieniInfoTecniche() {
    return `${this.formatoFile.toUpperCase()} - ${this.dimensioneFile}MB - Downloads: ${this.downloadCount}`;
  }

  // Override di un metodo padre con comportamento esteso
  ottieniInfo() {
    // Chiamiamo il metodo padre con super
    const infoBase = super.ottieniInfo();
    const infoTecniche = this.ottieniInfoTecniche();
    return `${infoBase} | ${infoTecniche}`;
  }
}
```

La differenza √® immediata e drammatica. La sintassi delle classi ES6 crea una struttura visivamente pi√π coerente dove propriet√† e metodi sono chiaramente raggruppati e organizzati. L'ereditariet√† diventa intuitiva con le keyword `extends` e `super`, eliminando la necessit√† di manipolare manualmente la prototype chain. I metodi statici sono chiaramente identificati, e l'override di metodi dalla classe padre risulta semplice e comprensibile.

## Anatomia di una Classe ES6: Comprendere ogni Componente

Ora che hai visto i benefici delle classi moderne, approfondiamo ogni aspetto della loro struttura per costruire una comprensione solida di come utilizzarle efficacemente. Ogni elemento di una classe ES6 ha un ruolo specifico e comprendere questi ruoli ti permetter√† di progettare sistemi orientati agli oggetti eleganti e maintainable.

Una classe √® essenzialmente un template che definisce le caratteristiche comuni che condivideranno tutte le istanze create da quella classe. Pensala come un blueprint architettonico: definisce la struttura, ma ogni casa costruita da quel blueprint sar√† un'istanza unica con i suoi specifici dettagli.

```javascript
// Esempio dettagliato che mostra tutti i componenti di una classe moderna
class GestoreTaskPersonali {
  // Proprieta statiche: condivise tra tutte le istanze della classe
  static PRIORITA_BASSA = 'bassa';
  static PRIORITA_MEDIA = 'media';
  static PRIORITA_ALTA = 'alta';
  static PRIORITA_CRITICA = 'critica';

  // Il constructor √® il metodo speciale chiamato quando si crea una nuova istanza
  constructor(nomeUtente) {
    // Validazione input nel constructor
    if (!nomeUtente || typeof nomeUtente !== 'string') {
      throw new Error('Il nome utente deve essere una stringa non vuota');
    }

    // Propriet√† dell'istanza: ogni istanza ha i suoi valori unici
    this.nomeUtente = nomeUtente;
    this.tasks = [];
    this.taskCompletati = 0;
    this.dataCreazione = new Date();

    console.log(`Gestore task creato per l'utente: ${nomeUtente}`);
  }

  // Metodi dell'istanza: operazioni che ogni istanza pu√≤ eseguire
  aggiungiTask(descrizione, priorita = GestoreTaskPersonali.PRIORITA_MEDIA) {
    // Validazione dei parametri
    if (!descrizione || typeof descrizione !== 'string') {
      throw new Error(
        'La descrizione del task deve essere una stringa non vuota',
      );
    }

    // Validazione della priorit√† usando le costanti statiche
    const prioritaValide = [
      GestoreTaskPersonali.PRIORITA_BASSA,
      GestoreTaskPersonali.PRIORITA_MEDIA,
      GestoreTaskPersonali.PRIORITA_ALTA,
      GestoreTaskPersonali.PRIORITA_CRITICA,
    ];

    if (!prioritaValide.includes(priorita)) {
      throw new Error(
        `Priorit√† non valida. Usa una delle costanti: ${prioritaValide.join(', ')}`,
      );
    }

    // Creazione del task con ID univoco
    const nuovoTask = {
      id: this._generaIdUnico(),
      descrizione: descrizione,
      priorita: priorita,
      completato: false,
      dataCreazione: new Date(),
      dataCompletamento: null,
    };

    this.tasks.push(nuovoTask);

    console.log(`Task aggiunto: "${descrizione}" con priorit√† ${priorita}`);
    return nuovoTask.id;
  }

  completaTask(taskId) {
    const task = this.tasks.find(t => t.id === taskId);

    if (!task) {
      throw new Error(`Task con ID ${taskId} non trovato`);
    }

    if (task.completato) {
      console.log(`Task "${task.descrizione}" √® gi√† completato`);
      return false;
    }

    task.completato = true;
    task.dataCompletamento = new Date();
    this.taskCompletati++;

    console.log(`Task completato: "${task.descrizione}"`);
    return true;
  }

  ottieniTaskPerPriorita(priorita) {
    return this.tasks.filter(
      task => task.priorita === priorita && !task.completato,
    );
  }

  ottieniStatistiche() {
    const totaliTask = this.tasks.length;
    const taskAttivi = this.tasks.filter(t => !t.completato).length;
    const percentualeCompletamento =
      totaliTask > 0
        ? ((this.taskCompletati / totaliTask) * 100).toFixed(1)
        : 0;

    return {
      utente: this.nomeUtente,
      totaliTask: totaliTask,
      taskCompletati: this.taskCompletati,
      taskAttivi: taskAttivi,
      percentualeCompletamento: `${percentualeCompletamento}%`,
      dataCreazione: this.dataCreazione,
    };
  }

  // Metodo privato (convenzione con underscore - non veramente privato in ES6 standard)
  _generaIdUnico() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
  }

  // Metodo statico: appartiene alla classe, non alle singole istanze
  static confrontaPerformance(gestore1, gestore2) {
    const stats1 = gestore1.ottieniStatistiche();
    const stats2 = gestore2.ottieniStatistiche();

    const perf1 = parseFloat(stats1.percentualeCompletamento);
    const perf2 = parseFloat(stats2.percentualeCompletamento);

    if (perf1 > perf2) {
      return `${stats1.utente} ha performance migliore (${stats1.percentualeCompletamento} vs ${stats2.percentualeCompletamento})`;
    } else if (perf2 > perf1) {
      return `${stats2.utente} ha performance migliore (${stats2.percentualeCompletamento} vs ${stats1.percentualeCompletamento})`;
    } else {
      return `${stats1.utente} e ${stats2.utente} hanno performance equivalenti (${stats1.percentualeCompletamento})`;
    }
  }

  static creaGestoreDemo() {
    const gestore = new GestoreTaskPersonali('Demo User');

    // Aggiungiamo alcuni task di esempio
    gestore.aggiungiTask(
      'Completare progetto JavaScript',
      GestoreTaskPersonali.PRIORITA_ALTA,
    );
    gestore.aggiungiTask(
      'Leggere documentazione ES6',
      GestoreTaskPersonali.PRIORITA_MEDIA,
    );
    gestore.aggiungiTask(
      'Organizzare scrivania',
      GestoreTaskPersonali.PRIORITA_BASSA,
    );

    console.log('Gestore demo creato con task di esempio');
    return gestore;
  }
}

// Esempio di utilizzo che dimostra tutti i componenti
console.log('=== Test Completo della Classe GestoreTaskPersonali ===');

// Creazione di istanze
const gestoreMario = new GestoreTaskPersonali('Mario');
const gestoreAnna = new GestoreTaskPersonali('Anna');

// Utilizzo delle costanti statiche
gestoreMario.aggiungiTask(
  'Preparare presentazione',
  GestoreTaskPersonali.PRIORITA_ALTA,
);
gestoreMario.aggiungiTask(
  'Rispondere alle email',
  GestoreTaskPersonali.PRIORITA_MEDIA,
);

gestoreAnna.aggiungiTask(
  'Review del codice',
  GestoreTaskPersonali.PRIORITA_CRITICA,
);
gestoreAnna.aggiungiTask(
  'Meeting con il team',
  GestoreTaskPersonali.PRIORITA_ALTA,
);

// Completamento di alcuni task
const taskIds = [];
taskIds.push(
  gestoreMario.aggiungiTask(
    'Testing nuove feature',
    GestoreTaskPersonali.PRIORITA_MEDIA,
  ),
);
gestoreMario.completaTask(taskIds[0]);

// Utilizzo di metodi statici
console.log('\n=== Confronto Performance ===');
console.log(
  GestoreTaskPersonali.confrontaPerformance(gestoreMario, gestoreAnna),
);

console.log('\n=== Statistiche Finali ===');
console.log('Mario:', gestoreMario.ottieniStatistiche());
console.log('Anna:', gestoreAnna.ottieniStatistiche());

// Creazione gestore demo usando metodo statico
const gestoreDemo = GestoreTaskPersonali.creaGestoreDemo();
console.log('\nDemo:', gestoreDemo.ottieniStatistiche());
```

Questo esempio completo illustra come ogni componente di una classe ES6 abbia un ruolo specifico nell'architettura del nostro sistema. Le propriet√† statiche fungono da costanti condivise che garantiscono coerenza in tutta l'applicazione. Il constructor gestisce l'inizializzazione e la validazione dei dati, assicurando che ogni istanza parta da uno stato valido. I metodi dell'istanza implementano la logica specifica di ogni oggetto, mentre i metodi statici forniscono utility che operano sulla classe nel suo complesso.

## Ereditariet√† e la Keyword Extends: Costruire Gerarchie Robuste

L'ereditariet√† √® uno dei pilastri fondamentali della programmazione orientata agli oggetti, e le classi ES6 rendono questo concetto incredibilmente pi√π accessibile e potente. Quando parliamo di ereditariet√†, stiamo essenzialmente creando una relazione "√® un tipo di" tra classi, dove una classe figlio eredita tutte le caratteristiche della classe padre, ma pu√≤ anche aggiungere le proprie specifiche funzionalit√† o modificare comportamenti esistenti.

Per comprendere profondamente come funziona l'ereditariet√† nelle classi ES6, costruiamo insieme un sistema di gestione di diversi tipi di veicoli, partendo da una classe base e specializzandola gradualmente:

```javascript
// Classe base: definisce le caratteristiche comuni a tutti i veicoli
class Veicolo {
  constructor(marca, modello, anno, colore) {
    // Validazione dei parametri essenziali
    if (!marca || !modello || !anno) {
      throw new Error('Marca, modello e anno sono obbligatori');
    }

    this.marca = marca;
    this.modello = modello;
    this.anno = anno;
    this.colore = colore || 'non specificato';
    this.chilometraggio = 0;
    this.acceso = false;
    this.velocitaCorrente = 0;
    this.storicoMantenimento = [];
  }

  // Metodi comuni che ogni veicolo dovrebbe avere
  accendi() {
    if (this.acceso) {
      return `${this.marca} ${this.modello} √® gi√† acceso`;
    }

    this.acceso = true;
    return `${this.marca} ${this.modello} acceso con successo`;
  }

  spegni() {
    if (!this.acceso) {
      return `${this.marca} ${this.modello} √® gi√† spento`;
    }

    if (this.velocitaCorrente > 0) {
      return 'Non puoi spegnere il veicolo mentre √® in movimento';
    }

    this.acceso = false;
    return `${this.marca} ${this.modello} spento`;
  }

  accelera(incremento = 10) {
    if (!this.acceso) {
      return 'Devi prima accendere il veicolo';
    }

    this.velocitaCorrente += incremento;
    return `Velocit√† aumentata a ${this.velocitaCorrente} km/h`;
  }

  frena(decremento = 10) {
    this.velocitaCorrente = Math.max(0, this.velocitaCorrente - decremento);
    return `Velocit√† ridotta a ${this.velocitaCorrente} km/h`;
  }

  aggiungiMantenimento(descrizione, costo, data = new Date()) {
    const intervento = {
      id: Date.now(),
      descrizione,
      costo,
      data,
      chilometraggioAttuale: this.chilometraggio,
    };

    this.storicomantenimento.push(intervento);
    return `Intervento registrato: ${descrizione} - ‚Ç¨${costo}`;
  }

  ottieniInfo() {
    return `${this.marca} ${this.modello} (${this.anno}) - Colore: ${this.colore} - Km: ${this.chilometraggio}`;
  }

  // Metodo che pu√≤ essere sovrascritto dalle classi figlio
  calcolaConsumoCarburante(distanza) {
    // Calcolo generico: consumo base di 8 litri per 100km
    return (distanza / 100) * 8;
  }

  // Metodo statico per confrontare veicoli
  static confrontaAnni(veicolo1, veicolo2) {
    return veicolo1.anno - veicolo2.anno;
  }
}

// Prima specializzazione: Auto che estende Veicolo
class Auto extends Veicolo {
  constructor(
    marca,
    modello,
    anno,
    colore,
    numeroPorte,
    tipoCarburante,
    cilindrata,
  ) {
    // Super() deve essere la prima chiamata nel constructor della classe figlio
    super(marca, modello, anno, colore);

    // Propriet√† specifiche delle auto
    this.numeroPorte = numeroPorte || 4;
    this.tipoCarburante = tipoCarburante || 'benzina';
    this.cilindrata = cilindrata;
    this.bagagliOccupato = 0;
    this.capacitaBagagli = 400; // litri
    this.assicurazione = null;
  }

  // Metodi specifici per le auto
  caricaBagagli(volume) {
    if (this.bagagliOccupato + volume > this.capacitaBagagli) {
      return `Spazio insufficiente. Disponibili ${this.capacitaBagagli - this.bagagliOccupato} litri`;
    }

    this.bagagliOccupato += volume;
    return `Caricati ${volume} litri. Spazio residuo: ${this.capacitaBagagli - this.bagagliOccupato} litri`;
  }

  scaricaBagagli(volume = this.bagagliOccupato) {
    const volumeEffettivo = Math.min(volume, this.bagagliOccupato);
    this.bagagliOccupato -= volumeEffettivo;
    return `Scaricati ${volumeEffettivo} litri. Spazio occupato: ${this.bagagliOccupato} litri`;
  }

  // Override del metodo padre con calcolo pi√π specifico per le auto
  calcolaConsumoCarburante(distanza) {
    let consumoBase;

    switch (this.tipoCarburante) {
      case 'diesel':
        consumoBase = 6; // litri per 100km
        break;
      case 'ibrido':
        consumoBase = 4;
        break;
      case 'elettrico':
        return `${(distanza / 100) * 15} kWh`; // Per auto elettriche usiamo kWh
      default:
        consumoBase = 7;
    }

    // Aggiustiamo il consumo in base alla cilindrata
    if (this.cilindrata) {
      const fattoreCilindrata = this.cilindrata / 1600; // 1600cc come riferimento
      consumoBase *= fattoreCilindrata;
    }

    return `${(distanza / 100) * consumoBase} litri di ${this.tipoCarburante}`;
  }

  // Estende il metodo info del padre aggiungendo informazioni specifiche
  ottieniInfo() {
    const infoBase = super.ottieniInfo(); // Chiamiamo il metodo del padre
    return `${infoBase} - ${this.numeroPorte} porte - ${this.tipoCarburante} - ${this.cilindrata || 'N/A'}cc`;
  }

  // Metodo statico specifico per le auto
  static calcolaEtaVeicolo(auto, dataCorrente = new Date()) {
    return dataCorrente.getFullYear() - auto.anno;
  }
}

// Seconda specializzazione: Motocicletta che estende Veicolo
class Motocicletta extends Veicolo {
  constructor(marca, modello, anno, colore, cilindrata, tipoMotore) {
    super(marca, modello, anno, colore);

    // Propriet√† specifiche delle motociclette
    this.cilindrata = cilindrata;
    this.tipoMotore = tipoMotore || 'quattro tempi';
    this.cascoObbligatorio = true;
    this.passeggeroABordo = false;
  }

  // Metodi specifici per le motociclette
  salitaPasseggero() {
    if (this.passeggeroABordo) {
      return "C'√® gi√† un passeggero a bordo";
    }

    this.passeggeroABordo = true;
    return 'Passeggero salito a bordo';
  }

  discesaPasseggero() {
    if (!this.passeggeroABordo) {
      return "Non c'√® nessun passeggero a bordo";
    }

    this.passeggeroABordo = false;
    return 'Passeggero sceso';
  }

  // Override specifico per motociclette
  calcolaConsumoCarburante(distanza) {
    // Le moto consumano generalmente meno delle auto
    const consumoBase = 4; // litri per 100km
    const fattoreCilindrata = this.cilindrata / 600; // 600cc come riferimento
    const consumoEffettivo = consumoBase * fattoreCilindrata;

    return `${(distanza / 100) * consumoEffettivo} litri`;
  }

  // Override del metodo info con informazioni specifiche
  ottieniInfo() {
    const infoBase = super.ottieniInfo();
    const passeggero = this.passeggeroABordo ? 'con passeggero' : 'solo pilota';
    return `${infoBase} - ${this.cilindrata}cc - ${this.tipoMotore} - ${passeggero}`;
  }
}

// Terza specializzazione: ulteriore ereditariet√† con AutoSportiva che estende Auto
class AutoSportiva extends Auto {
  constructor(
    marca,
    modello,
    anno,
    colore,
    cilindrata,
    potenzaCV,
    tempoAccelerazione,
  ) {
    // Chiamiamo il constructor della classe padre (Auto)
    super(marca, modello, anno, colore, 2, 'benzina', cilindrata);

    // Propriet√† specifiche delle auto sportive
    this.potenzaCV = potenzaCV;
    this.tempoAccelerazione = tempoAccelerazione; // 0-100 km/h in secondi
    this.modalitaSport = false;
    this.velocitaMassima = this._calcolaVelocitaMassima();
  }

  // Metodi specifici delle auto sportive
  attivaMalitaSport() {
    if (this.modalitaSport) {
      return 'Modalit√† sport gi√† attiva';
    }

    this.modalitaSport = true;
    return 'Modalit√† sport attivata - Performance massime';
  }

  disattivaMlitaSport() {
    this.modalitaSport = false;
    return 'Modalit√† sport disattivata - Guida normale';
  }

  // Override del metodo accelera con comportamento specifico per auto sportive
  accelera(incremento = 15) {
    if (!this.acceso) {
      return 'Devi prima accendere il veicolo';
    }

    // In modalit√† sport l'accelerazione √® pi√π rapida
    const incrementoEffettivo = this.modalitaSport
      ? incremento * 1.5
      : incremento;

    if (this.velocitaCorrente + incrementoEffettivo > this.velocitaMassima) {
      this.velocitaCorrente = this.velocitaMassima;
      return `Velocit√† massima raggiunta: ${this.velocitaMassima} km/h`;
    }

    this.velocitaCorrente += incrementoEffettivo;
    const modalita = this.modalitaSport ? ' (modalit√† sport)' : '';
    return `Accelerazione sportiva: ${this.velocitaCorrente} km/h${modalita}`;
  }

  // Metodo privato per calcolare la velocit√† massima teorica
  _calcolaVelocitaMassima() {
    // Formula semplificata basata su potenza e peso stimato
    const pesoStimato = 1200; // kg
    const fattorePotenza = this.potenzaCV / pesoStimato;
    return Math.round(200 + fattorePotenza * 50); // velocit√† teorica
  }

  // Override con informazioni specifiche dell'auto sportiva
  ottieniInfo() {
    const infoAuto = super.ottieniInfo(); // Chiamiamo il metodo di Auto (che a sua volta chiama quello di Veicolo)
    const modalita = this.modalitaSport ? 'SPORT' : 'Normal';
    return `${infoAuto} - ${this.potenzaCV}CV - 0-100: ${this.tempoAccelerazione}s - Modalit√†: ${modalita}`;
  }
}

// Dimostriamo l'utilizzo dell'ereditariet√† con esempi pratici
console.log('=== Test Sistema Ereditariet√† Veicoli ===\n');

// Creiamo istanze di ogni tipo di veicolo
const veicoloGenerico = new Veicolo('Generica', 'Modello Base', 2020, 'bianco');
const miaAuto = new Auto('Toyota', 'Corolla', 2019, 'rosso', 4, 'ibrido', 1800);
const miaMoto = new Motocicletta(
  'Yamaha',
  'MT-07',
  2021,
  'nero',
  689,
  'quattro tempi',
);
const autoSportiva = new AutoSportiva(
  'Ferrari',
  '488 GTB',
  2022,
  'rosso',
  3902,
  670,
  3.0,
);

console.log('=== Informazioni Veicoli ===');
console.log(veicoloGenerico.ottieniInfo());
console.log(miaAuto.ottieniInfo());
console.log(miaMoto.ottieniInfo());
console.log(autoSportiva.ottieniInfo());

console.log('\n=== Test Funzionalit√† Specifiche ===');
// Test funzionalit√† auto
console.log(miaAuto.caricaBagagli(200));
console.log('Consumo per 150km:', miaAuto.calcolaConsumoCarburante(150));

// Test funzionalit√† motocicletta
console.log(miaMoto.salitaPasseggero());
console.log('Consumo moto per 150km:', miaMoto.calcolaConsumoCarburante(150));

// Test funzionalit√† auto sportiva
console.log(autoSportiva.attivaMalitaSport());
console.log(autoSportiva.accelera(30));

console.log('\n=== Test Metodi Ereditati ===');
// Tutti i veicoli hanno i metodi base
console.log(miaAuto.accendi());
console.log(miaMoto.accendi());
console.log(autoSportiva.spegni()); // Dovrebbe fallire perch√© ha velocit√† > 0

console.log('\n=== Test Polimorfismo ===');
// Array di veicoli diversi che rispondono tutti al metodo ottieniInfo()
const flotta = [veicoloGenerico, miaAuto, miaMoto, autoSportiva];
flotta.forEach((veicolo, indice) => {
  console.log(`Veicolo ${indice + 1}: ${veicolo.ottieniInfo()}`);
});
```

Questo esempio complesso dimostra la potenza dell'ereditariet√† nelle classi ES6. Ogni classe figlio mantiene tutte le funzionalit√† del padre ma pu√≤ aggiungerne di nuove o modificare quelle esistenti. Il polimorfismo permette di trattare oggetti di classi diverse attraverso un'interfaccia comune, mentre l'override dei metodi consente comportamenti specializzati per ogni tipo di veicolo.

## La Keyword Super: Comunicare con la Classe Padre

La keyword `super` rappresenta uno degli aspetti pi√π eleganti e potenti dell'ereditariet√† nelle classi ES6. Essa fornisce un ponte di comunicazione diretto tra una classe figlio e la sua classe padre, permettendo di accedere a propriet√†, metodi e constructor della classe genitore in modo pulito e intuitivo.

Comprendere `super` significa comprendere come le classi figlio possano estendere e personalizzare il comportamento delle classi padre senza duplicare codice o rompere l'incapsulamento. Esploriamo questo concetto attraverso un sistema di gestione di prodotti e-commerce che mostrer√† tutte le sfaccettature di `super`:

```javascript
// Classe base per tutti i prodotti
class Prodotto {
  constructor(nome, prezzo, categoria, descrizione) {
    this.nome = nome;
    this.prezzo = prezzo;
    this.categoria = categoria;
    this.descrizione = descrizione;
    this.dataCreazione = new Date();
    this.recensioni = [];
    this.disponibile = true;
    this.codiceBarrediritto = this._generaCodice();
  }

  aggiungiRecensione(voto, commento, autore) {
    if (voto < 1 || voto > 5) {
      throw new Error('Il voto deve essere compreso tra 1 e 5');
    }

    const recensione = {
      id: Date.now(),
      voto: voto,
      commento: commento,
      autore: autore,
      data: new Date(),
      verificata: false,
    };

    this.recensioni.push(recensione);
    console.log(`Recensione aggiunta al prodotto "${this.nome}" da ${autore}`);
    return recensione.id;
  }

  calcolaMediaVoti() {
    if (this.recensioni.length === 0) return 0;

    const sommaVoti = this.recensioni.reduce(
      (somma, recensione) => somma + recensione.voto,
      0,
    );
    return (sommaVoti / this.recensioni.length).toFixed(1);
  }

  applicaSconto(percentuale, motivazione = 'Offerta speciale') {
    if (percentuale < 0 || percentuale > 100) {
      throw new Error('La percentuale di sconto deve essere tra 0 e 100');
    }

    const vecchioPrezzo = this.prezzo;
    this.prezzo = this.prezzo * (1 - percentuale / 100);

    console.log(`Sconto del ${percentuale}% applicato a "${this.nome}"`);
    console.log(
      `Prezzo: ‚Ç¨${vecchioPrezzo.toFixed(2)} ‚Üí ‚Ç¨${this.prezzo.toFixed(2)}`,
    );
    console.log(`Motivazione: ${motivazione}`);

    return {
      prezzoOriginale: vecchioPrezzo,
      prezzoScontato: this.prezzo,
      risparmiato: vecchioPrezzo - this.prezzo,
    };
  }

  ottieniDettagli() {
    return {
      nome: this.nome,
      prezzo: this.prezzo,
      categoria: this.categoria,
      descrizione: this.descrizione,
      mediaVoti: this.calcolaMediaVoti(),
      numeroRecensioni: this.recensioni.length,
      disponibile: this.disponibile,
      codiceBarre: this.codiceBarre,
    };
  }

  _generaCodice() {
    return 'PROD-' + Math.random().toString(36).substring(2, 15).toUpperCase();
  }
}

// Classe specializzata per prodotti elettronici
class ProdottoElettronico extends Prodotto {
  constructor(
    nome,
    prezzo,
    descrizione,
    marca,
    modello,
    garanziaMesi,
    specificheTecniche,
  ) {
    // super() deve essere chiamato PRIMA di utilizzare 'this'
    super(nome, prezzo, 'Elettronica', descrizione);

    // Propriet√† specifiche per elettronica
    this.marca = marca;
    this.modello = modello;
    this.garanziaMesi = garanziaMesi || 24;
    this.specificheTecniche = specificheTecniche || {};
    this.dataScadenzaGaranzia = this._calcolaScadenzaGaranzia();
    this.registratoInGaranzia = false;
  }

  registraGaranzia(nomeCliente, emailCliente) {
    if (this.registratoInGaranzia) {
      return 'Prodotto gi√† registrato in garanzia';
    }

    this.registratoInGaranzia = true;
    this.informazioniGaranzia = {
      cliente: nomeCliente,
      email: emailCliente,
      dataRegistrazione: new Date(),
    };

    console.log(
      `Garanzia registrata per "${this.nome}" a nome di ${nomeCliente}`,
    );
    return 'Registrazione garanzia completata';
  }

  // Estende il metodo padre applicando sconti specifici per l'elettronica
  applicaSconto(percentuale, motivazione = 'Offerta tecnologia') {
    // Chiamiamo il metodo della classe padre per la logica base
    const risultatoSconto = super.applicaSconto(percentuale, motivazione);

    // Aggiungiamo comportamento specifico per prodotti elettronici
    if (percentuale >= 20) {
      console.log(
        'üéÅ BONUS: Sconto importante! Garanzia estesa automaticamente di 6 mesi',
      );
      this.garanziaMesi += 6;
      this.dataScadenzaGaranzia = this._calcolaScadenzaGaranzia();
    }

    // Se il prodotto √® molto scontato, potrebbe essere un modello in uscita
    if (percentuale >= 50) {
      console.log(
        '‚ÑπÔ∏è  Attenzione: Questo potrebbe essere un modello in dismissione',
      );
      this.descrizione += ' - MODELLO IN USCITA';
    }

    return {
      ...risultatoSconto,
      garanzia: `${this.garanziaMesi} mesi`,
      scadenzaGaranzia: this.dataScadenzaGaranzia,
    };
  }

  // Override del metodo padre con informazioni aggiuntive
  ottieniDettagli() {
    // Otteniamo prima i dettagli base dal padre
    const dettagliBase = super.ottieniDettagli();

    // Aggiungiamo informazioni specifiche per l'elettronica
    return {
      ...dettagliBase,
      marca: this.marca,
      modello: this.modello,
      garanziaMesi: this.garanziaMesi,
      garanziScadenza: this.dataScadenzaGaranzia,
      registratoInGaranzia: this.registratoInGaranzia,
      specificheTecniche: this.specificheTecniche,
    };
  }

  _calcolaScadenzaGaranzia() {
    const scadenza = new Date(this.dataCreazione);
    scadenza.setMonth(scadenza.getMonth() + this.garanziaMesi);
    return scadenza;
  }
}

// Ulteriore specializzazione: Smartphone che estende ProdottoElettronico
class Smartphone extends ProdottoElettronico {
  constructor(
    nome,
    prezzo,
    descrizione,
    marca,
    modello,
    sistemaOperativo,
    memoriaGB,
    fotocamerMP,
  ) {
    // Chiamiamo il constructor della classe padre con specifiche tecniche predefinite
    const specifiche = {
      sistema_operativo: sistemaOperativo,
      memoria_storage: `${memoriaGB}GB`,
      fotocamera_principale: `${fotocamerMP}MP`,
      tipo_dispositivo: 'Smartphone',
    };

    super(nome, prezzo, descrizione, marca, modello, 24, specifiche);

    // Propriet√† specifiche dello smartphone
    this.sistemaOperativo = sistemaOperativo;
    this.memoriaGB = memoriaGB;
    this.fotocamerMP = fotocamerMP;
    this.appInstallate = [];
    this.batteria = 100; // Percentuale carica
  }

  installaApp(nomeApp, dimensioneMB) {
    const memoriaOccupata = this.appInstallate.reduce(
      (totale, app) => totale + app.dimensione,
      0,
    );
    const memoriaDisponibile = this.memoriaGB * 1024 - memoriaOccupata; // Conversione in MB

    if (dimensioneMB > memoriaDisponibile) {
      return `Memoria insufficiente. Disponibili ${memoriaDisponibile}MB, richiesti ${dimensioneMB}MB`;
    }

    const app = {
      nome: nomeApp,
      dimensione: dimensioneMB,
      dataInstallazione: new Date(),
    };

    this.appInstallate.push(app);
    console.log(`App "${nomeApp}" installata (${dimensioneMB}MB)`);
    return `Installazione completata. Memoria residua: ${memoriaDisponibile - dimensioneMB}MB`;
  }

  // Estende il metodo di applicazione sconto con logiche specifiche per smartphone
  applicaSconto(percentuale, motivazione = 'Offerta smartphone') {
    // Prima chiamiamo il metodo della classe padre (ProdottoElettronico)
    const risultatoSconto = super.applicaSconto(percentuale, motivazione);

    // Logica specifica per smartphone
    if (percentuale >= 30) {
      console.log('üì± BONUS SMARTPHONE: Protezione schermo gratuita inclusa!');
      this.accessoriInclusi = this.accessoriInclusi || [];
      this.accessoriInclusi.push('Protezione schermo premium');
    }

    if (percentuale >= 40 && this.memoriaGB <= 64) {
      console.log('üíæ BONUS MEMORIA: Cloud storage gratuito per 1 anno!');
      this.serviziInclusi = this.serviziInclusi || [];
      this.serviziInclusi.push('Cloud storage 100GB - 1 anno');
    }

    return {
      ...risultatoSconto,
      accessoriInclusi: this.accessoriInclusi || [],
      serviziInclusi: this.serviziInclusi || [],
    };
  }

  // Override che combina informazioni da tutte le classi della gerarchia
  ottieniDettagli() {
    // Chiamiamo il metodo del padre che a sua volta chiama il nonno
    const dettagliElettronico = super.ottieniDettagli();

    // Calcoliamo informazioni specifiche dello smartphone
    const memoriaOccupata = this.appInstallate.reduce(
      (totale, app) => totale + app.dimensione,
      0,
    );
    const memoriaLibera = this.memoriaGB * 1024 - memoriaOccupata;

    return {
      ...dettagliElettronico,
      sistemaOperativo: this.sistemaOperativo,
      memoria: {
        totale: `${this.memoriaGB}GB`,
        occupata: `${(memoriaOccupata / 1024).toFixed(2)}GB`,
        libera: `${(memoriaLibera / 1024).toFixed(2)}GB`,
      },
      fotocamera: `${this.fotocamerMP}MP`,
      appInstallate: this.appInstallate.length,
      batteria: `${this.batteria}%`,
      accessoriInclusi: this.accessoriInclusi || [],
      serviziInclusi: this.serviziInclusi || [],
    };
  }
}

// Esempio completo che dimostra l'uso di super in tutti i contesti
console.log('=== Test Sistema Prodotti con Super ===\n');

// Creiamo prodotti di diversi tipi
const libro = new Prodotto(
  'Il Signore degli Anelli',
  15.99,
  'Libri',
  'Fantasy epic',
);
const laptop = new ProdottoElettronico(
  'MacBook Pro 14"',
  2499.99,
  'Laptop professionale per creativi',
  'Apple',
  'MacBook Pro 2023',
  36,
  { processore: 'M2 Pro', ram: '16GB', ssd: '512GB' },
);

const iPhone = new Smartphone(
  'iPhone 15 Pro',
  1199.99,
  'Smartphone premium con fotocamera avanzata',
  'Apple',
  'iPhone 15 Pro',
  'iOS 17',
  256,
  48,
);

console.log('=== Test Metodi Base (da Prodotto) ===');
libro.aggiungiRecensione(5, 'Capolavoro assoluto!', 'Mario');
laptop.aggiungiRecensione(4, 'Ottimo per il lavoro', 'Anna');
iPhone.aggiungiRecensione(5, 'Camera incredibile', 'Luca');

console.log('\n=== Test Metodi Specializzati ===');
laptop.registraGaranzia('Anna Bianchi', 'anna@email.com');
iPhone.installaApp('Instagram', 250);
iPhone.installaApp('Photoshop Mobile', 500);

console.log('\n=== Test Super in applicaSconto ===');
console.log('--- Sconto Libro (solo metodo base) ---');
libro.applicaSconto(20, 'Saldi estivi');

console.log('\n--- Sconto Laptop (base + elettronico) ---');
laptop.applicaSconto(25, 'Black Friday');

console.log('\n--- Sconto Smartphone (base + elettronico + smartphone) ---');
iPhone.applicaSconto(35, 'Lancio nuovo modello');

console.log('\n=== Test Super in ottieniDettagli ===');
console.log('--- Dettagli Libro ---');
console.log(JSON.stringify(libro.ottieniDettagli(), null, 2));

console.log('\n--- Dettagli Laptop ---');
console.log(JSON.stringify(laptop.ottieniDettagli(), null, 2));

console.log('\n--- Dettagli Smartphone ---');
console.log(JSON.stringify(iPhone.ottieniDettagli(), null, 2));

console.log('\n=== Dimostrazione Polimorfismo con Super ===');
const catalogo = [libro, laptop, iPhone];

console.log('Applicazione sconto del 15% a tutto il catalogo:');
catalogo.forEach(prodotto => {
  console.log(`\n--- ${prodotto.nome} ---`);
  prodotto.applicaSconto(15, 'Sconto fedelt√† cliente');
});
```

Questo esempio approfondito mostra come `super` funzioni a diversi livelli della gerarchia di ereditariet√†. Ogni classe pu√≤ chiamare metodi della propria classe padre, che a loro volta possono chiamare metodi della classe nonno, creando una catena di comportamenti che si combinano armoniosamente. L'importante √® comprendere che `super` si riferisce sempre alla classe immediatamente superiore nella gerarchia, non necessariamente alla classe radice.

## Metodi e Propriet√† Statiche: Funzionalit√† a Livello di Classe

I metodi e le propriet√† statiche rappresentano uno strumento potente per organizzare funzionalit√† che appartengono alla classe nel suo complesso piuttosto che alle singole istanze. Quando dichiari un metodo o una propriet√† come `static`, stai essenzialmente creando qualcosa che esiste a livello della classe e pu√≤ essere accessibile senza creare un'istanza di quella classe.

Questo concetto √® fondamentale per implementare pattern come Factory Methods, Utility Functions, costanti condivise, e contatori globali. Esploriamo questi concetti attraverso un sistema di gestione di una libreria che mostrer√† tutti gli aspetti pratici dei membri statici:

```javascript
class BibliotecaDigitale {
  // Propriet√† statiche: condivise tra tutte le istanze e accessibili dalla classe
  static contatoreTotaleLibri = 0;
  static bibliotecheCreate = 0;
  static GENERI_SUPPORTATI = [
    'Fiction', 'Saggistica', 'Scienze', 'Storia',
    'Biografie', 'Tecnologia', 'Arte', 'Cucina'
  ];
  static LIMITE_PRESTITI_DEFAULT = 5;
  static DURATA_PRESTITO_GIORNI = 14;

  // Registry statico per tenere traccia di tutte le biblioteche create
  static registryBiblioteche = new Map();

  constructor(nome, indirizzo, capacitaMassima = 10000) {
    this.id = BibliotecaDigitale._generaIdBiblioteca();
    this.nome = nome;
    this.indirizzo = indirizzo;
    this.capacitaMassima = capacitaMassima;
    this.libri = [];
    this.utentiRegistrati = [];
    this.prestitiAttivi = [];
    this.dataCreazione = new Date();

    // Aggiorniamo i contatori statici
    BibliotecaDigitale.bibliotecheCreate++;

    // Registriamo questa biblioteca nel registry statico
    BibliotecaDigitale.registryBiblioteche.set(this.id, this);

    console.log(`Biblioteca "${nome}" creata con ID: ${this.id}`);
  }

  aggiungiLibro(titolo, autore, genere, isbn) {
    // Validazione usando propriet√† statiche
    if (!BibliotecaDigitale.GENERI_SUPPORTATI.includes(genere)) {
      throw new Error(`Genere non supportato. Generi validi: ${BibliotecaDigitale.GENERI_SUPPORTATI.join(', ')}`);
    }

    if (this.libri.length >= this.capacitaMassima) {
      throw new Error('Capacit√† massima della biblioteca raggiunta');
    }

    const libro = {
      id: BibliotecaDigitale._generaIdLibro(),
      titolo,
      autore,
      genere,
      isbn,
      bibliotecaId: this.id,
      disponibile: true,
      dataAggiunta: new Date(),
      numeroPrestitiTotali: 0
    };

    this.libri.push(libro);
    BibliotecaDigitale.contatoreTotaleLibri++;

    console.log(`Libro "${titolo}" aggiunto alla biblioteca ${this.nome}`);
    return libro.id;
  }

  registraUtente(nome, email, tipoAbbonamento = 'base') {
    const utente = {
      id: BibliotecaDigitale._generaIdUtente(),
      nome,
      email,
      tipoAbbonamento,
      dataRegistrazione: new Date(),
      bibliotecaId: this.id,
      limitePrestiti: BibliotecaDigitale._calcolaLimitePrestiti(tipoAbbonamento),
      prestitiAttivi: 0
    };

    this.utentiRegistrati.push(utente);
    console.log(`Utente ${nome} registrato con abbonamento ${tipoAbbonamento}`);
    return utente.id;
  }

  // Metodi statici per operazioni a livello di classe
  static trovaLibroInTutteLeBiblioteche(criterioRicerca, valoreCerca) {
    const risultati = [];

    // Iteriamo attraverso tutte le biblioteche registrate
    for (const biblioteca of BibliotecaDigitale.registryBiblioteche.values()) {
      const libriTrovati = biblioteca.libri.filter(libro => {
        switch(criterioRicerca.toLowerCase()) {
          case 'titolo':
            return libro.titolo.toLowerCase().includes(valoreCerca.toLowerCase());
          case 'autore':
            return libro.autore.toLowerCase().includes(valoreCerca.toLowerCase());
          case 'genere':
            return libro.genere.toLowerCase() === valoreCerca.toLowerCase();
          case 'isbn':
            return libro.isbn === valoreCerca;
          default:
            return false;
        }
      });

      // Aggiungiamo informazioni sulla biblioteca ai risultati
      libriTrovati.forEach(libro => {
        risultati.push({
          ...libro,
          nomeBiblioteca: biblioteca.nome,
          indirizzoBiblioteca: biblioteca.indirizzo
        });
      });
    }

    return risultati;
  }

  static ottieniStatisticheGlobali() {
    let totaleUtenti = 0;
    let totalePrestitiAttivi = 0;
    let distribuzione GeneriMap = new Map();

    for (const biblioteca of BibliotecaDigitale.registryBiblioteche.values()) {
      totaleUtenti += biblioteca.utentiRegistrati.length;
      totalePrestitiAttivi += biblioteca.prestitiAttivi.length;

      // Calcoliamo la distribuzione dei generi
      biblioteca.libri.forEach(libro => {
        const count = distribuzioneGeneri.get(libro.genere) || 0;
        distribuzioneGeneri.set(libro.genere, count + 1);
      });
    }

    return {
      bibliotecheTotali: BibliotecaDigitale.bibliotecheCreate,
      libriTotali: BibliotecaDigitale.contatoreTotaleLibri,
      utentiTotali: totaleUtenti,
      prestitiAttiviTotali: totalePrestitiAttivi,
      distribuzioneGeneri: Object.fromEntries(distribuzioneGeneri),
      generiSupportati: BibliotecaDigitale.GENERI_SUPPORTATI.length
    };
  }

  // Factory method statico per creare biblioteche con configurazioni predefinite
  static creaBibliotecaUniversitaria(nomeUniversita, indirizzo) {
    const biblioteca = new BibliotecaDigitale(
      `Biblioteca ${nomeUniversita}`,
      indirizzo,
      50000 // Capacit√† maggiore per universit√†
    );

    // Aggiungiamo alcuni libri di base per biblioteche universitarie
    const libriBase = [
      ['Fondamenti di Informatica', 'Autore Vario', 'Tecnologia', '978-1234567890'],
      ['Storia Contemporanea', 'Storico Famoso', 'Storia', '978-1234567891'],
      ['Matematica Discreta', 'Matematico Esperto', 'Scienze', '978-1234567892']
    ];

    libriBase.forEach(([titolo, autore, genere, isbn]) => {
      biblioteca.aggiungiLibro(titolo, autore, genere, isbn);
    });

    console.log(`‚úÖ Biblioteca universitaria creata per ${nomeUniversita} con ${libriBase.length} libri di base`);
    return biblioteca;
  }

  static creaBibliotecaComunale(nomeComune, indirizzo) {
    const biblioteca = new BibliotecaDigitale(
      `Biblioteca Comunale di ${nomeComune}`,
      indirizzo,
      15000
    );

    // Libri pi√π generali per biblioteche comunali
    const libriComunali = [
      ['Ricette della Nonna', 'Chef Tradizionale', 'Cucina', '978-2234567890'],
      ['Arte Rinascimentale', 'Storico Arte', 'Arte', '978-2234567891'],
      ['Biografia di un Leader', 'Biografo Noto', 'Biografie', '978-2234567892']
    ];

    libriComunali.forEach(([titolo, autore, genere, isbn]) => {
      biblioteca.aggiungiLibro(titolo, autore, genere, isbn);
    });

    console.log(`üèõÔ∏è Biblioteca comunale creata per ${nomeComune} con ${libriComunali.length} libri di base`);
    return biblioteca;
  }

  // Utiliry method statico per validazione
  static validaIsbn(isbn) {
    // Rimuove trattini e spazi
    const isbnPulito = isbn.replace(/[-\s]/g, '');

    // Controlla lunghezza (ISBN-10 o ISBN-13)
    if (isbnPulito.length !== 10 && isbnPulito.length !== 13) {
      return false;
    }

    // Controllo base: tutti caratteri numerici
    return /^\d+$/.test(isbnPulito);
  }

  static confrontaBiblioteche(idBiblioteca1, idBiblioteca2) {
    const bib1 = BibliotecaDigitale.registryBiblioteche.get(idBiblioteca1);
    const bib2 = BibliotecaDigitale.registryBiblioteche.get(idBiblioteca2);

    if (!bib1 || !bib2) {
      throw new Error('Una o entrambe le biblioteche non esistono');
    }

    return {
      biblioteca1: {
        nome: bib1.nome,
        libri: bib1.libri.length,
        utenti: bib1.utentiRegistrati.length,
        capacita: bib1.capacitaMassima
      },
      biblioteca2: {
        nome: bib2.nome,
        libri: bib2.libri.length,
        utenti: bib2.utentiRegistrati.length,
        capacita: bib2.capacitaMassima
      },
      migliorePerLibri: bib1.libri.length > bib2.libri.length ? bib1.nome : bib2.nome,
      migliorePerUtenti: bib1.utentiRegistrati.length > bib2.utentiRegistrati.length ? bib1.nome : bib2.nome
    };
  }

  // Metodi statici privati (convenzione con _)
  static _generaIdBiblioteca() {
    return `BIB-${Date.now()}-${Math.random().toString(36).substring(2, 7).toUpperCase()}`;
  }

  static _generaIdLibro() {
    return `BOOK-${Date.now()}-${Math.random().toString(36).substring(2, 7).toUpperCase()}`;
  }

  static _generaIdUtente() {
    return `USER-${Date.now()}-${Math.random().toString(36).substring(2, 7).toUpperCase()}`;
  }

  static _calcolaLimitePrestiti(tipoAbbonamento) {
    switch(tipoAbbonamento.toLowerCase()) {
      case 'premium':
        return BibliotecaDigitale.LIMITE_PRESTITI_DEFAULT * 2;
      case 'studente':
        return BibliotecaDigitale.LIMITE_PRESTITI_DEFAULT + 3;
      case 'base':
      default:
        return BibliotecaDigitale.LIMITE_PRESTITI_DEFAULT;
    }
  }

  // Metodo statico per cleanup (utile per testing)
  static resetGlobalState() {
    BibliotecaDigitale.contatoreTotaleLibri = 0;
    BibliotecaDigitale.bibliotecheCreate = 0;
    BibliotecaDigitale.registryBiblioteche.clear();
    console.log('üîÑ Stato globale delle biblioteche resettato');
  }
}

// Esempi pratici di utilizzo dei metodi e propriet√† statiche
console.log('=== Demo Sistema Biblioteca con Membri Statici ===\n');

console.log('=== Creazione Biblioteche con Factory Methods ===');
const bibUniBocconi = BibliotecaDigitale.creaBibliotecaUniversitaria('Bocconi', 'Via Bocconi 1, Milano');
const bibComuneMilano = BibliotecaDigitale.creaBibliotecaComunale('Milano', 'Piazza Duomo, Milano');
const bibManuale = new BibliotecaDigitale('Biblioteca Personale', 'Via Casa Mia 1', 1000);

console.log('\n=== Test Propriet√† Statiche ===');
console.log('Generi supportati:', BibliotecaDigitale.GENERI_SUPPORTATI);
console.log('Limite prestiti default:', BibliotecaDigitale.LIMITE_PRESTITI_DEFAULT);
console.log('Contatore totale libri:', BibliotecaDigitale.contatoreTotaleLibri);
console.log('Biblioteche create:', BibliotecaDigitale.bibliotecheCreate);

console.log('\n=== Aggiunta Libri e Utenti ===');
bibManuale.aggiungiLibro('Design Patterns', 'Gang of Four', 'Tecnologia', '978-0123456789');
bibManuale.aggiungiLibro('Clean Code', 'Robert Martin', 'Tecnologia', '978-0123456788');
bibUniBocconi.aggiungiLibro('Economia Aziendale', 'Esperto Economia', 'Saggistica', '978-0987654321');

bibManuale.registraUtente('Marco Sviluppatore', 'marco@email.com', 'premium');
bibUniBocconi.registraUtente('Anna Studentessa', 'anna@university.com', 'studente');

console.log('\n=== Test Ricerca Globale (Metodo Statico) ===');
const libriTecnologia = BibliotecaDigitale.trovaLibroInTutteLeBiblioteche('genere', 'Tecnologia');
console.log('Libri di tecnologia trovati in tutte le biblioteche:');
libriTecnologia.forEach(libro => {
  console.log(`- "${libro.titolo}" presso ${libro.nomeBiblioteca}`);
});

console.log('\n=== Statistiche Globali (Metodo Statico) ===');
const statistiche = BibliotecaDigitale.ottieniStatisticheGlobali();
console.log('Statistiche del sistema:');
console.log(JSON.stringify(statistiche, null, 2));

console.log('\n=== Confronto Biblioteche (Metodo Statico) ===');
try {
  const confronto = BibliotecaDigitale.confrontaBiblioteche(bibUniBocconi.id, bibManuale.id);
  console.log('Confronto biblioteche:');
  console.log(JSON.stringify(confronto, null, 2));
} catch (error) {
  console.log('Errore nel confronto:', error.message);
}

console.log('\n=== Test Utility Statiche ===');
console.log('ISBN valido 978-0123456789?', BibliotecaDigitale.validaIsbn('978-0123456789'));
console.log('ISBN valido 123?', BibliotecaDigitale.validaIsbn('123'));

console.log('\n=== Accesso Registry Statico ===');
console.log('Biblioteche nel registry:');
for (const [id, biblioteca] of BibliotecaDigitale.registryBiblioteche) {
  console.log(`${id}: ${biblioteca.nome} (${biblioteca.libri.length} libri)`);
}

// Dimostrazione che i metodi statici non possono accedere a 'this'
console.log('\n=== Test Indipendenza Metodi Statici ===');
// I metodi statici possono essere chiamati anche senza istanze
const statisticheSenzaIstanza = BibliotecaDigitale.ottieniStatisticheGlobali();
console.log('Statistiche accessibili senza istanza:', statisticheSenzaIstanza.bibliotecheTotali > 0);
```

I metodi e le propriet√† statiche forniscono un modo elegante per organizzare funzionalit√† che appartengono concettualmente alla classe ma non a singole istanze specifiche. Sono particolarmente utili per implementare pattern come Singleton, Factory, Registry, e per fornire utility functions che operano su dati globali o che non necessitano di accesso allo stato dell'istanza.

## Getters e Setters: Controllo Elegante dell'Accesso ai Dati

I getters e setters rappresentano uno dei meccanismi pi√π eleganti per implementare l'incapsulamento nelle classi ES6. Essi permettono di definire propriet√† che si comportano come semplici variabili dall'esterno, ma che internamente eseguono logica personalizzata per la lettura o la scrittura dei valori. Questo approccio offre un perfetto equilibrio tra semplicit√† d'uso e controllo fine sul comportamento degli oggetti.

La potenza dei getters e setters risiede nella loro capacit√† di nascondere la complessit√† implementativa dietro un'interfaccia semplice e intuitiva. Possono validare input, calcolare valori derivati, implementare lazy loading, mantenere coerenza tra propriet√† correlate, e molto altro. Esploriamo questi concetti attraverso un sistema di gestione finanziaria personale:

```javascript
class ContoCorrente {
  // Propriet√† private (convenzione con underscore)
  constructor(titolare, saldoIniziale = 0, tipoConto = 'standard') {
    this._titolare = titolare;
    this._saldo = 0; // Inizializzato a zero, poi impostato tramite setter
    this._tipoConto = tipoConto;
    this._transazioni = [];
    this._limitePrelievoGiornaliero = this._calcolaLimitePrelievo(tipoConto);
    this._prelieviOggi = 0;
    this._dataUltimoPrelievo = null;
    this._contoBloccato = false;
    this._dataCreazioneString = new Date().toISOString();

    // Usiamo il setter per impostare il saldo iniziale (con tutte le validazioni)
    if (saldoIniziale > 0) {
      this.saldo = saldoIniziale;
    }

    console.log(
      `Conto corrente creato per ${titolare} con saldo iniziale di ‚Ç¨${this._saldo}`,
    );
  }

  // Getter per il saldo: accesso semplice ma con possibilit√† di logica aggiuntiva
  get saldo() {
    // Possiamo aggiungere logging, controlli di sicurezza, etc.
    if (this._contoBloccato) {
      throw new Error('Impossibile accedere al saldo: conto bloccato');
    }

    return this._saldo;
  }

  // Setter per il saldo: controllo completo su come il valore viene impostato
  set saldo(nuovoSaldo) {
    // Validazione del tipo
    if (typeof nuovoSaldo !== 'number' || isNaN(nuovoSaldo)) {
      throw new Error('Il saldo deve essere un numero valido');
    }

    // Validazione del valore
    if (nuovoSaldo < 0 && this._tipoConto !== 'premium') {
      throw new Error('Saldo negativo non permesso per conti standard');
    }

    if (nuovoSaldo < -1000 && this._tipoConto === 'premium') {
      throw new Error(
        'Saldo non pu√≤ essere inferiore a -‚Ç¨1000 anche per conti premium',
      );
    }

    // Registriamo la transazione se c'√® una variazione
    const variazione = nuovoSaldo - this._saldo;
    if (variazione !== 0) {
      this._registraTransazione(
        variazione > 0 ? 'deposito' : 'prelievo',
        Math.abs(variazione),
        `Regolazione saldo${variazione > 0 ? ' (deposito)' : ' (prelievo)'}`,
      );
    }

    this._saldo = nuovoSaldo;

    // Controlli automatici basati sul nuovo saldo
    this._verificaStatoConto();
  }

  // Getter per propriet√† calcolate/derivate
  get saldoFormattato() {
    const segno = this._saldo >= 0 ? '' : '-';
    const valore = Math.abs(this._saldo);
    return `‚Ç¨${segno}${valore.toLocaleString('it-IT', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
  }

  get bilanciaMensile() {
    const oggi = new Date();
    const inizioMese = new Date(oggi.getFullYear(), oggi.getMonth(), 1);

    const transazioniMese = this._transazioni.filter(
      t => new Date(t.data) >= inizioMese,
    );

    const entrate = transazioniMese
      .filter(t => t.tipo === 'deposito')
      .reduce((totale, t) => totale + t.importo, 0);

    const uscite = transazioniMese
      .filter(t => t.tipo === 'prelievo')
      .reduce((totale, t) => totale + t.importo, 0);

    return {
      periodo: `${inizioMese.toLocaleDateString('it-IT')} - ${oggi.toLocaleDateString('it-IT')}`,
      entrate: entrate,
      uscite: uscite,
      bilancio: entrate - uscite,
      numeroTransazioni: transazioniMese.length,
    };
  }

  get statusConto() {
    if (this._contoBloccato) {
      return 'BLOCCATO';
    } else if (this._saldo < 0) {
      return 'IN ROSSO';
    } else if (this._saldo > 10000) {
      return 'ELEVATO';
    } else if (this._saldo < 100) {
      return 'BASSO';
    } else {
      return 'NORMALE';
    }
  }

  // Getter per dati read-only
  get titolare() {
    return this._titolare;
  }

  get numeroTransazioni() {
    return this._transazioni.length;
  }

  get dataCreazione() {
    return new Date(this._dataCreazioneString);
  }

  // Setter per il tipo di conto con logica di validazione complessa
  get tipoConto() {
    return this._tipoConto;
  }

  set tipoConto(nuovoTipo) {
    const tipiValidi = ['standard', 'premium', 'business'];

    if (!tipiValidi.includes(nuovoTipo)) {
      throw new Error(
        `Tipo di conto non valido. Tipi supportati: ${tipiValidi.join(', ')}`,
      );
    }

    if (nuovoTipo === this._tipoConto) {
      console.log(`Il conto √® gi√† di tipo ${nuovoTipo}`);
      return;
    }

    const vecchioTipo = this._tipoConto;
    this._tipoConto = nuovoTipo;

    // Aggiorniamo il limite di prelievo in base al nuovo tipo
    this._limitePrelievoGiornaliero = this._calcolaLimitePrelievo(nuovoTipo);

    // Se passiamo da premium a standard, controlliamo se il saldo √® valido
    if (
      vecchioTipo === 'premium' &&
      nuovoTipo === 'standard' &&
      this._saldo < 0
    ) {
      console.log(
        '‚ö†Ô∏è  Attenzione: passando a conto standard con saldo negativo, il conto verr√† bloccato',
      );
      this._contoBloccato = true;
    }

    this._registraTransazione(
      'sistema',
      0,
      `Tipo conto cambiato da ${vecchioTipo} a ${nuovoTipo}`,
    );

    console.log(`Tipo di conto aggiornato da ${vecchioTipo} a ${nuovoTipo}`);
    console.log(
      `Nuovo limite prelievo giornaliero: ‚Ç¨${this._limitePrelievoGiornaliero}`,
    );
  }

  // Getter e setter per controllo avanzato del limite prelievo
  get limitePrelievoGiornaliero() {
    return this._limitePrelievoGiornaliero;
  }

  set limitePrelievoGiornaliero(nuovoLimite) {
    if (typeof nuovoLimite !== 'number' || nuovoLimite <= 0) {
      throw new Error('Il limite deve essere un numero positivo');
    }

    const limiteStandard = this._calcolaLimitePrelievo(this._tipoConto);

    // Solo i conti premium e business possono avere limiti personalizzati
    if (this._tipoConto === 'standard' && nuovoLimite > limiteStandard) {
      throw new Error(
        'I conti standard non possono avere limiti superiori a quelli predefiniti',
      );
    }

    if (nuovoLimite > 5000) {
      console.log(
        '‚ö†Ô∏è  Limite molto elevato: potrebbe richiedere approvazione manuale',
      );
    }

    const vecchioLimite = this._limitePrelievoGiornaliero;
    this._limitePrelievoGiornaliero = nuovoLimite;

    this._registraTransazione(
      'sistema',
      0,
      `Limite prelievo cambiato da ‚Ç¨${vecchioLimite} a ‚Ç¨${nuovoLimite}`,
    );

    console.log(`Limite prelievo giornaliero aggiornato: ‚Ç¨${nuovoLimite}`);
  }

  // Metodi pubblici che utilizzano getters e setters internamente
  deposita(importo, descrizione = 'Deposito') {
    if (typeof importo !== 'number' || importo <= 0) {
      throw new Error("L'importo deve essere un numero positivo");
    }

    // Usiamo il setter per beneficiare di tutte le validazioni
    this.saldo += importo;

    console.log(`Depositato ${importo}‚Ç¨. Nuovo saldo: ${this.saldoFormattato}`);
    return this.saldo;
  }

  preleva(importo, descrizione = 'Prelievo') {
    if (typeof importo !== 'number' || importo <= 0) {
      throw new Error("L'importo deve essere un numero positivo");
    }

    // Controlli specifici per i prelievi
    this._verificaLimitePrelievoGiornaliero(importo);

    // Controllo se il prelievo √® possibile
    const nuovoSaldo = this.saldo - importo;
    if (this._tipoConto === 'standard' && nuovoSaldo < 0) {
      throw new Error('Saldo insufficiente per conti standard');
    }

    if (this._tipoConto === 'premium' && nuovoSaldo < -1000) {
      throw new Error('Limite di scoperto raggiunto');
    }

    // Usiamo il setter per il saldo
    this.saldo = nuovoSaldo;

    // Aggiorniamo il tracker dei prelievi giornalieri
    this._aggiornaPrelievoGiornaliero(importo);

    console.log(`Prelevato ${importo}‚Ç¨. Nuovo saldo: ${this.saldoFormattato}`);
    return this.saldo;
  }

  // Metodi privati di supporto
  _calcolaLimitePrelievo(tipoConto) {
    switch (tipoConto) {
      case 'premium':
        return 2000;
      case 'business':
        return 5000;
      default:
        return 500;
    }
  }

  _verificaLimitePrelievoGiornaliero(importoPrelievo) {
    const oggi = new Date().toDateString();

    // Reset del contatore se √® un nuovo giorno
    if (!this._dataUltimoPrelievo || this._dataUltimoPrelievo !== oggi) {
      this._prelieviOggi = 0;
      this._dataUltimoPrelievo = oggi;
    }

    if (
      this._prelieviOggi + importoPrelievo >
      this._limitePrelievoGiornaliero
    ) {
      throw new Error(
        `Limite prelievo giornaliero superato. ` +
          `Disponibili: ‚Ç¨${this._limitePrelievoGiornaliero - this._prelieviOggi}, ` +
          `richiesti: ‚Ç¨${importoPrelievo}`,
      );
    }
  }

  _aggiornaPrelievoGiornaliero(importo) {
    this._prelieviOggi += importo;
  }

  _registraTransazione(tipo, importo, descrizione) {
    const transazione = {
      id: Date.now() + Math.random().toString(36).substring(2),
      tipo: tipo,
      importo: importo,
      descrizione: descrizione,
      data: new Date().toISOString(),
      saldoDopoTransazione: this._saldo,
    };

    this._transazioni.push(transazione);
  }

  _verificaStatoConto() {
    // Logica automatica basata sul saldo
    if (this._saldo < -500 && this._tipoConto === 'premium') {
      console.log('‚ö†Ô∏è  Attenzione: saldo molto basso, considera un deposito');
    }

    if (this._saldo > 50000) {
      console.log('üí° Suggerimento: considera investimenti per saldi elevati');
    }
  }

  // Metodo per ottenere un report completo che usa tutti i getters
  ottieniReportCompleto() {
    return {
      titolare: this.titolare,
      tipoConto: this.tipoConto,
      saldo: this.saldo,
      saldoFormattato: this.saldoFormattato,
      statusConto: this.statusConto,
      limitePrelievoGiornaliero: this.limitePrelievoGiornaliero,
      bilanciaMensile: this.bilanciaMensile,
      numeroTransazioni: this.numeroTransazioni,
      dataCreazione: this.dataCreazione,
      prelieviOggiRemaining:
        this._limitePrelievoGiornaliero - this._prelieviOggi,
    };
  }
}

// Test completo del sistema con getters e setters
console.log('=== Demo Sistema Conto Corrente con Getters/Setters ===\n');

console.log('=== Creazione Conto e Test Getters Base ===');
const contoMario = new ContoCorrente('Mario Rossi', 1000, 'standard');

console.log(`Titolare: ${contoMario.titolare}`);
console.log(`Saldo: ${contoMario.saldo}‚Ç¨`);
console.log(`Saldo formattato: ${contoMario.saldoFormattato}`);
console.log(`Status: ${contoMario.statusConto}`);
console.log(`Tipo conto: ${contoMario.tipoConto}`);

console.log('\n=== Test Setters con Validazione ===');
try {
  console.log('Tentativo di impostare saldo negativo su conto standard...');
  contoMario.saldo = -100; // Dovrebbe fallire
} catch (error) {
  console.log(`‚ùå Errore previsto: ${error.message}`);
}

try {
  console.log('Tentativo di impostare tipo conto non valido...');
  contoMario.tipoConto = 'platinum'; // Dovrebbe fallire
} catch (error) {
  console.log(`‚ùå Errore previsto: ${error.message}`);
}

console.log('\n=== Upgrade a Conto Premium ===');
contoMario.tipoConto = 'premium';
console.log(`Nuovo limite prelievo: ‚Ç¨${contoMario.limitePrelievoGiornaliero}`);

// Ora possiamo andare in rosso
contoMario.saldo = -200;
console.log(`Saldo dopo modifica: ${contoMario.saldoFormattato}`);
console.log(`Status conto: ${contoMario.statusConto}`);

console.log('\n=== Test Operazioni e Getters Calcolati ===');
contoMario.deposita(1500, 'Stipendio');
contoMario.preleva(300, 'Spesa supermercato');
contoMario.preleva(150, 'Benzina');

console.log('\nBilancia mensile:');
const bilancia = contoMario.bilanciaMensile;
console.log(`Periodo: ${bilancia.periodo}`);
console.log(`Entrate: ‚Ç¨${bilancia.entrate}`);
console.log(`Uscite: ‚Ç¨${bilancia.uscite}`);
console.log(`Bilancio: ‚Ç¨${bilancia.bilancio}`);

console.log('\n=== Test Limite Prelievo Personalizzato ===');
console.log(`Limite attuale: ‚Ç¨${contoMario.limitePrelievoGiornaliero}`);
contoMario.limitePrelievoGiornaliero = 3000;
console.log(`Nuovo limite: ‚Ç¨${contoMario.limitePrelievoGiornaliero}`);

console.log('\n=== Report Completo (usa tutti i getters) ===');
const report = contoMario.ottieniReportCompleto();
console.log(JSON.stringify(report, null, 2));

console.log('\n=== Test Conto Business ===');
const contoBusiness = new ContoCorrente('Azienda ABC', 10000, 'business');
contoBusiness.limitePrelievoGiornaliero = 4500;

console.log(
  `Conto business - Limite: ‚Ç¨${contoBusiness.limitePrelievoGiornaliero}`,
);
console.log(`Status: ${contoBusiness.statusConto}`);
console.log(`Saldo formattato: ${contoBusiness.saldoFormattato}`);
```

I getters e setters forniscono un meccanismo potente per implementare un'interfaccia semplice che nasconde complessit√† implementativa. Permettono di mantenere il codice client pulito e intuitivo mentre garantiscono che tutte le invarianti dell'oggetto siano sempre rispettate. Questo approccio √® fondamentale per creare classi robuste e maintainable in JavaScript moderno.

## Esercizi Pratici per Consolidare l'Apprendimento

Per padroneggiare completamente le classi ES6 e l'ereditariet√†, √® essenziale applicare tutti i concetti appresi in scenari realistici e complessi. I seguenti tre esercizi sono progettati per sfidare la tua comprensione a livelli crescenti di complessit√†, coprendo tutti gli aspetti delle classi moderne che abbiamo esplorato.

### Esercizio 1 (Livello Base): Sistema di Gestione Biblioteca Scolastica

Questo primo esercizio ti guider√† nella creazione di un sistema completo per gestire una biblioteca scolastica, implementando i concetti fondamentali delle classi ES6.

```javascript
/**
 * Esercizio 1: Sistema di Gestione Biblioteca Scolastica
 *
 * Crea un sistema per gestire una biblioteca scolastica con le seguenti specifiche:
 *
 * CLASSE BASE: Risorsa
 * - Propriet√†: id, titolo, autore/creatore, annoPublicazione, genere, disponibile
 * - Metodi: prenotare(), restituire(), ottieniInfo(), calcolaAntichia()
 * - Propriet√† statiche: contatoreTotaleRisorse, GENERI_DISPONIBILI
 * - Metodi statici: trovaPerGenere(), ottieniStatistiche()
 *
 * CLASSI DERIVATE:
 * - Libro (estende Risorsa): pagine, isbn, casaEditrice
 * - Rivista (estende Risorsa): numeroEdizione, frequenzaPublicazione
 * - MaterialeMultimediale (estende Risorsa): formato, durata, tipoContenuto
 *
 * OBIETTIVI DI APPRENDIMENTO:
 * - Constructor e super()
 * - Ereditariet√† e override di metodi
 * - Propriet√† e metodi statici
 * - Getters e setters per propriet√† calcolate
 * - Gestione dello stato interno
 */

// Inizia qui la tua implementazione...

class Risorsa {
  // Propriet√† statiche per tenere traccia di tutte le risorse
  static contatoreTotaleRisorse = 0;
  static GENERI_DISPONIBILI = [
    'Fiction',
    'Saggistica',
    'Scienze',
    'Storia',
    'Arte',
    'Tecnologia',
    'Sport',
    'Cucina',
    'Viaggi',
  ];
  static _registroRisorse = []; // Array per tenere traccia di tutte le risorse

  constructor(titolo, autoreCreatore, annoPublicazione, genere) {
    // Il tuo compito: implementa il constructor
    // - Valida i parametri (titolo e autore/creatore non possono essere vuoti)
    // - Verifica che il genere sia in GENERI_DISPONIBILI
    // - Genera un ID unico per la risorsa
    // - Inizializza disponibile a true
    // - Incrementa contatoreTotaleRisorse
    // - Aggiungi questa risorsa al registro statico
    // Implementa qui...
  }

  prenotare(nomeUtente) {
    // Il tuo compito: implementa la logica di prenotazione
    // - Controlla se la risorsa √® disponibile
    // - Se disponibile, imposta disponibile a false e registra chi l'ha prenotata
    // - Registra la data di prenotazione
    // - Restituisce un messaggio di successo o errore
    // Implementa qui...
  }

  restituire() {
    // Il tuo compito: implementa la logica di restituzione
    // - Controlla se la risorsa era effettivamente prenotata
    // - Rimette disponibile a true
    // - Cancella le informazioni di prenotazione
    // - Restituisce un messaggio di successo o errore
    // Implementa qui...
  }

  ottieniInfo() {
    // Il tuo compito: restituisci un oggetto con tutte le informazioni della risorsa
    // Includi anche l'antichit√† calcolata
    // Implementa qui...
  }

  calcolaAntichita() {
    // Il tuo compito: calcola quanti anni ha la risorsa
    // Restituisci il numero di anni dalla pubblicazione
    // Implementa qui...
  }

  // Getters e setters
  get etichettaCompleta() {
    // Il tuo compito: restituisci una stringa nel formato:
    // "TITOLO di AUTORE (ANNO) - Genere: GENERE"
    // Implementa qui...
  }

  get statusPrenotazione() {
    // Il tuo compito: restituisci "Disponibile" o "Prenotato da NOME_UTENTE"
    // Implementa qui...
  }

  // Metodi statici
  static trovaPerGenere(genere) {
    // Il tuo compito: filtra tutte le risorse per genere
    // Restituisci un array di risorse che corrispondono al genere specificato
    // Implementa qui...
  }

  static ottieniStatistiche() {
    // Il tuo compito: calcola e restituisci statistiche globali:
    // - Totale risorse
    // - Risorse disponibili vs prenotate
    // - Distribuzione per genere
    // - Risorsa pi√π vecchia e pi√π recente
    // Implementa qui...
  }

  static _generaId() {
    return (
      'RES-' +
      Date.now() +
      '-' +
      Math.random().toString(36).substring(2, 7).toUpperCase()
    );
  }
}

class Libro extends Risorsa {
  constructor(
    titolo,
    autore,
    annoPublicazione,
    genere,
    pagine,
    isbn,
    casaEditrice,
  ) {
    // Il tuo compito:
    // - Chiama super() con i parametri appropriati
    // - Inizializza le propriet√† specifiche del libro
    // - Valida che pagine sia un numero positivo
    // - Valida il formato dell'ISBN (deve essere una stringa di 10 o 13 caratteri numerici)
    // Implementa qui...
  }

  // Override del metodo padre
  ottieniInfo() {
    // Il tuo compito:
    // - Chiama super.ottieniInfo() per ottenere le informazioni base
    // - Aggiungi le informazioni specifiche del libro (pagine, isbn, casa editrice)
    // - Calcola e aggiungi la "densit√†" (pagine per anno di et√†)
    // Implementa qui...
  }

  get categoriaSpessore() {
    // Il tuo compito: restituisci una categoria basata sul numero di pagine
    // - Meno di 100: "Opuscolo"
    // - 100-300: "Libro normale"
    // - 300-500: "Libro corposo"
    // - Oltre 500: "Libro voluminoso"
    // Implementa qui...
  }

  get tempoLetturaStimato() {
    // Il tuo compito: calcola il tempo di lettura stimato
    // Assumi una velocit√† di lettura di 250 parole al minuto
    // Stima circa 250 parole per pagina
    // Restituisci il tempo in ore e minuti
    // Implementa qui...
  }
}

class Rivista extends Risorsa {
  constructor(
    titolo,
    editore,
    annoPublicazione,
    genere,
    numeroEdizione,
    frequenzaPublicazione,
  ) {
    // Il tuo compito:
    // - Chiama super() (l'editore sar√† il "creatore")
    // - Inizializza numeroEdizione e frequenzaPublicazione
    // - Valida che numeroEdizione sia positivo
    // - Valida che frequenzaPublicazione sia uno dei valori: 'settimanale', 'mensile', 'bimestrale', 'trimestrale'
    // Implementa qui...
  }

  ottieniInfo() {
    // Il tuo compito: estendi le informazioni base con quelle specifiche della rivista
    // Implementa qui...
  }

  get isCurrent() {
    // Il tuo compito: determina se la rivista √® "attuale"
    // Una rivista √® considerata attuale se √® stata pubblicata negli ultimi 2 anni
    // Implementa qui...
  }

  calcolaProssimaEdizione() {
    // Il tuo compito: calcola quando dovrebbe uscire la prossima edizione
    // Basati sulla frequenza di pubblicazione
    // Restituisci una data stimata
    // Implementa qui...
  }
}

class MaterialeMultimediale extends Risorsa {
  constructor(
    titolo,
    creatore,
    annoPublicazione,
    genere,
    formato,
    durata,
    tipoContenuto,
  ) {
    // Il tuo compito:
    // - Chiama super()
    // - Inizializza formato (es: "DVD", "Blu-ray", "Digital"), durata (in minuti), tipoContenuto (es: "Film", "Documentario", "Serie TV")
    // - Valida che durata sia un numero positivo
    // - Valida che formato sia uno dei formati supportati
    // Implementa qui...
  }

  static FORMATI_SUPPORTATI = ['DVD', 'Blu-ray', 'Digital', 'VHS', 'CD'];
  static TIPI_CONTENUTO = [
    'Film',
    'Documentario',
    'Serie TV',
    'Corso',
    'Musica',
  ];

  ottieniInfo() {
    // Il tuo compito: estendi le informazioni base con quelle specifiche del materiale multimediale
    // Includi anche la durata formattata (ore:minuti)
    // Implementa qui...
  }

  get durataFormattata() {
    // Il tuo compito: converte la durata da minuti a formato "Xh Ymin"
    // Esempio: 150 minuti = "2h 30min"
    // Implementa qui...
  }

  get categoriaContenuto() {
    // Il tuo compito: classifica il contenuto in base alla durata
    // - Meno di 30 min: "Contenuto breve"
    // - 30-90 min: "Contenuto standard"
    // - 90-180 min: "Contenuto lungo"
    // - Oltre 180 min: "Contenuto esteso"
    // Implementa qui...
  }
}

// Classe per gestire l'intera biblioteca
class BibliotecaScolastica {
  constructor(nomeBiblioteca, indirizzoScuola) {
    this.nome = nomeBiblioteca;
    this.indirizzo = indirizzoScuola;
    this.dataApertura = new Date();
    this.utentiRegistrati = [];
  }

  registraUtente(nome, classe, email) {
    // Il tuo compito: implementa la registrazione di un nuovo utente
    // - Controlla che non esista gi√† un utente con la stessa email
    // - Crea un oggetto utente con ID unico
    // - Aggiungi alla lista utentiRegistrati
    // Implementa qui...
  }

  cercaRisorsa(criteriocerca, valoreCerca) {
    // Il tuo compito: implementa una funzione di ricerca flessibile
    // Criteri supportati: 'titolo', 'autore', 'genere', 'anno'
    // Restituisci tutte le risorse che corrispondono ai criteri
    // Implementa qui...
  }

  ottieniReportCompleto() {
    // Il tuo compito: genera un report completo della biblioteca
    // - Informazioni generali (nome, indirizzo, data apertura)
    // - Statistiche risorse (usa il metodo statico di Risorsa)
    // - Numero utenti registrati
    // - Top 5 generi pi√π popolari
    // - Risorse attualmente prenotate
    // Implementa qui...
  }
}

// Test del tuo sistema
function testSistemaBiblioteca() {
  console.log('=== Test Sistema Biblioteca Scolastica ===\n');

  // Crea la biblioteca
  const biblioteca = new BibliotecaScolastica(
    'Biblioteca Liceo Da Vinci',
    'Via della Scienza 123',
  );

  // Registra alcuni utenti
  biblioteca.registraUtente('Mario Rossi', '3A', 'mario.rossi@scuola.it');
  biblioteca.registraUtente('Anna Bianchi', '4B', 'anna.bianchi@scuola.it');

  // Aggiungi risorse di diversi tipi
  const libro1 = new Libro(
    'Il Signore degli Anelli',
    'J.R.R. Tolkien',
    1954,
    'Fiction',
    1216,
    '9780007525546',
    'HarperCollins',
  );
  const libro2 = new Libro(
    'Sapiens',
    'Yuval Noah Harari',
    2011,
    'Saggistica',
    443,
    '9780062316097',
    'Harper',
  );

  const rivista1 = new Rivista(
    'National Geographic',
    'National Geographic Society',
    2023,
    'Scienze',
    287,
    'mensile',
  );
  const rivista2 = new Rivista(
    'Focus Storia',
    'Mondadori',
    2023,
    'Storia',
    156,
    'mensile',
  );

  const dvd1 = new MaterialeMultimediale(
    'Cosmos',
    'Carl Sagan',
    1980,
    'Scienze',
    'DVD',
    780,
    'Documentario',
  );
  const bluray1 = new MaterialeMultimediale(
    'Inception',
    'Christopher Nolan',
    2010,
    'Fiction',
    'Blu-ray',
    148,
    'Film',
  );

  // Test delle funzionalit√†
  console.log('=== Test Informazioni Risorse ===');
  console.log('Libro 1:', libro1.etichettaCompleta);
  console.log('Categoria spessore:', libro1.categoriaSpessore);
  console.log('Tempo lettura stimato:', libro1.tempoLetturaStimato);

  console.log('\nRivista 1:', rivista1.etichettaCompleta);
  console.log('√à attuale?', rivista1.isCurrent);

  console.log('\nDVD 1:', dvd1.etichettaCompleta);
  console.log('Durata formattata:', dvd1.durataFormattata);
  console.log('Categoria contenuto:', dvd1.categoriaContenuto);

  console.log('\n=== Test Prenotazioni ===');
  console.log(libro1.prenotare('Mario Rossi'));
  console.log('Status:', libro1.statusPrenotazione);

  console.log(libro1.prenotare('Anna Bianchi')); // Dovrebbe fallire

  console.log(libro1.restituire());
  console.log('Status dopo restituzione:', libro1.statusPrenotazione);

  console.log('\n=== Test Metodi Statici ===');
  const libriFiction = Risorsa.trovaPerGenere('Fiction');
  console.log(`Trovati ${libriFiction.length} risorse di Fiction`);

  const statistiche = Risorsa.ottieniStatistiche();
  console.log('Statistiche globali:', statistiche);

  console.log('\n=== Test Ricerca ===');
  const risultatiRicerca = biblioteca.cercaRisorsa('genere', 'Scienze');
  console.log(`Trovate ${risultatiRicerca.length} risorse di Scienze`);

  console.log('\n=== Report Completo ===');
  const report = biblioteca.ottieniReportCompleto();
  console.log(JSON.stringify(report, null, 2));
}

// Esegui il test quando hai completato l'implementazione
// testSistemaBiblioteca();
```

### Esercizio 2 (Livello Intermedio): Sistema di Gestione E-commerce

Questo esercizio intermedio ti sfider√† con concetti pi√π avanzati come polimorfismo, design patterns, e gestione di stati complessi.

```javascript
/**
 * Esercizio 2: Sistema di Gestione E-commerce Avanzato
 *
 * Crea un sistema e-commerce completo che gestisca prodotti, ordini, utenti e pagamenti.
 *
 * GERARCHIA PRODOTTI:
 * - Classe base Prodotto: id, nome, prezzo, descrizione, categoria, stock, recensioni
 * - ProdottoFisico: peso, dimensioni, costoSpedizione, metodiSpedizione
 * - ProdottoDigitale: dimensioneFile, formatoFile, linkDownload, limitDownload
 * - Abbonamento: durataMesi, rinnovo Automatico, benefici, prezzoMensile
 *
 * SISTEMA UTENTI:
 * - Utente base: dati anagrafici, indirizzi, metodiPagamento, storicoOrdini
 * - UtenteVIP: scontoPercentuale, spedizioneGratuita, supportoPrioritario
 *
 * GESTIONE ORDINI:
 * - Ordine: prodotti, quantit√†, totale, stato, metodoPagamento, indirizzoSpedizione
 * - Stati: 'in_sospeso', 'confermato', 'in_lavorazione', 'spedito', 'consegnato', 'annullato'
 *
 * OBIETTIVI DI APPRENDIMENTO:
 * - Ereditariet√† multipla e polimorfismo avanzato
 * - Getters/setters per logica business complessa
 * - Metodi statici per operazioni globali
 * - Pattern Observer per notifiche
 * - Gestione stati con validazioni
 */

// Inizia qui la tua implementazione...

// Enums simulati per mantenere consistenza
const CATEGORIE_PRODOTTI = {
  ELETTRONICA: 'elettronica',
  ABBIGLIAMENTO: 'abbigliamento',
  LIBRI: 'libri',
  CASA: 'casa',
  SPORT: 'sport',
  DIGITALE: 'digitale'
};

const STATI_ORDINE = {
  IN_SOSPESO: 'in_sospeso',
  CONFERMATO: 'confermato',
  IN_LAVORAZIONE: 'in_lavorazione',
  SPEDITO: 'spedito',
  CONSEGNATO: 'consegnato',
  ANNULLATO: 'annullato'
};

const TIPI_UTENTE = {
  BASE: 'base',
  VIP: 'vip',
  PREMIUM: 'premium'
};

class Prodotto {
  static contatoreTotaleProdotti = 0;
  static catalogoCompleto = [];
  static recensioniTotali = 0;

  constructor(nome, prezzo, descrizione, categoria) {
    // Il tuo compito: implementa il constructor base
    // - Genera ID unico
    // - Valida parametri (prezzo deve essere positivo, categoria deve essere valida)
    // - Inizializza stock a 0, recensioni array vuoto
    // - Aggiungi al catalogo completo
    // - Incrementa contatore

    // Implementa qui...
  }

  aggiungiRecensione(voto, commento, nomeUtente) {
    // Il tuo compito: implementa sistema recensioni
    // - Valida voto (1-5)
    // - Crea oggetto recensione con timestamp
    // - Aggiorna contatori statici
    // - Calcola nuova media voti

    // Implementa qui...
  }

  applicaSconto(percentuale, dataScadenza = null) {
    // Il tuo compito: implementa sistema sconti
    // - Valida percentuale (0-100)
    // - Salva prezzo originale se non gi√† scontato
    // - Applica sconto
    // - Gestisci data scadenza se presente

    // Implementa qui...
  }

  get prezzoFinale() {
    // Il tuo compito: calcola prezzo finale considerando sconti attivi
    // Controlla se lo sconto √® ancora valido

    // Implementa qui...
  }

  get mediaVoti() {
    // Il tuo compito: calcola media delle recensioni

    // Implementa qui...
  }

  get disponibilita() {
    // Il tuo compito: restituisci stato disponibilit√†
    // "Disponibile", "Scorte limitate" (stock < 5), "Non disponibile" (stock = 0)

    // Implementa qui...
  }

  // Metodi astratti da implementare nelle sottoclassi
  calcolaCostoTotale(quantita) {
    throw new Error('Il metodo calcolaCostoTotale deve essere implementato nelle sottoclassi');
  }

  verificaDisponibilita(quantita) {
    throw new Error('Il metodo verificaDisponibilita deve essere implementato nelle sottoclassi');
  }

  // Metodi statici
  static cercaProdotti(criteri) {
    // Il tuo compito: implementa ricerca avanzata
    // Criteri possibili: nome, categoria, prezzoMin, prezzoMax, votoMinimo

    // Implementa qui...
  }

  static ottieniTopProdotti(limite = 10) {
    // Il tuo compito: restituisci i prodotti con voto pi√π alto

    // Implementa qui...
  }
}

class ProdottoFisico extends Prodotto {
  constructor(nome, prezzo, descrizione, categoria, peso, dimensioni) {
    // Il tuo compito:
    // - Chiama super()
    // - Inizializza peso (kg) e dimensioni {lunghezza, larghezza, altezza} (cm)
    // - Valida che peso e dimensioni siano positivi
    // - Inizializza metodiSpedizione disponibili

    // Implementa qui...
  }

  calcolaCostoSpedizione(metodovendi) {
    // Il tuo compito: calcola costo spedizione basato su peso, dimensioni e metodo
    // Metodi: 'standard' (3-5 gg), 'express' (1-2 gg), 'premium' (stesso giorno)
    // Considera anche le dimensioni per calcoli volumetrici

    // Implementa qui...
  }

  calcolaCostoTotale(quantita, metodoSpedizione = 'standard') {
    // Il tuo compito: implementa calcolo costo totale includendo spedizione

    // Implementa qui...
  }

  verificaDisponibilita(quantita) {
    // Il tuo compito: controlla se la quantit√† richiesta √® disponibile

    // Implementa qui...
  }

  get pesoVolumetrico() {
    // Il tuo compito: calcola peso volumetrico (dimensioni / 5000)

    // Implementa qui...
  }

  get pesoBillabile() {
    // Il tuo compito: restituisci il maggiore tra peso reale e peso volumetrico

    // Implementa qui...
  }
}

class ProdottoDigitale extends Prodotto {
  constructor(nome, prezzo, descrizione, categoria, dimensioneFile, formatoFile) {
    // Il tuo compito:
    // - Chiama super()
    // - Inizializza dimensioneFile (MB), formatoFile
    // - Genera linkDownload unico (simulato)
    // - Imposta limitDownload di default a -1 (illimitato)
    // - I prodotti digitali hanno sempre stock infinito

    // Implementa qui...
  }

  generaLinkDownload(utente) {
    // Il tuo compito: genera link download personalizzato per utente
    // Include controlli su limiti download se applicabili

    // Implementa qui...
  }

  calcolaCostoTotale(quantita) {
    // Il tuo compito: per prodotti digitali non c'√® costo spedizione

    // Implementa qui...
  }

  verificaDisponibilita(quantita) {
    // Il tuo compito: prodotti digitali sono sempre disponibili

    // Implementa qui...
  }

  get dimensioneFormattata() {
    // Il tuo compito: formatta dimensione file (MB, GB)

    // Implementa qui...
  }
}

class Abbonamento extends Prodotto {
  constructor(nome, prezzoMensile, descrizione, durataMesi, benefici = []) {
    // Il tuo compito:
    // - Chiama super() con prezzo = prezzoMensile * durataMesi
    // - Inizializza propriet√† specifiche abbonamento
    // - Imposta rinnovo Automatico default a false

    // Implementa qui...
  }

  calcolaCostoTotale(quantita) {
    // Il tuo compito: calcola costo basato su durata e quantit√†

    // Implementa qui...
  }

  verificaDisponibilita(quantita) {
    // Il tuo compito: abbonamenti sempre disponibili

    // Implementa qui...
  }

  get prezzoMensileEffettivo() {
    // Il tuo compito: calcola prezzo mensile considerando sconti

    // Implementa qui...
  }

  calcolaRisparmioAnnuale() {
    // Il tuo compito: calcola risparmio dell'abbonamento vs pagamento mensile

    // Implementa qui...
  }
}

class Utente {
  static contatoreTotaleUtenti = 0;
  static registroUtenti = [];

  constructor(nome, cognome, email, tipoUtente = TIPI_UTENTE.BASE) {
    // Il tuo compito: implementa constructor utente
    // - Genera ID unico
    // - Valida email format
    // - Inizializza arrays per indirizzi, metodiPagamento, storicoOrdini
    // - Imposta limiti spesa basati su tipoUtente

    // Implementa qui...
  }

  aggiungiIndirizzo(indirizzo) {
    // Il tuo compito: aggiunge indirizzo validato
    // Formato: { tipo, via, citt√†, cap, provincia, paese, predefinito }

    // Implementa qui...
  }

  aggiungiMetodoPagamento(metodovera) {
    // Il tuo compito: aggiunge metodo pagamento
    // Formato: { tipo, dettagli, predefinito }
    // Tipi: 'carta_credito', 'paypal', 'bonifico', 'contrassegno'

    // Implementa qui...
  }

  calcolaScontoApplicabile(importo) {
    // Il tuo compito: calcola sconto basato su tipo utente e storico acquisti
    // Metodo virtuale - implementazione base restituisce 0

    return 0;
  }

  get spesaTotale() {
    // Il tuo compito: calcola spesa totale da storico ordini

    // Implementa qui...
  }

  get ordiniCompletati() {
    // Il tuo compito: conta ordini con stato 'consegnato'

    // Implementa qui...
  }
}

class UtenteVIP extends Utente {
  constructor(nome, cognome, email, scontoPercentuale = 10) {
    // Il tuo compito: estendi constructor per utenti VIP

    // Implementa qui...
  }

  calcolaScontoApplicabile(importo) {
    // Il tuo compito: override con logica VIP
    // Sconto percentuale + bonus per spese elevate

    // Implementa qui...
  }

  get spedizioneGratuitaAttiva() {
    // Il tuo compito: VIP hanno sempre spedizione gratuita

    return true;
  }
}

class Ordine {
  static contatoreOrdini = 0;
  static storicoOrdini = [];

  constructor(utente, prodotti = []) {
    // Il tuo compito: implementa constructor ordine
    // - Genera numero ordine
    // - Valida utente e prodotti
    // - Inizializza stato a IN_SOSPESO
    // - Calcola totali iniziali

    // Implementa qui...
  }

  aggiungiProdotto(prodotto, quantita = 1, opzioni = {}) {
    // Il tuo compito: aggiunge prodotto all'ordine
    // - Verifica disponibilit√†
    // - Calcola costi (inclusa spedizione per prodotti fisici)
    // - Aggiorna totali

    // Implementa qui...
  }

  rimuoviProdotto(prodottoId) {
    // Il tuo compito: rimuove prodotto dall'ordine
    // - Solo se ordine non ancora confermato
    // - Ricalcola totali

    // Implementa qui...
  }

  applicaCoupon(codice Coupon) {
    // Il tuo compito: applica coupon di sconto
    // - Valida coupon
    // - Calcola sconto
    // - Aggiorna totali

    // Implementa qui...
  }

  confermaOrdine(metodoPagamento, indirizzoSpedizione) {
    // Il tuo compito: conferma ordine
    // - Cambia stato a CONFERMATO
    // - Processa pagamento (simulato)
    // - Riduce stock prodotti
    // - Genera ricevuta

    // Implementa qui...
  }

  aggiornaStato(nuovoStato, note = '') {
    // Il tuo compito: aggiorna stato ordine
    // - Valida transizione stato
    // - Aggiorna timestamp
    // - Notifica utente (simulato)

    // Implementa qui...
  }

  get subtotale() {
    // Il tuo compito: calcola subtotale prodotti

    // Implementa qui...
  }

  get costoSpedizione() {
    // Il tuo compito: calcola costo spedizione totale

    // Implementa hier...
  }

  get scontiApplicati() {
    // Il tuo compito: calcola sconti totali applicati

    // Implementa hier...
  }

  get totaleFinale() {
    // Il tuo compito: calcola totale finale

    // Implementa heir...
  }

  // Metodi statici
  static ottieniOrdiniPerStato(stato) {
    // Il tuo compito: filtra ordini per stato

    // Implementa hier...
  }

  static calcolaRicaviPeriodo(dataInizio, dataFine) {
    // Il tuo compito: calcola ricavi per periodo

    // Implementa heir...
  }
}

// Sistema principale E-commerce
class SistemaEcommerce {
  constructor(nomeNegozio) {
    this.nome = nomeNegozio;
    this.dataApertura = new Date();
    this.configurazione = {
      valutaBase: 'EUR',
      ivPercentuale: 22,
      spedizioneGratuitaSopra: 50,
      limiteProdottiCarrello: 100
    };
  }

  registraUtente(datiUtente) {
    // Il tuo compito: crea e registra nuovo utente

    // Implementa hier...
  }

  aggiungiProdotto(tipoProdotto, datiProdotto) {
    // Il tuo compito: factory method per creare prodotti
    // Supporta 'fisico', 'digitale', 'abbonamento'

    // Implementa heir...
  }

  creaOrdine(emailUtente) {
    // Il tuo compito: crea nuovo ordine per utente

    // Implementa heir...
  }

  ottieniDashboard() {
    // Il tuo compito: genera dashboard con statistiche complete
    // - Prodotti totali per categoria
    // - Ordini per stato
    // - Ricavi ultimo mese
    // - Top prodotti
    // - Utenti attivi

    // Implementa heir...
  }
}

// Test del sistema
function testSistemaEcommerce() {
  console.log('=== Test Sistema E-commerce Avanzato ===\n');

  const negozio = new SistemaEcommerce('TechStore Pro');

  // Crea prodotti diversi
  const laptop = new ProdottoFisico(
    'MacBook Pro 14"',
    2499.99,
    'Laptop professionale',
    CATEGORIE_PRODOTTI.ELETTRONICA,
    1.6, // peso in kg
    { lunghezza: 31.26, larghezza: 22.12, altezza: 1.55 } // cm
  );

  const ebook = new ProdottoDigitale(
    'Corso JavaScript Avanzato',
    99.99,
    'Corso completo di JavaScript',
    CATEGORIE_PRODOTTI.DIGITALE,
    500, // MB
    'PDF+Video'
  );

  const abbonamentoPremium = new Abbonamento(
    'Premium Membership',
    29.99, // prezzo mensile
    'Accesso illimitato a tutti i contenuti',
    12, // durata mesi
    ['Download illimitati', 'Supporto prioritario', 'Anteprime esclusive']
  );

  // Registra utenti
  const utentePino = negozio.registraUtente({
    nome: 'Mario',
    cognome: 'Rossi',
    email: 'mario@email.com',
    tipo: TIPI_UTENTE.BASE
  });

  const utenteVip = negozio.registraUtente({
    nome: 'Anna',
    cognome: 'Bianchi',
    email: 'anna@email.com',
    tipo: TIPI_UTENTE.VIP
  });

  // Test funzionalit√† complete...

  console.log('Sistema E-commerce inizializzato con successo!');
}

// testSistemaEcommerce();
```

### Esercizio 3 (Livello Avanzato): Sistema di Gestione Ospedaliera

Questo esercizio finale rappresenta il culmine
