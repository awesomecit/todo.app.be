# Promises, async/await e Gestione Asincrona Avanzata

## Prerequisiti Fondamentali: Le Basi della Programmazione Asincrona

Prima di esplorare Promises e async/await, dobbiamo costruire solide fondamenta. Molti sviluppatori si tuffano direttamente nei concetti avanzati senza comprendere completamente i meccanismi sottostanti che rendono possibile la programmazione asincrona in JavaScript. Questo approccio spesso porta a confusione e bug difficili da individuare.

Immagina JavaScript come un ristorante con un solo cuoco (single-threaded) che deve gestire molti ordini contemporaneamente. Come può un singolo cuoco servire efficacemente decine di tavoli senza che nessuno aspetti troppo? La risposta sta nell'organizzazione intelligente del lavoro e nell'uso di assistenti per compiti che richiedono tempo di attesa.

### L'Event Loop: Il Cuore Pulsante di JavaScript

L'Event Loop è il meccanismo che permette a JavaScript di essere asincrono pur essendo single-threaded. È fondamentale comprenderlo perché influenza direttamente come si comportano Promises e async/await.

#### Come Funziona l'Event Loop: Una Spiegazione Visiva

Immaginiamo la struttura interna di JavaScript come una serie di zone di lavoro interconnesse:

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Call Stack    │    │   Web APIs      │    │  Callback Queue │
│                 │    │                 │    │                 │
│  [function3()]  │    │  setTimeout()   │    │  [callback1]    │
│  [function2()]  │    │  fetch()        │    │  [callback2]    │
│  [function1()]  │    │  DOM events     │    │  [callback3]    │
│  [main()]       │    │  etc...         │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         ↑                       ↓                       ↑
         │                       │                       │
         │              ┌─────────────────┐              │
         │              │   Event Loop    │              │
         └──────────────│  "Is call stack  │──────────────┘
                        │   empty? Move    │
                        │  next callback"  │
                        └─────────────────┘
```

L'Event Loop segue un algoritmo molto semplice ma potente:

1. **Esegue tutto nel Call Stack** finché non è vuoto
2. **Controlla la Callback Queue** per vedere se ci sono callback in attesa
3. **Sposta il primo callback** dalla queue al call stack (se il call stack è vuoto)
4. **Ripete il processo** continuamente

#### Esempio Pratico: Tracciamo l'Esecuzione Passo per Passo

Consideriamo questo codice apparentemente semplice ma che spesso confonde gli sviluppatori:

```javascript
console.log('Inizio'); // Esecuzione sincrona

setTimeout(() => {
  console.log('Timeout 1'); // Callback asincrono
}, 0);

setTimeout(() => {
  console.log('Timeout 2'); // Callback asincrono
}, 0);

console.log('Fine'); // Esecuzione sincrona

// Output:
// Inizio
// Fine
// Timeout 1
// Timeout 2
```

Potrebbe sorprenderti che "Fine" venga stampato prima dei timeout, anche se questi hanno delay 0. Vediamo cosa succede nel dettaglio:

**Passo 1-2**: Call Stack esegue `console.log("Inizio")`

```
Call Stack: [console.log("Inizio")]
Web APIs: []
Callback Queue: []
Output: "Inizio"
```

**Passo 3-4**: Incontro `setTimeout()` - la callback viene affidata alle Web APIs

```
Call Stack: [setTimeout(...)]
Web APIs: [Timer 1 (0ms) → callback1]
Callback Queue: []
```

**Passo 5-6**: Secondo `setTimeout()` - altra callback alle Web APIs

```
Call Stack: [setTimeout(...)]
Web APIs: [Timer 1 (0ms) → callback1, Timer 2 (0ms) → callback2]
Callback Queue: []
```

**Passo 7-8**: Call Stack esegue `console.log("Fine")`

```
Call Stack: [console.log("Fine")]
Web APIs: [Timer 1 SCADUTO → callback1, Timer 2 SCADUTO → callback2]
Callback Queue: [callback1, callback2]
Output: "Inizio", "Fine"
```

**Passo 9-10**: Call Stack vuoto, Event Loop sposta le callback

```
Call Stack: [callback1] → esegue console.log("Timeout 1")
Web APIs: []
Callback Queue: [callback2]
Output: "Inizio", "Fine", "Timeout 1"
```

**Passo 11**: Ultima callback

```
Call Stack: [callback2] → esegue console.log("Timeout 2")
Web APIs: []
Callback Queue: []
Output: "Inizio", "Fine", "Timeout 1", "Timeout 2"
```

#### Microtask Queue: La Corsia Preferenziale

Le Promises introducono un concetto aggiuntivo: la **Microtask Queue**, che ha priorità più alta rispetto alla normale Callback Queue (ora chiamata **Macrotask Queue**):

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Call Stack    │    │ Microtask Queue │    │ Macrotask Queue │
│                 │    │                 │    │                 │
│  [executing]    │    │  [promise.then] │    │  [setTimeout]   │
│                 │    │  [queueMicro]   │    │  [setInterval]  │
│                 │    │  [MutationObs]  │    │  [I/O callbacks]│
└─────────────────┘    └─────────────────┘    └─────────────────┘
         ↑                       ↑                       ↑
         │                       │                       │
         │              ┌─────────────────┐              │
         │              │   Event Loop    │              │
         └──────────────│ 1. Call Stack   │──────────────┘
                        │ 2. Microtasks   │
                        │ 3. Macrotasks   │
                        └─────────────────┘
```

Esempio pratico della priorità:

```javascript
console.log('1'); // Sincrono

setTimeout(() => console.log('2'), 0); // Macrotask

Promise.resolve().then(() => console.log('3')); // Microtask

console.log('4'); // Sincrono

// Output: 1, 4, 3, 2
// I microtask (Promise) hanno priorità sui macrotask (setTimeout)!
```

### Callback Functions: L'Era Pre-Promise

Prima dell'avvento delle Promises, le callback erano l'unico modo per gestire operazioni asincrone. Comprendere le callback è essenziale perché molte API moderne sono costruite sopra di esse, e ti aiuterà ad apprezzare i vantaggi delle Promises.

#### Cosa Sono le Callback?

Una callback è semplicemente una funzione passata come argomento ad un'altra funzione, con l'aspettativa che venga chiamata in un momento futuro. Il nome stesso suggerisce l'idea: "chiamami indietro quando hai finito".

```javascript
// Esempio concettuale: una callback nel mondo reale
function ordinaPizza(tipo, quandoPronte) {
  console.log(`Ordinando pizza ${tipo}...`);

  // Simula il tempo di preparazione
  setTimeout(() => {
    const pizza = `Pizza ${tipo} pronta!`;
    quandoPronte(pizza); // "Chiamata indietro" quando pronta
  }, 2000);
}

// Utilizzo della callback
ordinaPizza('Margherita', pizzaPronte => {
  console.log('Ho ricevuto:', pizzaPronte);
  console.log('Posso iniziare a mangiare!');
});

console.log('Nel frattempo posso fare altre cose...');

// Output:
// Ordinando pizza Margherita...
// Nel frattempo posso fare altre cose...
// (dopo 2 secondi)
// Ho ricevuto: Pizza Margherita pronta!
// Posso iniziare a mangiare!
```

#### Pattern della Callback: Error-First Convention

La convenzione più comune per le callback in JavaScript (specialmente in Node.js) è il pattern "error-first":

```javascript
function leggiFile(nomeFile, callback) {
  // Simula lettura file
  setTimeout(() => {
    const successo = Math.random() > 0.3; // 70% di successo

    if (successo) {
      const contenuto = `Contenuto del file ${nomeFile}`;
      callback(null, contenuto); // null = nessun errore
    } else {
      const errore = new Error(`Impossibile leggere ${nomeFile}`);
      callback(errore, null); // errore come primo parametro
    }
  }, 1000);
}

// Utilizzo con gestione errori
leggiFile('documento.txt', (errore, contenuto) => {
  if (errore) {
    console.error('Errore:', errore.message);
    return; // Gestione dell'errore
  }

  console.log('File letto con successo:', contenuto);
  // Procedi con la logica normale
});
```

#### Il Problema delle Callback Annidate

Le callback diventano problematiche quando dobbiamo concatenare multiple operazioni asincrone. Immagina di dover:

1. Leggere un file di configurazione
2. Usare quella configurazione per connettersi a un database
3. Eseguire una query basata sui dati letti
4. Formattare i risultati
5. Salvare i risultati in un altro file

```javascript
// Esempio realistico di callback hell
leggiFile('config.json', (errore, config) => {
  if (errore) {
    console.error('Errore config:', errore);
    return;
  }

  connettiDatabase(config.db, (errore, connessione) => {
    if (errore) {
      console.error('Errore connessione:', errore);
      return;
    }

    eseguiQuery(connessione, config.query, (errore, risultati) => {
      if (errore) {
        console.error('Errore query:', errore);
        connessione.close();
        return;
      }

      formattaRisultati(risultati, (errore, datiFormattati) => {
        if (errore) {
          console.error('Errore formattazione:', errore);
          connessione.close();
          return;
        }

        salvaFile('output.json', datiFormattati, errore => {
          if (errore) {
            console.error('Errore salvataggio:', errore);
          } else {
            console.log('Operazione completata con successo!');
          }
          connessione.close();
        });
      });
    });
  });
});
```

Questo codice presenta diversi problemi critici che le Promises risolveranno:

- **Indentazione eccessiva**: Il codice diventa rapidamente illeggibile
- **Gestione errori ripetitiva**: Ogni livello deve gestire errori in modo simile
- **Difficile refactoring**: Modificare il flusso richiede ristrutturazioni significative
- **Testing complesso**: Testare singoli step isolatamente è molto difficile
- **Resource management**: Difficile garantire che le risorse vengano liberate correttamente

### Funzioni JavaScript: Fondamenta Solide

Per lavorare efficacemente con la programmazione asincrona, dobbiamo avere una comprensione solida di come funzionano le funzioni in JavaScript, poiché callbacks, Promises e async/await sono tutti costruiti su questi concetti.

#### Dichiarazioni vs Espressioni di Funzioni

```javascript
// Function Declaration - viene "hoisted" (sollevata)
function dichiarazione() {
  return 'Posso essere chiamata prima della mia definizione';
}

// Function Expression - non viene hoisted
const espressione = function () {
  return 'Posso essere chiamata solo dopo la mia definizione';
};

// Arrow Function - forma compatta, comportamento diverso del 'this'
const arrow = () => {
  return 'Sintassi concisa, ideale per callback';
};

// Arrow function con return implicito
const arrowCompatta = () => 'Return automatico per espressioni singole';
```

#### Higher-Order Functions: Funzioni che Lavorano con Funzioni

Le higher-order functions sono funzioni che accettano altre funzioni come parametri o le ritornano. Questo concetto è fondamentale per comprendere callback e Promise chaining:

```javascript
// Esempio di higher-order function personalizzata
function eseguiConLog(operazione, ...parametri) {
  console.log(`Inizio operazione: ${operazione.name}`);
  const inizio = Date.now();

  const risultato = operazione(...parametri);

  const durata = Date.now() - inizio;
  console.log(`Operazione completata in ${durata}ms`);

  return risultato;
}

// Utilizzo
function calcolaQuadrato(numero) {
  return numero * numero;
}

const risultato = eseguiConLog(calcolaQuadrato, 5);
console.log('Risultato:', risultato);
```

### Scope e Closures: Il Contesto delle Funzioni Asincrone

Le closures sono particolarmente importanti nella programmazione asincrona perché permettono alle callback e alle Promise di "ricordare" il contesto in cui sono state create.

#### Lexical Scope: Dove le Variabili Sono Accessibili

```javascript
function esterno() {
  const variabileEsterna = 'Sono visibile anche dentro';

  function interno() {
    const variabileInterna = 'Sono visibile solo qui';
    console.log(variabileEsterna); // OK - scope esterno accessibile
    console.log(variabileInterna); // OK - scope locale
  }

  interno();
  // console.log(variabileInterna); // ERRORE - fuori scope!
}

esterno();
```

#### Closures in Azione: Mantenere lo Stato

Le closures permettono alle funzioni di "catturare" e mantenere variabili dal loro scope di creazione:

```javascript
function creaContatore() {
  let conteggio = 0; // Variabile "privata"

  return function () {
    conteggio++; // La closure "ricorda" conteggio
    return conteggio;
  };
}

const contatore1 = creaContatore();
const contatore2 = creaContatore();

console.log(contatore1()); // 1
console.log(contatore1()); // 2
console.log(contatore2()); // 1 (contatore indipendente)
console.log(contatore1()); // 3
```

#### Closures nelle Operazioni Asincrone

Le closures sono essenziali per mantenere il contesto nelle operazioni asincrone:

```javascript
function processaUtenti(utenti) {
  utenti.forEach((utente, indice) => {
    // La closure cattura 'utente' e 'indice'
    setTimeout(() => {
      console.log(`Processando utente ${indice}: ${utente.nome}`);
      // utente e indice sono ancora disponibili!
    }, indice * 1000); // Delay progressivo
  });
}

const utenti = [{ nome: 'Mario' }, { nome: 'Luigi' }, { nome: 'Peach' }];

processaUtenti(utenti);
// Output (con delay):
// Processando utente 0: Mario
// Processando utente 1: Luigi  (dopo 1 sec)
// Processando utente 2: Peach  (dopo 2 sec)
```

### Array Methods: Strumenti per la Programmazione Funzionale

I metodi degli array come `map`, `filter`, `reduce` e `forEach` sono fondamentali per lavorare efficacemente con operazioni asincrone, specialmente quando dobbiamo processare collezioni di dati.

#### Map: Trasformare Ogni Elemento

```javascript
// Trasformazione sincrona
const numeri = [1, 2, 3, 4, 5];
const quadrati = numeri.map(numero => numero * numero);
console.log(quadrati); // [1, 4, 9, 16, 25]

// Preparazione per trasformazioni asincrone
const utenti = ['mario', 'luigi', 'peach'];
const urlsApi = utenti.map(nome => `/api/users/${nome}`);
console.log(urlsApi); // ["/api/users/mario", "/api/users/luigi", "/api/users/peach"]
```

#### Filter: Selezionare Elementi

```javascript
// Filtro sincrono
const numeri = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const pari = numeri.filter(numero => numero % 2 === 0);
console.log(pari); // [2, 4, 6, 8, 10]

// Filtro per preparare operazioni asincrone
const tasks = [
  { id: 1, completed: false, priority: 'high' },
  { id: 2, completed: true, priority: 'low' },
  { id: 3, completed: false, priority: 'high' },
  { id: 4, completed: false, priority: 'medium' },
];

const tasksAttive = tasks.filter(task => !task.completed);
const tasksPriorite = tasksAttive.filter(task => task.priority === 'high');
console.log(tasksPriorite); // Tasks non completate ad alta priorità
```

#### Reduce: Aggregare e Combinare

```javascript
// Somma semplice
const numeri = [1, 2, 3, 4, 5];
const somma = numeri.reduce((accumulo, numero) => accumulo + numero, 0);
console.log(somma); // 15

// Raggruppamento più complesso (utile per operazioni asincrone)
const ordini = [
  { cliente: 'Mario', importo: 100, stato: 'completato' },
  { cliente: 'Luigi', importo: 150, stato: 'pending' },
  { cliente: 'Mario', importo: 75, stato: 'completato' },
  { cliente: 'Peach', importo: 200, stato: 'completato' },
];

// Raggruppa ordini per cliente
const ordiniPerCliente = ordini.reduce((raggruppo, ordine) => {
  if (!raggruppo[ordine.cliente]) {
    raggruppo[ordine.cliente] = [];
  }
  raggruppo[ordine.cliente].push(ordine);
  return raggruppo;
}, {});

console.log(ordiniPerCliente);
// {
//   Mario: [{ cliente: "Mario", importo: 100, stato: "completato" }, ...]
//   Luigi: [{ cliente: "Luigi", importo: 150, stato: "pending" }],
//   Peach: [{ cliente: "Peach", importo: 200, stato: "completato" }]
// }
```

#### Array Methods con Funzioni Asincrone: Anteprima

Anche se approfondiremo questo aspetto più avanti, è utile vedere come questi metodi si relazionano con operazioni asincrone:

```javascript
// PROBLEMA: map con async/await non funziona come potresti aspettarti
async function recuperaNomiUtenti(ids) {
  // Questo NON funziona come aspettato!
  const nomi = ids.map(async id => {
    const response = await fetch(`/api/users/${id}`);
    const user = await response.json();
    return user.nome;
  });

  console.log(nomi); // Array di Promises, non di nomi!
  return nomi;
}

// SOLUZIONE: Promise.all con map
async function recuperaNomiUtentiCorretto(ids) {
  const promisesNomi = ids.map(async id => {
    const response = await fetch(`/api/users/${id}`);
    const user = await response.json();
    return user.nome;
  });

  const nomi = await Promise.all(promisesNomi);
  console.log(nomi); // Effettivamente un array di nomi!
  return nomi;
}
```

### Mettendo Tutto Insieme: Un Esempio Preparatorio

Ora che abbiamo coperto tutti i prerequisiti, vediamo come si combinano in un esempio che anticipa quello che impareremo con le Promises:

```javascript
// Simulazione di operazioni asincrone con callback
function simulaApiCall(endpoint, callback) {
  const delay = Math.random() * 2000; // Ritardo casuale fino a 2 secondi
  const success = Math.random() > 0.2; // 80% di successo

  setTimeout(() => {
    if (success) {
      callback(null, `Dati da ${endpoint}`);
    } else {
      callback(new Error(`Errore chiamata a ${endpoint}`), null);
    }
  }, delay);
}

// Orchestrazione di multiple chiamate API usando tutti i concetti visti
function caricaDashboard(userId, callback) {
  const endpoints = ['profile', 'notifications', 'analytics'];
  const risultati = {};
  let completate = 0;
  let erroriRiscontrati = [];

  // Utilizzo di closures per mantenere lo stato
  endpoints.forEach(endpoint => {
    simulaApiCall(`/api/${endpoint}/${userId}`, (errore, dati) => {
      completate++;

      if (errore) {
        erroriRiscontrati.push({ endpoint, errore: errore.message });
      } else {
        risultati[endpoint] = dati;
      }

      // Controlla se tutte le chiamate sono completate
      if (completate === endpoints.length) {
        if (erroriRiscontrati.length > 0) {
          callback(erroriRiscontrati, risultati);
        } else {
          callback(null, risultati);
        }
      }
    });
  });
}

// Utilizzo con gestione degli errori
caricaDashboard('user123', (errori, dati) => {
  if (errori) {
    console.error('Alcuni errori sono stati riscontrati:', errori);
    console.log('Dati parziali disponibili:', dati);
  } else {
    console.log('Tutti i dati caricati con successo:', dati);
  }
});
```

Questo esempio mostra la complessità che emerge anche con operazioni relativamente semplici quando si utilizzano solo callback. Noterai come il codice diventi rapidamente complesso e difficile da seguire, anche con una buona comprensione dei prerequisiti.

È proprio questa complessità che ha portato alla creazione delle Promises e, successivamente, della sintassi async/await. Ora che hai una solida comprensione delle fondamenta, sei pronto per apprezzare completamente come questi strumenti moderni semplificano drasticamente la gestione delle operazioni asincrone.

### L'Evoluzione della Gestione Asincrona in JavaScript

La gestione asincrona in JavaScript ha attraversato diverse fasi evolutive:

1. **Era dei Callback (pre-2012)**: La gestione asincrona avveniva esclusivamente tramite callback
2. **Era delle Promises (2012-2015)**: Introduzione delle Promise per risolvere il "callback hell"
3. **Era async/await (2017-oggi)**: Sintassi più pulita e leggibile per le operazioni asincrone

## Il Problema: Callback Hell

Prima di apprezzare le Promises, dobbiamo comprendere il problema che risolvono. Considera questo scenario realistico:

```javascript
// Esempio di Callback Hell - PROBLEMA
function processUserOrder(userId, callback) {
  // 1. Recupera i dati dell'utente
  getUserData(userId, (err, user) => {
    if (err) {
      callback(err, null);
      return;
    }

    // 2. Verifica il credito dell'utente
    checkUserCredit(user.id, (err, creditInfo) => {
      if (err) {
        callback(err, null);
        return;
      }

      // 3. Calcola il prezzo dell'ordine
      calculateOrderPrice(user.cartItems, (err, totalPrice) => {
        if (err) {
          callback(err, null);
          return;
        }

        // 4. Processa il pagamento
        processPayment(user.id, totalPrice, (err, paymentResult) => {
          if (err) {
            callback(err, null);
            return;
          }

          // 5. Invia email di conferma
          sendConfirmationEmail(
            user.email,
            paymentResult,
            (err, emailResult) => {
              if (err) {
                callback(err, null);
                return;
              }

              callback(null, {
                user,
                payment: paymentResult,
                email: emailResult,
              });
            },
          );
        });
      });
    });
  });
}
```

Questo codice presenta diversi problemi critici:

- **Pyramid of Doom**: Indentazione eccessiva che rende il codice difficile da leggere
- **Error Handling Ripetitivo**: Ogni callback deve gestire errori in modo simile
- **Difficile Manutenzione**: Aggiungere o modificare step è complesso
- **Testing Complesso**: Difficile testare singole parti del flusso

## Le Promises: La Soluzione Elegante

Una **Promise** è un oggetto che rappresenta il completamento (o il fallimento) di un'operazione asincrona. Pensa a una Promise come a un "contratto" che garantisce che prima o poi riceverai un risultato.

### Anatomia di una Promise

Una Promise può trovarsi in uno di questi tre stati:

| Stato         | Descrizione                        | Metodo di Risoluzione |
| ------------- | ---------------------------------- | --------------------- |
| **Pending**   | Operazione in corso                | Stato iniziale        |
| **Fulfilled** | Operazione completata con successo | `resolve()`           |
| **Rejected**  | Operazione fallita                 | `reject()`            |

```javascript
// Anatomia base di una Promise
const myPromise = new Promise((resolve, reject) => {
  // Simula un'operazione asincrona (es. chiamata API)
  setTimeout(() => {
    const success = Math.random() > 0.5; // 50% di probabilità di successo

    if (success) {
      resolve('Operazione completata con successo!'); // Fulfill
    } else {
      reject(new Error('Qualcosa è andato storto!')); // Reject
    }
  }, 1000);
});

// Utilizzo della Promise
myPromise
  .then(result => {
    console.log('Successo:', result);
  })
  .catch(error => {
    console.error('Errore:', error.message);
  });
```

### Refactoring del Callback Hell con Promises

Vediamo come le Promises trasformano il nostro esempio precedente:

```javascript
// Versione con Promises - SOLUZIONE
function processUserOrder(userId) {
  return getUserData(userId) // Ritorna una Promise
    .then(user => {
      return checkUserCredit(user.id).then(creditInfo => ({
        user,
        creditInfo,
      }));
    })
    .then(({ user, creditInfo }) => {
      return calculateOrderPrice(user.cartItems).then(totalPrice => ({
        user,
        creditInfo,
        totalPrice,
      }));
    })
    .then(({ user, creditInfo, totalPrice }) => {
      return processPayment(user.id, totalPrice).then(paymentResult => ({
        user,
        paymentResult,
      }));
    })
    .then(({ user, paymentResult }) => {
      return sendConfirmationEmail(user.email, paymentResult).then(
        emailResult => ({
          user,
          payment: paymentResult,
          email: emailResult,
        }),
      );
    })
    .catch(error => {
      // Gestione centralizzata degli errori
      console.error("Errore nel processamento dell'ordine:", error);
      throw error; // Re-throw per permettere al chiamante di gestire
    });
}
```

Già meglio, ma possiamo fare di più! Ecco una versione ancora più pulita:

```javascript
// Versione ottimizzata con Promise chaining
async function processUserOrder(userId) {
  try {
    const user = await getUserData(userId);
    const creditInfo = await checkUserCredit(user.id);
    const totalPrice = await calculateOrderPrice(user.cartItems);
    const paymentResult = await processPayment(user.id, totalPrice);
    const emailResult = await sendConfirmationEmail(user.email, paymentResult);

    return {
      user,
      payment: paymentResult,
      email: emailResult,
    };
  } catch (error) {
    console.error("Errore nel processamento dell'ordine:", error);
    throw error;
  }
}
```

## Promise Methods Essenziali

### Promise.resolve() e Promise.reject()

```javascript
// Creare Promises già risolte o rifiutate
const resolvedPromise = Promise.resolve('Valore immediato');
const rejectedPromise = Promise.reject(new Error('Errore immediato'));

resolvedPromise.then(console.log); // "Valore immediato"
rejectedPromise.catch(console.error); // Error: Errore immediato
```

### Promise.all() - Operazioni Parallele

Quando hai bisogno di eseguire multiple operazioni asincrone in parallelo e aspettare che tutte completino:

```javascript
// Esempio pratico: Caricare dati da multiple API
async function loadDashboardData(userId) {
  try {
    // Esegue tutte le chiamate in parallelo
    const [userProfile, notifications, analytics, settings] = await Promise.all(
      [
        fetchUserProfile(userId),
        fetchNotifications(userId),
        fetchAnalytics(userId),
        fetchUserSettings(userId),
      ],
    );

    return {
      profile: userProfile,
      notifications,
      analytics,
      settings,
    };
  } catch (error) {
    // Se anche solo una Promise fallisce, Promise.all viene rigettata
    console.error('Errore nel caricamento dei dati dashboard:', error);
    throw error;
  }
}
```

**Importante**: Promise.all fallisce completamente se anche solo una delle Promises viene rigettata.

### Promise.allSettled() - Attendere Tutte le Risoluzioni

Quando vuoi aspettare che tutte le Promises completino, indipendentemente dal loro esito:

```javascript
async function loadOptionalData(userId) {
  const promises = [
    fetchUserProfile(userId), // Essenziale
    fetchRecommendations(userId), // Opzionale
    fetchAds(userId), // Opzionale
    fetchWeatherData(), // Opzionale
  ];

  const results = await Promise.allSettled(promises);

  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      console.log(`Operazione ${index} completata:`, result.value);
    } else {
      console.error(`Operazione ${index} fallita:`, result.reason);
    }
  });

  // Processa solo i risultati riusciti
  const successfulResults = results
    .filter(result => result.status === 'fulfilled')
    .map(result => result.value);

  return successfulResults;
}
```

### Promise.race() - Prima Promise che Completa

Utile per implementare timeout o per scegliere la risposta più veloce tra multiple fonti:

```javascript
// Implementazione di timeout per le chiamate API
function fetchWithTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Timeout scaduto')), timeout);
  });

  return Promise.race([fetchPromise, timeoutPromise]);
}

// Utilizzo
async function loadDataWithTimeout() {
  try {
    const response = await fetchWithTimeout('/api/data', 3000);
    const data = await response.json();
    return data;
  } catch (error) {
    if (error.message === 'Timeout scaduto') {
      console.error('La richiesta ha impiegato troppo tempo');
      // Fallback o retry logic
      return await loadFromCache();
    }
    throw error;
  }
}
```

## Async/Await: Sintassi Sincrona per Codice Asincrono

Async/await è **syntactic sugar** sopra le Promises che rende il codice asincrono più leggibile e simile al codice sincrono.

### Regole Fondamentali

1. **async** può essere usato solo con funzioni
2. **await** può essere usato solo dentro funzioni async
3. Una funzione async **ritorna sempre una Promise**

```javascript
// Dichiarazioni diverse di funzioni async
async function regularFunction() {
  /* ... */
}

const arrowFunction = async () => {
  /* ... */
};

const objectMethod = {
  async method() {
    /* ... */
  },
};

class MyClass {
  async classMethod() {
    /* ... */
  }
}
```

### Esempio Completo: Sistema di Cache Intelligente

```javascript
class DataCache {
  constructor() {
    this.cache = new Map();
    this.cacheTTL = 5 * 60 * 1000; // 5 minuti
  }

  // Verifica se i dati in cache sono ancora validi
  isCacheValid(key) {
    const cached = this.cache.get(key);
    if (!cached) return false;

    return Date.now() - cached.timestamp < this.cacheTTL;
  }

  // Metodo async per recuperare dati con cache intelligente
  async getData(key, fetchFunction) {
    // Controlla prima la cache
    if (this.isCacheValid(key)) {
      console.log(`Cache hit per ${key}`);
      return this.cache.get(key).data;
    }

    console.log(`Cache miss per ${key} - fetching...`);

    try {
      // Esegue la funzione di fetch (che ritorna una Promise)
      const data = await fetchFunction();

      // Salva in cache con timestamp
      this.cache.set(key, {
        data,
        timestamp: Date.now(),
      });

      return data;
    } catch (error) {
      console.error(`Errore nel fetch per ${key}:`, error);

      // Ritorna dati dalla cache anche se scaduti (fallback)
      const cached = this.cache.get(key);
      if (cached) {
        console.log(`Usando cache scaduta come fallback per ${key}`);
        return cached.data;
      }

      throw error;
    }
  }
}

// Utilizzo del cache system
const cache = new DataCache();

async function loadUserData(userId) {
  return cache.getData(`user-${userId}`, async () => {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response.json();
  });
}
```

## Gestione Avanzata degli Errori

### Pattern: Try-Catch con Retry Logic

```javascript
async function resilientApiCall(url, maxRetries = 3, delayMs = 1000) {
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`Tentativo ${attempt}/${maxRetries} per ${url}`);

      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      console.log(`Successo al tentativo ${attempt}`);
      return data;
    } catch (error) {
      lastError = error;
      console.error(`Tentativo ${attempt} fallito:`, error.message);

      if (attempt < maxRetries) {
        // Exponential backoff: aumenta il delay ad ogni tentativo
        const backoffDelay = delayMs * Math.pow(2, attempt - 1);
        console.log(
          `Aspetto ${backoffDelay}ms prima del prossimo tentativo...`,
        );
        await delay(backoffDelay);
      }
    }
  }

  throw new Error(
    `Tutti i ${maxRetries} tentativi falliti. Ultimo errore: ${lastError.message}`,
  );
}

// Utility function per il delay
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

### Pattern: Circuit Breaker

Il Circuit Breaker è un pattern per prevenire chiamate ripetute a servizi che stanno fallendo:

```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000, monitor = false) {
    this.threshold = threshold; // Numero di errori prima di "aprire" il circuito
    this.timeout = timeout; // Tempo prima di ritentare
    this.monitor = monitor; // Log per debug

    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }

  async call(fn, ...args) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
        this.log('Circuit breaker: HALF_OPEN - tentativo di recovery');
      } else {
        throw new Error('Circuit breaker OPEN - servizio non disponibile');
      }
    }

    try {
      const result = await fn(...args);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
    this.log('Circuit breaker: Reset - servizio recovered');
  }

  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();

    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
      this.log(`Circuit breaker: OPEN - soglia ${this.threshold} superata`);
    }
  }

  log(message) {
    if (this.monitor) {
      console.log(`[CircuitBreaker] ${message}`);
    }
  }
}

// Utilizzo del Circuit Breaker
const apiCircuitBreaker = new CircuitBreaker(3, 30000, true);

async function callExternalAPI(endpoint) {
  return apiCircuitBreaker.call(async () => {
    const response = await fetch(endpoint);
    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }
    return response.json();
  });
}
```

## Pattern Avanzati di Gestione Asincrona

### Sequential vs Parallel Execution

```javascript
// SEQUENZIALE - Ogni operazione aspetta la precedente
async function sequentialProcessing(items) {
  const results = [];

  for (const item of items) {
    const result = await processItem(item); // Aspetta prima di continuare
    results.push(result);
  }

  return results;
}

// PARALLELO - Tutte le operazioni iniziano insieme
async function parallelProcessing(items) {
  const promises = items.map(item => processItem(item));
  return Promise.all(promises);
}

// BATCH - Limita il numero di operazioni concorrenti
async function batchProcessing(items, batchSize = 3) {
  const results = [];

  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchPromises = batch.map(item => processItem(item));
    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults);

    console.log(`Processato batch ${Math.floor(i / batchSize) + 1}`);
  }

  return results;
}
```

### Async Iterators e for-await-of

```javascript
// Async Iterator per processare grandi dataset
class AsyncDataProcessor {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }

  async *processData() {
    let offset = 0;
    const batchSize = 100;

    while (true) {
      const batch = await this.dataSource.getBatch(offset, batchSize);

      if (batch.length === 0) break; // Fine dati

      for (const item of batch) {
        const processedItem = await this.processItem(item);
        yield processedItem; // Yield ogni item processato
      }

      offset += batchSize;
    }
  }

  async processItem(item) {
    // Simula processing asincrono
    await delay(10);
    return { ...item, processed: true, timestamp: Date.now() };
  }
}

// Utilizzo dell'async iterator
async function consumeAsyncData() {
  const processor = new AsyncDataProcessor(dataSource);

  // for-await-of per consumare l'async iterator
  for await (const processedItem of processor.processData()) {
    console.log('Item processato:', processedItem);

    // Possiamo fare altre operazioni asincrone qui
    await saveToDatabase(processedItem);
  }

  console.log('Tutti i dati sono stati processati');
}
```

## Edge Cases e Problemi Comuni

### Edge Case 1: Promise che Non Si Risolve Mai

```javascript
// PROBLEMA: Promise che rimane pending per sempre
function problematicFunction() {
  return new Promise((resolve, reject) => {
    // Nessun codice che chiama resolve() o reject()
    setTimeout(() => {
      console.log('Questo si esegue ma la Promise non si risolve mai');
    }, 1000);
  });
}

// SOLUZIONE: Sempre implementare timeout
function createTimeoutPromise(promise, timeoutMs = 5000) {
  return Promise.race([
    promise,
    new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Timeout')), timeoutMs);
    }),
  ]);
}

async function safeAsyncCall() {
  try {
    const result = await createTimeoutPromise(problematicFunction(), 3000);
    return result;
  } catch (error) {
    if (error.message === 'Timeout') {
      console.error('Operazione scaduta dopo 3 secondi');
    }
    throw error;
  }
}
```

### Edge Case 2: Memory Leaks con Event Listeners

```javascript
// PROBLEMA: Event listeners che creano memory leaks
class ProblematicClass {
  constructor() {
    this.data = [];

    // Listener che referenzia this - potenziale memory leak
    window.addEventListener('resize', () => {
      this.handleResize();
    });
  }

  async loadData() {
    // Se questo fallisce, il listener rimane attivo
    this.data = await fetchLargeDataset();
  }

  handleResize() {
    console.log('Resize handled', this.data.length);
  }
}

// SOLUZIONE: Cleanup appropriato
class SafeClass {
  constructor() {
    this.data = [];
    this.abortController = new AbortController();

    // Usa AbortController per cleanup automatico
    window.addEventListener(
      'resize',
      () => {
        this.handleResize();
      },
      { signal: this.abortController.signal },
    );
  }

  async loadData() {
    try {
      // Usa fetch con AbortSignal
      const response = await fetch('/api/large-dataset', {
        signal: this.abortController.signal,
      });
      this.data = await response.json();
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Operazione annullata');
        return;
      }
      throw error;
    }
  }

  handleResize() {
    if (!this.abortController.signal.aborted) {
      console.log('Resize handled', this.data.length);
    }
  }

  // Metodo per cleanup
  destroy() {
    this.abortController.abort();
    this.data = [];
  }
}
```

### Edge Case 3: Race Conditions

```javascript
// PROBLEMA: Race condition con multiple chiamate async
class UserManager {
  constructor() {
    this.cache = {};
  }

  // PROBLEMATICO: Multiple chiamate possono creare race conditions
  async getUser(userId) {
    if (this.cache[userId]) {
      return this.cache[userId];
    }

    // Se due chiamate arrivano contemporaneamente,
    // entrambe fanno la fetch!
    const user = await fetch(`/api/users/${userId}`).then(r => r.json());
    this.cache[userId] = user;
    return user;
  }
}

// SOLUZIONE: Promise caching
class SafeUserManager {
  constructor() {
    this.cache = {};
    this.pendingRequests = {};
  }

  async getUser(userId) {
    // Se l'utente è già in cache, ritornalo
    if (this.cache[userId]) {
      return this.cache[userId];
    }

    // Se c'è già una richiesta in corso, aspetta quella
    if (this.pendingRequests[userId]) {
      return this.pendingRequests[userId];
    }

    // Crea una nuova richiesta e cachala
    this.pendingRequests[userId] = this.fetchUser(userId);

    try {
      const user = await this.pendingRequests[userId];
      this.cache[userId] = user;
      return user;
    } finally {
      // Pulisce la richiesta pending
      delete this.pendingRequests[userId];
    }
  }

  async fetchUser(userId) {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch user ${userId}`);
    }
    return response.json();
  }
}
```

## Debugging di Codice Asincrono

### Stack Trace Preservation

```javascript
// PROBLEMA: Stack trace perso con async/await
async function deepAsyncFunction() {
  await someAsyncOperation();
  throw new Error('Errore in deep function');
}

async function middleFunction() {
  return deepAsyncFunction(); // Stack trace perso qui
}

async function topFunction() {
  try {
    await middleFunction();
  } catch (error) {
    // Error stack non mostra il path completo
    console.error(error.stack);
  }
}

// SOLUZIONE: Error wrapping con stack trace preservation
class AsyncError extends Error {
  constructor(message, originalError, context) {
    super(message);
    this.name = 'AsyncError';
    this.originalError = originalError;
    this.context = context;

    // Preserva lo stack trace originale
    if (originalError && originalError.stack) {
      this.stack = `${this.stack}\nCaused by: ${originalError.stack}`;
    }
  }
}

async function improvedDeepFunction() {
  try {
    await someAsyncOperation();
    throw new Error('Errore in deep function');
  } catch (error) {
    throw new AsyncError('Errore nel processing profondo', error, {
      function: 'deepAsyncFunction',
      userId: 123,
    });
  }
}
```

### Async Performance Monitoring

```javascript
// Utility per monitorare performance di operazioni async
class AsyncProfiler {
  constructor() {
    this.metrics = {};
  }

  async profile(name, asyncFunction) {
    const start = Date.now();
    const startMemory = process.memoryUsage?.()?.heapUsed || 0;

    try {
      const result = await asyncFunction();

      const duration = Date.now() - start;
      const endMemory = process.memoryUsage?.()?.heapUsed || 0;
      const memoryDelta = endMemory - startMemory;

      this.recordMetric(name, {
        duration,
        memoryDelta,
        success: true,
      });

      return result;
    } catch (error) {
      const duration = Date.now() - start;

      this.recordMetric(name, {
        duration,
        success: false,
        error: error.message,
      });

      throw error;
    }
  }

  recordMetric(name, metric) {
    if (!this.metrics[name]) {
      this.metrics[name] = [];
    }

    this.metrics[name].push({
      ...metric,
      timestamp: new Date().toISOString(),
    });
  }

  getReport(name) {
    const metrics = this.metrics[name] || [];
    if (metrics.length === 0) return null;

    const successful = metrics.filter(m => m.success);
    const failed = metrics.filter(m => !m.success);

    const avgDuration =
      successful.reduce((sum, m) => sum + m.duration, 0) / successful.length;
    const maxDuration = Math.max(...metrics.map(m => m.duration));
    const minDuration = Math.min(...metrics.map(m => m.duration));

    return {
      name,
      totalCalls: metrics.length,
      successRate: (successful.length / metrics.length) * 100,
      avgDuration: Math.round(avgDuration),
      maxDuration,
      minDuration,
      recentErrors: failed.slice(-5).map(m => m.error),
    };
  }
}

// Utilizzo del profiler
const profiler = new AsyncProfiler();

async function monitoredApiCall(endpoint) {
  return profiler.profile(`api_call_${endpoint}`, async () => {
    const response = await fetch(endpoint);
    return response.json();
  });
}

// Report periodico delle performance
setInterval(() => {
  console.log('Performance Report:', profiler.getReport('api_call_/api/users'));
}, 60000);
```

## Esercizi Pratici

### Esercizio 1: Sistema di Download con Progress

Implementa un sistema di download che:

- Scarica multiple files in parallelo (massimo 3 contemporaneamente)
- Mostra il progress di ogni download
- Gestisce retry automatico per i download falliti
- Implementa un timeout configurabile
- Fornisce statistiche finali

```javascript
// Il tuo compito: implementa questa classe
class DownloadManager {
  constructor(maxConcurrent = 3, retryAttempts = 3, timeoutMs = 10000) {
    // Implementa il costruttore
  }

  async downloadFiles(urls, progressCallback) {
    // Implementa la logica di download
    // progressCallback dovrebbe essere chiamato con: { url, progress, status }
    // Ritorna un array con i risultati di ogni download
  }

  async downloadFile(url) {
    // Implementa il download di un singolo file con retry e timeout
  }

  getStats() {
    // Ritorna statistiche: { completed, failed, totalTime, averageSpeed }
  }
}

// Test del tuo sistema
const downloader = new DownloadManager(2, 3, 5000);
const urls = [
  'https://httpbin.org/delay/1',
  'https://httpbin.org/delay/2',
  'https://httpbin.org/delay/3',
  'https://httpbin.org/status/500', // Questo fallirà
  'https://httpbin.org/delay/1',
];

downloader
  .downloadFiles(urls, ({ url, progress, status }) => {
    console.log(`${url}: ${progress}% - ${status}`);
  })
  .then(results => {
    console.log('Download completati:', results);
    console.log('Statistiche:', downloader.getStats());
  });
```

### Esercizio 2: Cache Distribuita con TTL e Invalidazione

Crea un sistema di cache avanzato che:

- Supporta TTL (Time To Live) per ogni elemento
- Implementa strategie di invalidazione (LRU)
- Gestisce il warming della cache in background
- Fornisce statistiche di hit/miss
- Supporta cache tags per invalidazione di gruppo

```javascript
// Schema della soluzione da implementare
class AdvancedCache {
  constructor(maxSize = 1000, defaultTTL = 300000) {
    // Implementa inizializzazione
  }

  async get(key, fetchFunction, options = {}) {
    // Implementa logica di get con fetch automatico se mancante
    // options: { ttl, tags, forceRefresh }
  }

  async set(key, value, options = {}) {
    // Implementa logica di set con TTL e tags
    // options: { ttl, tags }
  }

  async invalidate(key) {
    // Invalida una chiave specifica
  }

  async invalidateByTag(tag) {
    // Invalida tutte le chiavi con un determinato tag
  }

  async warmCache(keys) {
    // Pre-carica chiavi in background
  }

  getStats() {
    // Ritorna { hits, misses, hitRate, size, memoryUsage }
  }

  startCleanupJob(intervalMs = 60000) {
    // Avvia job di pulizia automatica per elementi scaduti
  }
}

// Test del sistema
const cache = new AdvancedCache(500, 60000);

async function testCache() {
  // Testa tutte le funzionalità implementate
  await cache.set(
    'user:123',
    { name: 'Mario' },
    { ttl: 30000, tags: ['user', 'profile'] },
  );

  const user = await cache.get(
    'user:124',
    async () => {
      return { name: 'Luigi' }; // Simulate API call
    },
    { ttl: 45000, tags: ['user'] },
  );

  console.log('Cache stats:', cache.getStats());

  // Invalida tutti gli utenti
  await cache.invalidateByTag('user');
}
```

### Esercizio 3: Event Sourcing System

Implementa un sistema di Event Sourcing che:

- Gestisce eventi asincroni in ordine
- Supporta replay di eventi
- Implementa snapshot per performance
- Gestisce conflitti e retry
- Fornisce proiezioni real-time

```javascript
// Schema del sistema da implementare
class EventStore {
  constructor() {
    // Implementa store degli eventi
  }

  async appendEvent(streamId, event, expectedVersion = -1) {
    // Appende un evento al stream con controllo versione
    // Gestisce conflitti di concorrenza
  }

  async getEvents(streamId, fromVersion = 0) {
    // Recupera eventi da una versione specifica
  }

  async createSnapshot(streamId, state, version) {
    // Crea snapshot dello stato per performance
  }

  async getSnapshot(streamId) {
    // Recupera l'ultimo snapshot
  }
}

class EventProcessor {
  constructor(eventStore) {
    this.eventStore = eventStore;
    this.projections = new Map();
    this.handlers = new Map();
  }

  async replayEvents(streamId, fromVersion = 0) {
    // Replay eventi per ricostruire stato
  }

  async processEvent(event) {
    // Processa un singolo evento attraverso tutti gli handlers
  }

  registerHandler(eventType, handler) {
    // Registra handler per tipo evento
  }

  async startProjection(name, projectionHandler) {
    // Avvia proiezione real-time
  }
}

// Test del sistema
const eventStore = new EventStore();
const processor = new EventProcessor(eventStore);

// Implementa handlers per eventi User
processor.registerHandler('UserCreated', async event => {
  console.log('User created:', event.data.name);
});

processor.registerHandler('UserUpdated', async event => {
  console.log('User updated:', event.data.changes);
});

// Test scenario
async function testEventSourcing() {
  const userId = 'user-123';

  await eventStore.appendEvent(userId, {
    type: 'UserCreated',
    data: { name: 'Mario Rossi', email: 'mario@example.com' },
    timestamp: Date.now(),
  });

  await eventStore.appendEvent(userId, {
    type: 'UserUpdated',
    data: { changes: { name: 'Mario Rossi Jr.' } },
    timestamp: Date.now(),
  });

  // Replay per ricostruire stato
  await processor.replayEvents(userId);
}
```

## Appendice: Cheat Sheet e Risorse

### Tabella di Scelta: Quando Usare Cosa

| Scenario                                 | Soluzione Consigliata                 | Perché                                        |
| ---------------------------------------- | ------------------------------------- | --------------------------------------------- |
| Singola operazione asincrona             | `async/await`                         | Sintassi più pulita e leggibile               |
| Multiple operazioni in parallelo         | `Promise.all()`                       | Massima performance, fallisce se una fallisce |
| Multiple operazioni, alcune opzionali    | `Promise.allSettled()`                | Non fallisce se alcune operazioni falliscono  |
| Prima risposta tra multiple fonti        | `Promise.race()`                      | Utile per timeout e fallback                  |
| Processing sequenziale di grandi dataset | `for await...of` con async generators | Efficiente per memoria                        |
| Operazioni con retry logic               | Custom wrapper con try/catch          | Controllo fine della logica di retry          |
| Timeout per operazioni                   | `Promise.race()` con timeout promise  | Prevenire hanging indefinito                  |

### Pattern Comuni: Quick Reference

```javascript
// 1. TIMEOUT PATTERN
const withTimeout = (promise, ms) =>
  Promise.race([
    promise,
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Timeout')), ms),
    ),
  ]);

// 2. RETRY PATTERN
const retry = async (fn, attempts = 3, delay = 1000) => {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (err) {
      if (i === attempts - 1) throw err;
      await new Promise(r => setTimeout(r, delay * Math.pow(2, i)));
    }
  }
};

// 3. DEBOUNCE ASYNC PATTERN
const debounceAsync = (fn, delay) => {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    return new Promise(resolve => {
      timeoutId = setTimeout(() => resolve(fn(...args)), delay);
    });
  };
};

// 4. QUEUE PATTERN
class AsyncQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  async add(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({ task, resolve, reject });
      this.tryNext();
    });
  }

  tryNext() {
    if (this.running >= this.concurrency || this.queue.length === 0) return;

    this.running++;
    const { task, resolve, reject } = this.queue.shift();

    task()
      .then(resolve, reject)
      .finally(() => {
        this.running--;
        this.tryNext();
      });
  }
}
```

### Errori Comuni da Evitare

| ❌ Da Evitare                                    | ✅ Meglio                                   | Motivo                             |
| ------------------------------------------------ | ------------------------------------------- | ---------------------------------- |
| `async` senza `await`                            | Usa `await` o ritorna la Promise            | Inutile overhead                   |
| `await` in loop senza motivo                     | `Promise.all()` per operazioni parallele    | Performance                        |
| Promise constructor per wrappare async functions | Usa direttamente async/await                | Promise constructor è anti-pattern |
| `try/catch` attorno a ogni `await`               | Centralizza error handling                  | Codice più pulito                  |
| Mixing callbacks e Promises                      | Usa solo Promises/async-await               | Consistency                        |
| Non gestire Promise rejection                    | Sempre gestire con `.catch()` o `try/catch` | Evita UnhandledPromiseRejection    |

### Performance Tips

- **Parallelize quando possibile**: Usa `Promise.all()` invece di await sequenziali
- **Batch operations**: Raggruppa operazioni piccole in batch più grandi
- **Implement caching**: Evita operazioni costose ripetute
- **Use streaming**: Per grandi dataset, preferisci streams agli array
- **Monitor memory**: Long-running async operations possono creare memory leaks
- **Set timeouts**: Sempre implementa timeout per operazioni di rete
- **Circuit breaker**: Implementa circuit breaker per servizi esterni instabili

### Debugging Checklist

1. ✅ Tutti i Promise rejection sono gestiti?
2. ✅ Ci sono timeout appropriati per operazioni di rete?
3. ✅ Le operazioni sono parallele quando possibile?
4. ✅ Memory leaks da event listeners non rimossi?
5. ✅ Race conditions in stato condiviso?
6. ✅ Error stack traces sono informativi?
7. ✅ Performance monitoring per operazioni critiche?
