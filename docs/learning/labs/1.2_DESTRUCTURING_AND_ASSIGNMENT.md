# Guida Completa al Destructuring Assignment in JavaScript

Il destructuring assignment rappresenta una delle innovazioni più eleganti e trasformative introdotte in JavaScript moderno (ES6). Questa feature non è semplicemente una sintassi alternativa per accedere alle proprietà di oggetti e array, ma un paradigma completamente nuovo che cambia il modo in cui pensiamo all'estrazione e manipolazione dei dati nelle nostre applicazioni.

Prima di immergerci nella sintassi specifica, è fondamentale comprendere il problema che il destructuring risolve e perché la sua introduzione ha rappresentato un punto di svolta per la produttività degli sviluppatori JavaScript.

## Il Problema Fondamentale: Accesso Verboso ai Dati

Nelle applicazioni JavaScript moderne, lavoriamo costantemente con strutture dati complesse che arrivano da API, database, file di configurazione o vengono create internamente dalla nostra logica applicativa. L'approccio tradizionale per estrarre valori specifici da queste strutture richiedeva una sintassi ripetitiva e verbose che rendeva il codice difficile da leggere e mantenere.

Consideriamo un scenario tipico dove dobbiamo processare dati di un utente che arrivano da un'API esterna. L'approccio pre-ES6 richiedeva di scrivere codice come questo:

```javascript
// Simuliamo dati complessi come quelli che potresti ricevere da un'API
const risposta_utente = {
  dati_personali: {
    nome_completo: 'Marco Rossi',
    data_nascita: '1990-05-15',
    codice_fiscale: 'RSSMRC90E15H501Z',
  },
  contatti: {
    email_primaria: 'marco.rossi@email.com',
    telefono_cellulare: '+39 335 123 4567',
    indirizzo_residenza: {
      via_numero: 'Via Giuseppe Verdi, 42',
      citta: 'Milano',
      cap: '20121',
      provincia: 'MI',
    },
  },
  preferenze_account: {
    tema_interfaccia: 'scuro',
    lingua_preferita: 'it',
    notifiche_attive: true,
  },
};

// Approccio tradizionale: ripetitivo e soggetto a errori
var nome = risposta_utente.dati_personali.nome_completo;
var email = risposta_utente.contatti.email_primaria;
var telefono = risposta_utente.contatti.telefono_cellulare;
var citta = risposta_utente.contatti.indirizzo_residenza.citta;
var cap = risposta_utente.contatti.indirizzo_residenza.cap;
var tema = risposta_utente.preferenze_account.tema_interfaccia;
var lingua = risposta_utente.preferenze_account.lingua_preferita;

// Per utilizzare questi dati, dobbiamo aver scritto 7 righe di codice ripetitivo
console.log('Utente: ' + nome + ', Email: ' + email + ', Città: ' + citta);
```

Questo approccio presenta diversi problemi significativi che vanno oltre la semplice verbosità. Primo, ogni volta che scriviamo `risposta_utente.qualcosa.altro`, rischiamo di commettere errori di battitura che possono essere difficili da individuare durante il debugging. Secondo, se la struttura dei dati cambia anche minimamente, dobbiamo aggiornare ogni singola linea di estrazione dei valori. Terzo, il codice non è auto-documentante: guardando le assegnazioni, non è immediatamente chiaro quali sono le proprietà importanti che stiamo estraendo dall'oggetto.

## La Rivoluzione del Destructuring: Sintassi Dichiarativa

Il destructuring assignment risolve tutti questi problemi introducendo una sintassi che rispecchia la struttura dei dati che stiamo manipolando. Invece di dire al computer "come" estrarre i dati passo dopo passo, diciamo "cosa" vogliamo estrarre, rendendo il codice più dichiarativo e intenzionale.

Riprendiamo l'esempio precedente e vediamo come il destructuring trasforma completamente l'approccio:

```javascript
// Destructuring: sintassi dichiarativa e auto-documentante
const {
  dati_personali: { nome_completo: nome },
  contatti: {
    email_primaria: email,
    telefono_cellulare: telefono,
    indirizzo_residenza: { citta, cap },
  },
  preferenze_account: { tema_interfaccia: tema, lingua_preferita: lingua },
} = risposta_utente;

// Lo stesso risultato, ma con una sintassi che descrive chiaramente
// la struttura dei dati e le nostre intenzioni
console.log(`Utente: ${nome}, Email: ${email}, Città: ${citta}`);
```

La differenza è immediatamente evidente e va ben oltre la riduzione delle linee di codice. Il destructuring crea una "mappa visuale" della struttura dati che stiamo navigando, rendendo il codice auto-documentante. Quando un altro sviluppatore (o il nostro futuro io) legge questo codice, può immediatamente comprendere la forma dei dati e quali proprietà consideriamo importanti.

## Anatomia del Destructuring: Come Funziona Internamente

Per utilizzare efficacemente il destructuring, è importante comprendere come JavaScript interpreta questa sintassi internamente. Quando scriviamo un'espressione di destructuring, il motore JavaScript esegue una serie di operazioni che possiamo concettualizzare come "pattern matching".

Il lato sinistro dell'assegnazione definisce un "pattern" o "template" che descrive la struttura che ci aspettiamo di trovare nel lato destro. JavaScript poi confronta questa struttura aspettata con l'oggetto o array reale, estraendo i valori dalle posizioni corrispondenti.

```javascript
// Quando scriviamo questo destructuring...
const { nome, eta } = persona;

// ...JavaScript internamente esegue qualcosa di concettualmente simile a:
// const nome = persona.nome;
// const eta = persona.eta;
// Ma con controlli aggiuntivi e funzionalità avanzate
```

Questa comprensione del meccanismo interno ci aiuta a capire perché il destructuring è così potente e flessibile. Non stiamo semplicemente "abbreviando" la sintassi tradizionale, ma utilizzando un sistema di pattern matching che può gestire strutture complesse, valori mancanti, rinominazioni e molte altre situazioni avanzate.

## Destructuring degli Oggetti: Dalla Base all'Avanzato

Iniziamo la nostra esplorazione pratica del destructuring partendo dai casi più semplici e costruendo gradualmente verso scenari più complessi e realistici.

### Estrazione Base: I Primi Passi

Il caso più semplice di destructuring degli oggetti coinvolge l'estrazione di proprietà il cui nome coincide con il nome della variabile che vogliamo creare:

```javascript
const studente = {
  nome: 'Alice',
  cognome: 'Bianchi',
  matricola: 'ST001234',
  corso: 'Informatica',
  anno: 2,
  media_voti: 28.5,
};

// Estrazione diretta: i nomi delle variabili corrispondono ai nomi delle proprietà
const { nome, cognome, corso } = studente;

console.log(nome); // 'Alice'
console.log(cognome); // 'Bianchi'
console.log(corso); // 'Informatica'

// Possiamo estrarre tutte le proprietà che vogliamo in una singola operazione
const { matricola, anno, media_voti } = studente;
console.log(`Studente ${matricola}, anno ${anno}, media: ${media_voti}`);
```

È importante notare che l'ordine delle proprietà nel destructuring non deve corrispondere all'ordine nell'oggetto originale. JavaScript abbina le proprietà per nome, non per posizione, il che rende il destructuring molto flessibile:

```javascript
// L'ordine non importa: JavaScript abbina per nome
const { corso, nome, anno } = studente;
// Funziona perfettamente, anche se l'ordine è diverso dall'oggetto originale
```

### Rinominazione Durante l'Estrazione: Chiarezza e Controllo

Una delle caratteristiche più potenti del destructuring è la capacità di rinominare le variabili durante l'estrazione. Questo è particolarmente utile quando lavoriamo con API esterne che utilizzano convenzioni di naming diverse dalle nostre, o quando vogliamo rendere i nomi più descrittivi nel contesto specifico del nostro codice:

```javascript
const configurazione_server = {
  srv_port: 8080,
  srv_host: 'localhost',
  db_name: 'production_db',
  db_user: 'admin',
  max_conn: 100,
  ssl_enabled: true,
};

// Rinominiamo le proprietà per renderle più leggibili nel nostro contesto
const {
  srv_port: porta_server,
  srv_host: indirizzo_host,
  db_name: nome_database,
  db_user: utente_database,
  max_conn: connessioni_massime,
  ssl_enabled: ssl_attivo,
} = configurazione_server;

// Ora abbiamo nomi di variabili molto più descrittivi e comprensibili
console.log(`Server avviato su ${indirizzo_host}:${porta_server}`);
console.log(`Database: ${nome_database}, Utente: ${utente_database}`);
console.log(
  `SSL ${ssl_attivo ? 'attivo' : 'disattivo'}, Max connessioni: ${connessioni_massime}`,
);
```

La sintassi per la rinominazione segue il pattern `{ nome_originale: nuovo_nome }`. Questo ci dà il controllo completo sui nomi delle variabili che creiamo, permettendoci di adattarci a qualsiasi convenzione di naming senza essere vincolati dai nomi utilizzati nei dati sorgente.

### Valori di Default: Gestire l'Incertezza

Nel mondo reale dello sviluppo software, spesso lavoriamo con dati che potrebbero essere incompleti o provenienti da fonti non completamente affidabili. Il destructuring ci permette di gestire elegantemente queste situazioni fornendo valori di default che vengono utilizzati quando una proprietà è `undefined`:

```javascript
const impostazioni_utente = {
  tema: 'chiaro',
  lingua: 'it',
  // Nota: mancano molte impostazioni che potremmo aspettarci
};

// Forniamo valori di default sensati per le proprietà che potrebbero mancare
const {
  tema,
  lingua,
  notifiche = true, // Valore di default se manca
  auto_salvataggio = false, // Valore di default se manca
  timeout_sessione = 3600, // Valore di default se manca
  tema_scuro = false, // Valore di default se manca
} = impostazioni_utente;

console.log(`Tema: ${tema}, Lingua: ${lingua}`);
console.log(`Notifiche: ${notifiche ? 'attive' : 'disattive'}`);
console.log(`Auto-salvataggio: ${auto_salvataggio ? 'attivo' : 'disattivo'}`);
console.log(`Timeout sessione: ${timeout_sessione} secondi`);
```

È fondamentale comprendere che i valori di default vengono utilizzati solo quando la proprietà è esattamente `undefined`. Se la proprietà esiste ma ha un valore falsy come `null`, `false`, `0`, o una stringa vuota `''`, il valore di default non verrà utilizzato:

```javascript
const dati_con_valori_falsy = {
  nome: '', // Stringa vuota
  eta: 0, // Zero
  attivo: false, // Boolean false
  descrizione: null, // Null esplicito
};

const {
  nome = 'Nome Sconosciuto',
  eta = 18,
  attivo = true,
  descrizione = 'Nessuna descrizione',
  campo_mancante = 'Questo userà il default',
} = dati_con_valori_falsy;

console.log(nome); // '' (stringa vuota, NON il default)
console.log(eta); // 0 (NON il default)
console.log(attivo); // false (NON il default)
console.log(descrizione); // null (NON il default)
console.log(campo_mancante); // 'Questo userà il default' (undefined → default)
```

### Combinare Rinominazione e Valori di Default

Una delle caratteristiche più eleganti del destructuring è la capacità di combinare la rinominazione con i valori di default, creando un controllo granulare su come trasformiamo i dati durante l'estrazione:

```javascript
const risposta_api = {
  usr_nm: 'mario.rossi',
  usr_status: 'active',
  // Nota: mancano altri campi che potremmo voler utilizzare
};

// Combiniamo rinominazione e valori di default per massima flessibilità
const {
  usr_nm: nome_utente = 'utente_anonimo',
  usr_email: email_utente = 'nessuna-email@example.com',
  usr_status: stato_utente = 'sconosciuto',
  usr_role: ruolo_utente = 'guest',
  usr_last_login: ultimo_accesso = new Date('2000-01-01'),
} = risposta_api;

console.log(`Utente: ${nome_utente}`);
console.log(`Email: ${email_utente}`); // Userà il default
console.log(`Stato: ${stato_utente}`);
console.log(`Ruolo: ${ruolo_utente}`); // Userà il default
console.log(`Ultimo accesso: ${ultimo_accesso.toISOString()}`); // Userà il default
```

Questa combinazione di rinominazione e valori di default è particolarmente potente quando integriamo sistemi esterni o lavoriamo con API che potrebbero cambiare nel tempo. Ci permette di creare un'interfaccia stabile e prevedibile per i nostri dati, indipendentemente dalle variazioni nella struttura sorgente.

### Destructuring Annidato: Navigare Strutture Complesse

Nel mondo reale, spesso lavoriamo con oggetti profondamente annidati che rappresentano entità complesse come utenti, prodotti, configurazioni o risposte da API. Il destructuring annidato ci permette di navigare queste strutture con una sintassi che riflette visualmente l'organizzazione dei dati:

```javascript
const ordine_ecommerce = {
  id_ordine: 'ORD-2024-001',
  data_creazione: '2024-01-15T10:30:00Z',
  cliente: {
    anagrafica: {
      nome: 'Laura',
      cognome: 'Verdi',
      codice_fiscale: 'VRDLRA85D52H501W',
    },
    contatti: {
      email: 'laura.verdi@email.com',
      telefono: '+39 347 987 6543',
    },
    indirizzo_spedizione: {
      destinatario: 'Laura Verdi',
      via: 'Corso Italia 15',
      citta: 'Torino',
      cap: '10121',
      provincia: 'TO',
      note: 'Suonare al citofono',
    },
  },
  articoli: [
    {
      codice: 'PROD-001',
      nome: 'Laptop Dell XPS 13',
      quantita: 1,
      prezzo_unitario: 1299.99,
      categoria: 'Elettronica',
    },
  ],
  totali: {
    subtotale: 1299.99,
    tasse: 284.0,
    spedizione: 9.99,
    totale_finale: 1593.98,
  },
  pagamento: {
    metodo: 'carta_credito',
    numero_carta_mascherato: '**** **** **** 1234',
    stato: 'completato',
  },
};

// Destructuring annidato per estrarre informazioni specifiche
// Nota come la struttura del destructuring riflette quella dell'oggetto
const {
  id_ordine,
  cliente: {
    anagrafica: { nome: nome_cliente, cognome: cognome_cliente },
    contatti: { email: email_cliente },
    indirizzo_spedizione: {
      citta: citta_spedizione,
      cap: cap_spedizione,
      note: note_spedizione = 'Nessuna nota speciale',
    },
  },
  totali: { totale_finale, spedizione: costo_spedizione },
  pagamento: {
    stato: stato_pagamento,
    numero_carta_mascherato: carta_mascherata,
  },
} = ordine_ecommerce;

// Ora possiamo utilizzare tutte queste informazioni con nomi chiari
console.log(`Ordine ${id_ordine} per ${nome_cliente} ${cognome_cliente}`);
console.log(`Email cliente: ${email_cliente}`);
console.log(`Spedizione a ${citta_spedizione} (${cap_spedizione})`);
console.log(`Note spedizione: ${note_spedizione}`);
console.log(`Totale: €${totale_finale} (spedizione: €${costo_spedizione})`);
console.log(`Pagamento: ${stato_pagamento} con carta ${carta_mascherata}`);
```

È importante comprendere un aspetto fondamentale del destructuring annidato: quando estraiamo proprietà da oggetti annidati, non creiamo automaticamente variabili per i livelli intermedi. Nell'esempio sopra, non abbiamo variabili chiamate `cliente`, `anagrafica`, `contatti`, `indirizzo_spedizione`, `totali` o `pagamento`. Abbiamo solo le variabili finali che abbiamo esplicitamente estratto.

Se avessimo bisogno anche degli oggetti intermedi, dovremmo estrarli esplicitamente:

```javascript
// Se vogliamo sia l'oggetto completo che alcune proprietà specifiche
const {
  cliente, // L'intero oggetto cliente
  cliente: {
    anagrafica: { nome: nome_cliente }, // E anche il nome specifico
  },
} = ordine_ecommerce;

console.log(cliente); // L'oggetto completo
console.log(nome_cliente); // 'Laura'
```

## Destructuring degli Array: Posizione e Ordine

Mentre il destructuring degli oggetti si basa sui nomi delle proprietà, il destructuring degli array si basa sulla posizione degli elementi. Questo lo rende particolarmente utile quando lavoriamo con sequenze di dati dove l'ordine ha un significato specifico.

### Estrazione Base da Array

Il destructuring degli array utilizza le parentesi quadre e assegna variabili basandosi sulla posizione:

```javascript
const coordinate_gps = [45.4642, 9.19, 120]; // Latitudine, Longitudine, Altitudine

// Estrazione per posizione
const [latitudine, longitudine, altitudine] = coordinate_gps;

console.log(`Posizione: ${latitudine}°N, ${longitudine}°E`);
console.log(`Altitudine: ${altitudine}m sul livello del mare`);

// Esempio con dati di una funzione che restituisce multiple valori
function calcolaStatistiche(numeri) {
  const somma = numeri.reduce((acc, num) => acc + num, 0);
  const media = somma / numeri.length;
  const minimo = Math.min(...numeri);
  const massimo = Math.max(...numeri);

  return [somma, media, minimo, massimo]; // Restituisce un array
}

const dati = [10, 20, 30, 40, 50];
const [somma, media, minimo, massimo] = calcolaStatistiche(dati);

console.log(`Somma: ${somma}, Media: ${media}`);
console.log(`Range: da ${minimo} a ${massimo}`);
```

### Saltare Elementi: Destructuring Selettivo

Una caratteristica interessante del destructuring degli array è la possibilità di "saltare" elementi che non ci interessano usando virgole senza nomi di variabili:

```javascript
const risultati_gara = [
  'Mario Rossi',
  'Laura Bianchi',
  'Paolo Verdi',
  'Anna Neri',
  'Luca Gialli',
];

// Vogliamo solo il primo e il terzo classificato
const [primo, , terzo] = risultati_gara;

console.log(`Vincitore: ${primo}`);
console.log(`Terzo posto: ${terzo}`);

// Possiamo saltare più elementi consecutivi
const [vincitore, , , quarto, quinto] = risultati_gara;

console.log(
  `Podio: ${vincitore} (primo), ${quarto} (quarto), ${quinto} (quinto)`,
);
```

Questa tecnica è particolarmente utile quando lavoriamo con API che restituiscono array con molti elementi, ma siamo interessati solo ad alcuni valori specifici in posizioni note.

### Rest Parameter: Catturare gli Elementi Rimanenti

Il rest parameter (operatore `...`) ci permette di catturare tutti gli elementi rimanenti di un array in una nuova variabile array:

```javascript
const classifica_finale = [
  'Team Alpha',
  'Team Beta',
  'Team Gamma',
  'Team Delta',
  'Team Epsilon',
  'Team Zeta',
];

// Separare i primi tre dai rimanenti
const [primo_posto, secondo_posto, terzo_posto, ...altri_team] =
  classifica_finale;

console.log('Podio:');
console.log(`🥇 ${primo_posto}`);
console.log(`🥈 ${secondo_posto}`);
console.log(`🥉 ${terzo_posto}`);

console.log('\nAltri partecipanti:');
altri_team.forEach((team, indice) => {
  console.log(`${indice + 4}° posto: ${team}`);
});

// Il rest parameter può essere usato per separare head e tail
const numeri = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const [primo_numero, ...numeri_rimanenti] = numeri;

console.log(`Primo numero: ${primo_numero}`);
console.log(`Numeri rimanenti: [${numeri_rimanenti.join(', ')}]`);
```

È importante ricordare che il rest parameter deve sempre essere l'ultimo elemento nel destructuring pattern:

```javascript
// ✅ Corretto: rest parameter alla fine
const [a, b, ...resto] = array;

// ❌ Sbagliato: rest parameter non può essere seguito da altri elementi
// const [a, ...resto, b] = array; // SyntaxError!
```

### Valori di Default negli Array

Come con gli oggetti, possiamo fornire valori di default per elementi dell'array che potrebbero essere `undefined`:

```javascript
const configurazione_colori = ['#FF0000', '#00FF00']; // Rosso e Verde, manca il Blu

// Forniamo un valore di default per il colore blu
const [rosso, verde, blu = '#0000FF'] = configurazione_colori;

console.log(`Rosso: ${rosso}`); // '#FF0000'
console.log(`Verde: ${verde}`); // '#00FF00'
console.log(`Blu: ${blu}`); // '#0000FF' (valore di default)

// Esempio pratico: parsing di una stringa di configurazione
function parseConfigurazioneDatabase(stringa_config) {
  // La stringa potrebbe essere "localhost:5432:mydb" o solo "localhost:5432"
  const parti = stringa_config.split(':');

  const [host, porta = '5432', database = 'postgres'] = parti;

  return {
    host: host,
    porta: parseInt(porta),
    database: database,
  };
}

console.log(parseConfigurazioneDatabase('localhost:3306:webapp'));
// { host: 'localhost', porta: 3306, database: 'webapp' }

console.log(parseConfigurazioneDatabase('localhost:5432'));
// { host: 'localhost', porta: 5432, database: 'postgres' }

console.log(parseConfigurazioneDatabase('localhost'));
// { host: 'localhost', porta: 5432, database: 'postgres' }
```

### Swapping di Variabili: Una Tecnica Elegante

Una delle applicazioni più eleganti del destructuring degli array è lo scambio di valori tra variabili senza bisogno di una variabile temporanea:

```javascript
let a = 10;
let b = 20;

console.log(`Prima dello scambio: a = ${a}, b = ${b}`);

// Scambio elegante usando destructuring
[a, b] = [b, a];

console.log(`Dopo lo scambio: a = ${a}, b = ${b}`);

// Questa tecnica funziona con qualsiasi numero di variabili
let x = 'primo';
let y = 'secondo';
let z = 'terzo';

console.log(`Prima: x = ${x}, y = ${y}, z = ${z}`);

// Rotazione circolare
[x, y, z] = [z, x, y];

console.log(`Dopo rotazione: x = ${x}, y = ${y}, z = ${z}`);

// Esempio pratico: algoritmo di ordinamento
function bubbleSortStep(array) {
  const arr = [...array]; // Copia per non modificare l'originale
  let scambi_effettuati = false;

  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] > arr[i + 1]) {
      // Scambio elegante senza variabile temporanea
      [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
      scambi_effettuati = true;
    }
  }

  return { array_ordinato: arr, ci_sono_stati_scambi: scambi_effettuati };
}

const numeri_disordinati = [64, 34, 25, 12, 22, 11, 90];
console.log('Array originale:', numeri_disordinati);

let risultato = bubbleSortStep(numeri_disordinati);
console.log('Dopo un passo:', risultato.array_ordinato);
```

## Pattern Avanzati e Applicazioni nel Mondo Reale

Ora che abbiamo costruito una solida comprensione delle basi del destructuring, esploriamo alcuni pattern più sofisticati che incontrerai frequentemente nello sviluppo di applicazioni JavaScript professionali.

### Destructuring nei Parametri di Funzione

Uno degli usi più potenti e comuni del destructuring è nei parametri delle funzioni. Questo pattern è particolarmente utile quando dobbiamo passare molte opzioni o configurazioni a una funzione, trasformando quella che potrebbe essere una lunga lista di parametri in un singolo oggetto auto-documentante:

```javascript
// Approccio tradizionale: molti parametri difficili da ricordare
function creaUtenteTradizonale(
  nome,
  cognome,
  email,
  età,
  ruolo,
  attivo,
  dataRegistrazione,
  preferenze,
) {
  // È difficile ricordare l'ordine e tutti i parametri sono obbligatori
  return {
    nome,
    cognome,
    email,
    età,
    ruolo,
    attivo,
    dataRegistrazione,
    preferenze,
  };
}

// Approccio con destructuring: più flessibile e auto-documentante
function creaUtente({
  nome,
  cognome,
  email,
  età = 18, // Valore di default
  ruolo = 'utente_standard', // Valore di default
  attivo = true, // Valore di default
  data_registrazione = new Date(),
  preferenze = {},
}) {
  // I parametri sono auto-documentanti e hanno valori di default sensati
  return {
    nome,
    cognome,
    email,
    età,
    ruolo,
    attivo,
    data_registrazione,
    preferenze,
    id: Math.random().toString(36).substr(2, 9), // ID generato automaticamente
  };
}

// L'utilizzo è molto più chiaro e flessibile
const nuovo_utente = creaUtente({
  nome: 'Marco',
  cognome: 'Bianchi',
  email: 'marco.bianchi@email.com',
  ruolo: 'amministratore',
  // età, attivo, data_registrazione e preferenze useranno i valori di default
});

console.log(nuovo_utente);

// Possiamo anche fornire solo i parametri essenziali
const utente_base = creaUtente({
  nome: 'Anna',
  cognome: 'Rossi',
  email: 'anna.rossi@email.com',
});

console.log(utente_base);
```

Questo pattern è particolarmente potente perché:

- I parametri sono auto-documentanti
- L'ordine non importa
- Possiamo fornire valori di default ragionevoli
- È facile aggiungere nuovi parametri senza rompere il codice esistente
- Il codice chiamante è molto più leggibile

### Destructuring con API e Risposte HTTP

Nel mondo dello sviluppo web moderno, spesso lavoriamo con dati provenienti da API REST, GraphQL o altri servizi web. Questi dati hanno spesso strutture complesse e annidiate, e il destructuring ci permette di estrarre facilmente le informazioni che ci servono:

```javascript
// Simuliamo una risposta tipica da un'API di e-commerce
async function simulaChiamataAPI() {
  return {
    status: 200,
    message: 'Successo',
    data: {
      utente: {
        id: 12345,
        profilo: {
          nome_completo: 'Elena Verdi',
          avatar_url: 'https://example.com/avatars/12345.jpg',
          biografia:
            'Sviluppatrice full-stack appassionata di tecnologie moderne',
        },
        impostazioni: {
          tema: 'scuro',
          lingua: 'it',
          notifiche: {
            email: true,
            push: false,
            sms: true,
          },
          privacy: {
            profilo_pubblico: false,
            mostra_email: false,
            indicizzazione_motori: false,
          },
        },
        statistiche: {
          ordini_totali: 47,
          spesa_totale: 2847.5,
          prodotti_preferiti: 12,
          recensioni_scritte: 8,
        },
      },
      metadata: {
        tempo_risposta: 0.045,
        versione_api: 'v2.1',
        server: 'eu-west-1',
      },
    },
  };
}

async function gestisciProfiloUtente() {
  try {
    const risposta = await simulaChiamataAPI();

    // Destructuring complesso per estrarre solo i dati che ci servono
    const {
      status,
      data: {
        utente: {
          id: id_utente,
          profilo: {
            nome_completo: nome_utente,
            avatar_url: url_avatar,
            biografia = 'Nessuna biografia disponibile',
          },
          impostazioni: {
            tema,
            lingua,
            notifiche: { email: notifiche_email, push: notifiche_push },
            privacy: { profilo_pubblico, mostra_email },
          },
          statistiche: { ordini_totali, spesa_totale, recensioni_scritte },
        },
        metadata: { tempo_risposta, versione_api },
      },
    } = risposta;

    // Ora possiamo utilizzare tutte queste informazioni con nomi chiari
    if (status === 200) {
      console.log(`=== Profilo di ${nome_utente} (ID: ${id_utente}) ===`);
      console.log(`Avatar: ${url_avatar}`);
      console.log(`Biografia: ${biografia}`);
      console.log(`\nImpostazioni:`);
      console.log(`- Tema: ${tema}`);
      console.log(`- Lingua: ${lingua}`);
      console.log(
        `- Notifiche email: ${notifiche_email ? 'attive' : 'disattive'}`,
      );
      console.log(
        `- Notifiche push: ${notifiche_push ? 'attive' : 'disattive'}`,
      );
      console.log(`- Profilo pubblico: ${profilo_pubblico ? 'sì' : 'no'}`);
      console.log(`\nStatistiche:`);
      console.log(`- Ordini effettuati: ${ordini_totali}`);
      console.log(`- Spesa totale: €${spesa_totale}`);
      console.log(`- Recensioni scritte: ${recensioni_scritte}`);
      console.log(
        `\nAPI Info: versione ${versione_api}, tempo risposta: ${tempo_risposta}s`,
      );
    }

    return {
      id_utente,
      nome_utente,
      tema,
      lingua,
      ordini_totali,
      spesa_totale,
    };
  } catch (errore) {
    console.error('Errore nel caricamento del profilo:', errore);
    return null;
  }
}

// Utilizziamo la funzione
gestisciProfiloUtente().then(profilo => {
  if (profilo) {
    console.log('\nDati estratti per utilizzo interno:', profilo);
  }
});
```

### Destructuring Dinamico e Computed Property Names

Per scenari più avanzati, JavaScript ci permette di utilizzare nomi di proprietà calcolati nel destructuring. Questo è utile quando i nomi delle proprietà sono determinati dinamicamente a runtime:

```javascript
const dati_sensori = {
  temperatura_01: 23.5,
  temperatura_02: 24.1,
  umidita_01: 45.2,
  umidita_02: 47.8,
  pressione_01: 1013.25,
  pressione_02: 1014.1,
};

function estraiDatiSensore(dati, tipo_sensore, numero_sensore) {
  // Costruiamo dinamicamente il nome della proprietà
  const nome_proprieta = `${tipo_sensore}_${numero_sensore.toString().padStart(2, '0')}`;

  // Destructuring con nome calcolato
  const { [nome_proprieta]: valore_sensore } = dati;

  return {
    tipo: tipo_sensore,
    numero: numero_sensore,
    valore: valore_sensore || 'Sensore non trovato',
  };
}

console.log(estraiDatiSensore(dati_sensori, 'temperatura', 1));
// { tipo: 'temperatura', numero: 1, valore: 23.5 }

console.log(estraiDatiSensore(dati_sensori, 'umidita', 2));
// { tipo: 'umidita', numero: 2, valore: 47.8 }

console.log(estraiDatiSensore(dati_sensori, 'velocita', 1));
// { tipo: 'velocita', numero: 1, valore: 'Sensore non trovato' }

// Esempio più complesso: estrazione multipla dinamica
function estraiMultipliSensori(dati, configurazioni) {
  const risultati = {};

  configurazioni.forEach(({ tipo, numero, alias }) => {
    const nome_proprieta = `${tipo}_${numero.toString().padStart(2, '0')}`;
    const { [nome_proprieta]: valore } = dati;
    risultati[alias] = valore !== undefined ? valore : null;
  });

  return risultati;
}

const configurazioni_sensori = [
  { tipo: 'temperatura', numero: 1, alias: 'temp_ingresso' },
  { tipo: 'temperatura', numero: 2, alias: 'temp_uscita' },
  { tipo: 'umidita', numero: 1, alias: 'umidita_ambiente' },
  { tipo: 'pressione', numero: 1, alias: 'pressione_atmosferica' },
];

const letture_sensori = estraiMultipliSensori(
  dati_sensori,
  configurazioni_sensori,
);
console.log('Letture sensori:', letture_sensori);
```

### Combinare Destructuring con Altre Feature ES6

Il destructuring si combina potentemente con altre caratteristiche moderne di JavaScript, creando pattern di codice molto espressivi:

```javascript
// Combinazione con template literals, arrow functions, e spread operator
const prodotti = [
  {
    id: 1,
    nome: 'Laptop Dell',
    prezzo: 899.99,
    categoria: 'Elettronica',
    specifiche: { ram: '16GB', storage: '512GB SSD', cpu: 'Intel i7' },
  },
  {
    id: 2,
    nome: 'Mouse Wireless',
    prezzo: 29.99,
    categoria: 'Accessori',
    specifiche: { dpi: '1600', batteria: 'Ricaricabile', connessione: 'USB-C' },
  },
  {
    id: 3,
    nome: 'Monitor 4K',
    prezzo: 349.99,
    categoria: 'Display',
    specifiche: {
      risoluzione: '3840x2160',
      dimensioni: '27 pollici',
      refresh: '60Hz',
    },
  },
];

// Destructuring nelle arrow functions per processamento dati
const prodotti_formattati = prodotti
  .filter(
    ({ categoria }) => categoria === 'Elettronica' || categoria === 'Display',
  )
  .map(
    ({
      nome,
      prezzo,
      specifiche: { risoluzione, dimensioni, ram, storage },
    }) => ({
      nome,
      prezzo_formattato: `€${prezzo.toFixed(2)}`,
      descrizione: risoluzione
        ? `${nome} - ${dimensioni} (${risoluzione})`
        : `${nome} - ${ram}, ${storage}`,
    }),
  )
  .sort((a, b) =>
    b.prezzo_formattato.localeCompare(a.prezzo_formattato, undefined, {
      numeric: true,
    }),
  );

console.log('Prodotti elettronica e display:', prodotti_formattati);

// Destructuring con rest parameters per separazione dati
const configurazione_completa = {
  ambiente: 'produzione',
  debug: false,
  database: {
    host: 'prod-db.company.com',
    porta: 5432,
    nome: 'webapp_prod',
  },
  cache: {
    tipo: 'redis',
    host: 'cache.company.com',
    ttl: 3600,
  },
  api_keys: {
    payment_gateway: 'pk_live_abc123',
    email_service: 'key_def456',
    analytics: 'ga_ghi789',
  },
  feature_flags: {
    nuova_ui: true,
    checkout_rapido: true,
    raccomandazioni_ai: false,
  },
};

// Separare configurazione sensibile da quella pubblica
const {
  api_keys, // Dati sensibili
  ...config_pubblica // Tutto il resto
} = configurazione_completa;

console.log('Configurazione pubblica:', config_pubblica);
console.log('API Keys (sensibili):', Object.keys(api_keys));

// Destructuring con spread per creazione di oggetti derivati
const { database, cache, ...altre_config } = config_pubblica;
const configurazione_frontend = {
  ...altre_config,
  database: { host: database.host }, // Solo host pubblico
  cache_enabled: Boolean(cache), // Solo flag booleano
};

console.log('Config per frontend:', configurazione_frontend);
```

## Edge Cases e Situazioni Speciali

Come ogni caratteristica potente del linguaggio, il destructuring ha alcuni comportamenti speciali e edge cases che è importante comprendere per evitare bug sottili e scrivere codice più robusto.

### Gestione di Valori Null e Undefined

Uno degli errori più comuni quando si impara il destructuring riguarda il tentativo di destrutturare valori `null` o `undefined`. È fondamentale comprendere come gestire queste situazioni:

```javascript
// Situazioni pericolose che causano errori
const dati_nulli = null;
const dati_undefined = undefined;

try {
  // ❌ Questo genererà un TypeError
  const { proprieta } = dati_nulli;
} catch (errore) {
  console.log('Errore con null:', errore.message);
  // TypeError: Cannot destructure property 'proprieta' of 'null' as it is null.
}

try {
  // ❌ Anche questo genererà un TypeError
  const { proprieta } = dati_undefined;
} catch (errore) {
  console.log('Errore con undefined:', errore.message);
  // TypeError: Cannot destructure property 'proprieta' of 'undefined' as it is undefined.
}

// ✅ Soluzioni sicure per gestire valori potenzialmente nulli
function gestisciDatiIncertiTradizionale(dati) {
  // Approccio tradizionale: controllo esplicito
  if (dati != null) {
    // Controlla sia null che undefined
    const { nome, eta } = dati;
    return { nome, eta };
  } else {
    return { nome: 'Sconosciuto', eta: 0 };
  }
}

function gestisciDatiIncertiConDefault(dati) {
  // Approccio con default dell'oggetto intero
  const { nome = 'Sconosciuto', eta = 0 } = dati || {};
  return { nome, eta };
}

function gestisciDatiIncertiConNullish(dati) {
  // Approccio moderno con nullish coalescing
  const { nome = 'Sconosciuto', eta = 0 } = dati ?? {};
  return { nome, eta };
}

// Test delle diverse strategie
console.log('Con null:', gestisciDatiIncertiConDefault(null));
console.log('Con undefined:', gestisciDatiIncertiConDefault(undefined));
console.log(
  'Con oggetto valido:',
  gestisciDatiIncertiConDefault({ nome: 'Mario', eta: 30 }),
);
console.log(
  'Con oggetto parziale:',
  gestisciDatiIncertiConDefault({ nome: 'Anna' }),
);
```

### Comportamento con Valori Falsy

È importante distinguere tra `undefined` e altri valori falsy. I valori di default nel destructuring si attivano solo per `undefined`, non per altri valori falsy come `null`, `false`, `0`, `''`:

```javascript
const oggetto_con_valori_falsy = {
  stringa_vuota: '',
  zero: 0,
  false_esplicito: false,
  null_esplicito: null,
  // undefined_esplicito: undefined, (commentato = proprietà mancante)
};

const {
  stringa_vuota = 'Default String',
  zero = 42,
  false_esplicito = true,
  null_esplicito = 'Default Null',
  undefined_esplicito = 'Default Undefined',
  proprieta_inesistente = 'Default Inesistente',
} = oggetto_con_valori_falsy;

console.log('Risultati del destructuring con valori falsy:');
console.log(`stringa_vuota: "${stringa_vuota}"`); // "" (NON il default)
console.log(`zero: ${zero}`); // 0 (NON il default)
console.log(`false_esplicito: ${false_esplicito}`); // false (NON il default)
console.log(`null_esplicito: ${null_esplicito}`); // null (NON il default)
console.log(`undefined_esplicito: ${undefined_esplicito}`); // "Default Undefined" (USA il default)
console.log(`proprieta_inesistente: ${proprieta_inesistente}`); // "Default Inesistente" (USA il default)

// Se vuoi gestire anche altri valori falsy, devi farlo esplicitamente
function gestisciTuttiIValoriFalsy(dati) {
  const { nome, eta, attivo } = dati || {};

  return {
    nome: nome || 'Nome Sconosciuto', // Gestisce '', null, undefined
    eta: eta ?? 0, // Gestisce solo null e undefined
    attivo: attivo !== undefined ? attivo : true, // Gestisce esplicitamente undefined
  };
}

console.log(gestisciTuttiIValoriFalsy({ nome: '', eta: 0, attivo: false }));
// { nome: 'Nome Sconosciuto', eta: 0, attivo: false }
```

### Destructuring e Scope delle Variabili

Il destructuring rispetta completamente le regole di scope di `const`, `let`, e `var`. Questo può creare situazioni interessanti e potenziali insidie:

```javascript
// Comportamento con diversi tipi di dichiarazione
function dimostrazioneScope() {
  const dati = { a: 1, b: 2, c: 3 };

  // Le variabili destructured seguono le regole del loro tipo di dichiarazione
  {
    const { a, b } = dati; // Solo disponibili in questo blocco
    console.log(`Nel blocco: a = ${a}, b = ${b}`);
  }

  // console.log(a); // ❌ ReferenceError: a is not defined

  {
    var { c } = dati; // var è hoisted e disponibile nella funzione
  }

  console.log(`Fuori dal blocco: c = ${c}`); // ✅ Funziona grazie a var

  // Let permette re-assegnazione ma non re-dichiarazione
  let { a: valore_a } = dati;
  console.log(`Prima: valore_a = ${valore_a}`);

  ({ a: valore_a } = { a: 999 }); // Re-assegnazione (nota le parentesi!)
  console.log(`Dopo: valore_a = ${valore_a}`);
}

dimostrazioneScope();

// Attenzione alle parentesi quando si fa destructuring senza dichiarazione
let x, y;
const punto = { x: 10, y: 20 };

// ❌ Questo non funziona - JavaScript pensa che { sia l'inizio di un blocco
// { x, y } = punto; // SyntaxError

// ✅ Le parentesi risolvono l'ambiguità
({ x, y } = punto);
console.log(`Coordinate: (${x}, ${y})`);
```

### Destructuring Misto: Oggetti e Array Insieme

In situazioni complesse, potresti trovarti a lavorare con strutture che combinano oggetti e array. Il destructuring può gestire elegantemente questi scenari:

```javascript
const dati_complessi = {
  utente: {
    id: 123,
    nome: 'Laura Bianchi',
  },
  ordini: [
    { id: 'ORD-001', totale: 299.99, articoli: ['Libro', 'Penna'] },
    { id: 'ORD-002', totale: 89.5, articoli: ['Quaderno', 'Matita', 'Gomma'] },
    { id: 'ORD-003', totale: 149.99, articoli: ['Zaino'] },
  ],
  statistiche: {
    ordini_totali: 3,
    spesa_totale: 539.48,
    prodotti_acquistati: [
      'Libro',
      'Penna',
      'Quaderno',
      'Matita',
      'Gomma',
      'Zaino',
    ],
  },
};

// Destructuring misto: navighiamo oggetti e array insieme
const {
  utente: { nome: nome_utente },
  ordini: [
    primo_ordine,
    {
      id: id_secondo_ordine,
      articoli: [primo_articolo_secondo_ordine],
    },
    ...altri_ordini
  ],
  statistiche: {
    spesa_totale,
    prodotti_acquistati: [primo_prodotto, secondo_prodotto, ...altri_prodotti],
  },
} = dati_complessi;

console.log(`Cliente: ${nome_utente}`);
console.log(`Primo ordine completo:`, primo_ordine);
console.log(`ID secondo ordine: ${id_secondo_ordine}`);
console.log(
  `Primo articolo del secondo ordine: ${primo_articolo_secondo_ordine}`,
);
console.log(`Altri ordini:`, altri_ordini);
console.log(`Spesa totale: €${spesa_totale}`);
console.log(`Primi due prodotti: ${primo_prodotto}, ${secondo_prodotto}`);
console.log(`Altri prodotti:`, altri_prodotti);

// Esempio pratico: analisi dati di vendita
function analizzaVendite(dati_vendite) {
  const risultati_analisi = [];

  dati_vendite.forEach(
    ({
      venditore: { nome, regione },
      vendite: [vendita_migliore, ...altre_vendite],
    }) => {
      const { prodotto, valore, data: data_vendita } = vendita_migliore;

      const totale_altre_vendite = altre_vendite.reduce(
        (sum, { valore }) => sum + valore,
        0,
      );

      risultati_analisi.push({
        venditore: nome,
        regione,
        migliore_vendita: { prodotto, valore, data_vendita },
        altre_vendite_totale: totale_altre_vendite,
        performance: valore > totale_altre_vendite ? 'Eccellente' : 'Buona',
      });
    },
  );

  return risultati_analisi;
}

const dati_vendite = [
  {
    venditore: { nome: 'Mario Rossi', regione: 'Nord' },
    vendite: [
      { prodotto: 'Laptop Pro', valore: 1999.99, data: '2024-01-15' },
      { prodotto: 'Mouse', valore: 29.99, data: '2024-01-10' },
      { prodotto: 'Tastiera', valore: 79.99, data: '2024-01-12' },
    ],
  },
];

console.log('Analisi vendite:', analizzaVendite(dati_vendite));
```

## Esercizi Pratici per Consolidare l'Apprendimento

Per padroneggiare veramente il destructuring assignment, è essenziale applicare i concetti in situazioni pratiche e realistiche. I seguenti esercizi sono progettati per sfidare la tua comprensione a diversi livelli e per coprire scenari che incontrerai frequentemente nello sviluppo professionale.

### Esercizio 1 (Livello Base): Normalizzazione Dati Utente

In questo esercizio, simulerai l'integrazione con diversi sistemi esterni che forniscono dati utente in formati leggermente diversi. Il tuo compito è creare una funzione che normalizza questi dati in un formato consistente utilizzando il destructuring.

```javascript
/**
 * Esercizio 1: Processore di Dati Utente
 *
 * Hai ricevuto dati utente da tre sistemi diversi con formati leggermente diversi.
 * Crea una funzione che normalizza questi dati usando il destructuring avanzato.
 *
 * Obiettivi di apprendimento:
 * - Destructuring con rinominazione
 * - Valori di default
 * - Gestione di strutture diverse
 */

// Dati di esempio con strutture diverse provenienti da sistemi esterni
const utenti_sistema_a = [
  {
    personal_info: {
      full_name: 'Mario Rossi',
      birth_year: 1985,
    },
    contact: {
      email_address: 'mario.rossi@email.com',
      phone_number: '+39 123 456 7890',
    },
    location: {
      street_address: 'Via Roma 123',
      city_name: 'Milano',
      postal_code: '20100',
    },
  },
];

const utenti_sistema_b = [
  {
    nome_cognome: 'Laura Bianchi',
    anni: 28,
    email: 'laura.bianchi@test.com',
    residenza: {
      citta: 'Roma',
      cap: '00100',
    },
  },
];

const utenti_sistema_c = [
  {
    anagrafica: {
      first_name: 'Paolo',
      last_name: 'Verdi',
      age_years: 32,
    },
    contatti: {
      primary_email: 'paolo.verdi@example.com',
    },
    indirizzo: {
      municipality: 'Napoli',
    },
  },
];

function normalizzaUtente(utente, sistema_origine) {
  /**
   * Il tuo compito: implementa questa funzione usando il destructuring per:
   *
   * 1. Estrarre e normalizzare i seguenti campi:
   *    - Nome completo (potrebbe essere full_name, nome_cognome, o first_name + last_name)
   *    - Età o anno di nascita (calcola l'età se hai l'anno di nascita)
   *    - Email (potrebbe essere email_address, email, o primary_email)
   *    - Città (potrebbe essere city_name, citta, o municipality)
   *    - Codice postale (potrebbe mancare, usa 'N/A' come default)
   *    - Telefono (potrebbe mancare, usa 'Non fornito' come default)
   *
   * 2. Restituire sempre un oggetto con questa struttura:
   *    {
   *      nome_completo: string,
   *      eta: number,
   *      email: string,
   *      citta: string,
   *      cap: string,
   *      telefono: string,
   *      sistema_origine: string
   *    }
   *
   * Suggerimenti:
   * - Usa destructuring annidato per navigare le strutture complesse
   * - Sfrutta la rinominazione per uniformare i nomi delle variabili
   * - Usa valori di default per gestire i campi mancanti
   * - Per l'età, se hai birth_year, calcola: new Date().getFullYear() - birth_year
   */
  // Implementa qui la tua soluzione...
}

// Test della tua implementazione
function testNormalizzazione() {
  console.log('=== Test Normalizzazione Utenti ===\n');

  const utente_a = normalizzaUtente(utenti_sistema_a[0], 'Sistema A');
  console.log('Utente Sistema A:', utente_a);

  const utente_b = normalizzaUtente(utenti_sistema_b[0], 'Sistema B');
  console.log('Utente Sistema B:', utente_b);

  const utente_c = normalizzaUtente(utenti_sistema_c[0], 'Sistema C');
  console.log('Utente Sistema C:', utente_c);

  // Verifica che tutti gli oggetti abbiano la stessa struttura
  const tutti_utenti = [utente_a, utente_b, utente_c];
  const proprietà_richieste = [
    'nome_completo',
    'eta',
    'email',
    'citta',
    'cap',
    'telefono',
    'sistema_origine',
  ];

  tutti_utenti.forEach((utente, indice) => {
    const chiavi_mancanti = proprietà_richieste.filter(
      prop => !(prop in utente),
    );
    if (chiavi_mancanti.length === 0) {
      console.log(`✅ Utente ${indice + 1}: struttura corretta`);
    } else {
      console.log(
        `❌ Utente ${indice + 1}: mancano ${chiavi_mancanti.join(', ')}`,
      );
    }
  });
}

// Esegui il test quando hai implementato la funzione
// testNormalizzazione();
```

### Esercizio 2 (Livello Intermedio): Analizzatore di Log di Sistema

Questo esercizio ti sfiderà a lavorare con strutture dati più complesse e variabili, similmente a quello che potresti incontrare nell'analisi di log di applicazioni reali.

```javascript
/**
 * Esercizio 2: Analizzatore di Log di Sistema
 *
 * Simula l'analisi di log di sistema con strutture complesse e variabili.
 * Dovrai utilizzare destructuring avanzato per estrarre informazioni
 * da diverse tipologie di eventi di log.
 *
 * Obiettivi di apprendimento:
 * - Destructuring condizionale basato sul tipo di log
 * - Gestione di strutture opzionali
 * - Aggregazione di dati estratti
 */

const log_entries = [
  // Log di errore di database
  {
    timestamp: '2024-01-15T10:30:00Z',
    level: 'ERROR',
    category: 'DATABASE',
    message: 'Connection timeout',
    context: {
      operation: 'SELECT',
      table: 'users',
      query_time: 5000,
      error_details: {
        code: 'CONN_TIMEOUT',
        description: 'Database connection timed out after 5000ms',
        stack_trace: ['db.js:45', 'user-service.js:23', 'api.js:12'],
      },
      affected_user: {
        id: 12345,
        session: 'sess_abc123',
      },
    },
  },

  // Log di accesso utente
  {
    timestamp: '2024-01-15T10:31:00Z',
    level: 'INFO',
    category: 'AUTH',
    message: 'User login successful',
    context: {
      user_info: {
        id: 67890,
        username: 'laura.bianchi',
        role: 'admin',
      },
      session_data: {
        session_id: 'sess_def456',
        ip_address: '192.168.1.100',
        user_agent:
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      },
      authentication: {
        method: 'password',
        two_factor: true,
        attempts: 1,
      },
    },
  },

  // Log di performance API
  {
    timestamp: '2024-01-15T10:32:00Z',
    level: 'WARN',
    category: 'PERFORMANCE',
    message: 'Slow API response detected',
    context: {
      endpoint: '/api/v1/products',
      method: 'GET',
      response_time: 2500,
      threshold: 1000,
      request_details: {
        params: { category: 'electronics', limit: 50 },
        headers: { 'user-agent': 'Mobile App v1.2' },
      },
      performance_metrics: {
        db_query_time: 1800,
        cache_hit_rate: 0.15,
        memory_usage: 245,
      },
    },
  },

  // Log di sicurezza
  {
    timestamp: '2024-01-15T10:33:00Z',
    level: 'CRITICAL',
    category: 'SECURITY',
    message: 'Suspicious activity detected',
    context: {
      threat_type: 'brute_force',
      target_resource: '/admin/login',
      source_info: {
        ip_addresses: ['10.0.0.1', '10.0.0.2', '10.0.0.3'],
        country: 'Unknown',
        is_proxy: true,
      },
      attack_details: {
        attempts: 50,
        time_window: 300,
        success_rate: 0.0,
      },
      countermeasures: {
        ip_blocked: true,
        admin_notified: true,
        rate_limit_applied: true,
      },
    },
  },
];

class AnalizzatoreLog {
  constructor() {
    this.statistiche = {
      totale_entries: 0,
      entries_per_livello: {},
      entries_per_categoria: {},
      utenti_coinvolti: new Set(),
      errori_database: 0,
      accessi_utente: 0,
      problemi_performance: 0,
      minacce_sicurezza: 0,
      tempo_risposta_lento: [],
      ip_sospetti: new Set(),
    };
  }

  analizzaEntry(entry) {
    /**
     * Il tuo compito: implementa questo metodo usando destructuring per:
     *
     * 1. Estrarre sempre: timestamp, level, category, message
     *
     * 2. Per categoria DATABASE:
     *    - Estrarre: operation, table, query_time, error_code
     *    - Se presente affected_user.id, aggiungerlo agli utenti_coinvolti
     *    - Incrementare errori_database
     *
     * 3. Per categoria AUTH:
     *    - Estrarre: user_id, username, role, session_id, ip_address
     *    - Aggiungere user_id agli utenti_coinvolti
     *    - Incrementare accessi_utente
     *
     * 4. Per categoria PERFORMANCE:
     *    - Estrarre: endpoint, response_time, threshold, cache_hit_rate
     *    - Se response_time > threshold, aggiungere ai tempo_risposta_lento
     *    - Incrementare problemi_performance
     *
     * 5. Per categoria SECURITY:
     *    - Estrarre: threat_type, attempts, ip_addresses
     *    - Aggiungere tutti gli ip_addresses agli ip_sospetti
     *    - Incrementare minacce_sicurezza
     *
     * 6. Aggiornare sempre:
     *    - totale_entries
     *    - entries_per_livello[level]
     *    - entries_per_categoria[category]
     *
     * Suggerimenti:
     * - Usa destructuring annidato per accedere ai dati nidificati
     * - Gestisci i campi opzionali con valori di default
     * - Usa la rinominazione per rendere più chiare le variabili
     */
    // Implementa qui la tua soluzione...
  }

  processaLog(entries) {
    entries.forEach(entry => this.analizzaEntry(entry));
    return this.ottieniRiassunto();
  }

  ottieniRiassunto() {
    return {
      ...this.statistiche,
      utenti_coinvolti: Array.from(this.statistiche.utenti_coinvolti),
      ip_sospetti: Array.from(this.statistiche.ip_sospetti),
      tempo_medio_risposta_lento:
        this.statistiche.tempo_risposta_lento.length > 0
          ? this.statistiche.tempo_risposta_lento.reduce((a, b) => a + b, 0) /
            this.statistiche.tempo_risposta_lento.length
          : 0,
    };
  }
}

// Test dell'analizzatore
function testAnalizzatoreLog() {
  console.log('=== Test Analizzatore Log ===\n');

  const analizzatore = new AnalizzatoreLog();
  const riassunto = analizzatore.processaLog(log_entries);

  console.log('Riassunto completo:', JSON.stringify(riassunto, null, 2));

  // Verifica che tutti i campi attesi siano presenti
  const campi_richiesti = [
    'totale_entries',
    'entries_per_livello',
    'entries_per_categoria',
    'utenti_coinvolti',
    'errori_database',
    'accessi_utente',
    'problemi_performance',
    'minacce_sicurezza',
  ];

  campi_richiesti.forEach(campo => {
    if (campo in riassunto) {
      console.log(`✅ Campo ${campo}: presente`);
    } else {
      console.log(`❌ Campo ${campo}: mancante`);
    }
  });
}

// Esegui il test quando hai implementato il metodo
// testAnalizzatoreLog();
```

### Esercizio 3 (Livello Avanzato): Sistema di Configurazione Gerarchica

Questo esercizio finale sfida la tua comprensione del destructuring in uno scenario molto realistico: la gestione di configurazioni complesse con ereditarietà e override.

```javascript
/**
 * Esercizio 3: Sistema di Configurazione Gerarchica
 *
 * Crea un sistema avanzato di gestione configurazioni che supporta
 * ereditarietà, override, e merge intelligente usando destructuring.
 *
 * Obiettivi di apprendimento:
 * - Destructuring con rest/spread parameters
 * - Merge ricorsivo di configurazioni
 * - Pattern avanzati di destructuring
 */

const sistema_configurazioni = {
  // Configurazione base (default per tutti gli ambienti)
  base: {
    applicazione: {
      nome: 'MyApp',
      versione: '1.0.0',
      porta: 3000,
      host: '0.0.0.0',
    },
    database: {
      tipo: 'postgresql',
      host: 'localhost',
      porta: 5432,
      nome: 'myapp',
      pool: {
        min: 2,
        max: 10,
        timeout: 30000,
      },
      ssl: {
        abilitato: false,
        certificato: null,
        chiave: null,
      },
    },
    cache: {
      tipo: 'memory',
      ttl: 3600,
      max_size: 100,
    },
    logging: {
      livello: 'info',
      formato: 'json',
      outputs: ['console'],
      rotazione: {
        abilitata: false,
        dimensione_max: '10MB',
        file_max: 5,
      },
    },
    sicurezza: {
      jwt: {
        secret: 'dev-secret',
        expires_in: '24h',
        algoritmo: 'HS256',
      },
      cors: {
        abilitato: true,
        origini: ['*'],
        metodi: ['GET', 'POST', 'PUT', 'DELETE'],
        headers: ['Content-Type', 'Authorization'],
      },
    },
    feature_flags: {
      nuova_ui: false,
      analytics: false,
      notifiche_push: false,
    },
  },

  // Configurazione per sviluppo (estende base)
  sviluppo: {
    applicazione: {
      porta: 3001,
      debug: true,
    },
    database: {
      host: 'localhost',
      nome: 'myapp_dev',
      pool: {
        min: 1,
        max: 5,
      },
    },
    logging: {
      livello: 'debug',
      outputs: ['console', 'file'],
    },
    sicurezza: {
      jwt: {
        secret: 'dev-secret-key',
        expires_in: '7d',
      },
      cors: {
        origini: ['http://localhost:3000', 'http://localhost:8080'],
      },
    },
    feature_flags: {
      nuova_ui: true,
      analytics: true,
    },
  },

  // Configurazione per test (estende base)
  test: {
    applicazione: {
      porta: 3002,
    },
    database: {
      tipo: 'sqlite',
      host: ':memory:',
      nome: 'test.db',
    },
    cache: {
      tipo: 'memory',
      ttl: 60,
    },
    logging: {
      livello: 'error',
      outputs: ['console'],
    },
  },

  // Configurazione per produzione (estende base)
  produzione: {
    applicazione: {
      porta: 80,
      host: '127.0.0.1',
    },
    database: {
      host: 'db.production.com',
      porta: 5432,
      pool: {
        min: 10,
        max: 50,
      },
      ssl: {
        abilitato: true,
        certificato: '/path/to/cert.pem',
        chiave: '/path/to/key.pem',
      },
    },
    cache: {
      tipo: 'redis',
      host: 'cache.production.com',
      porta: 6379,
      ttl: 7200,
      max_size: 1000,
    },
    logging: {
      livello: 'warn',
      outputs: ['file', 'syslog'],
      rotazione: {
        abilitata: true,
        dimensione_max: '100MB',
        file_max: 10,
      },
    },
    sicurezza: {
      jwt: {
        secret: process.env.JWT_SECRET || 'prod-secret-key',
        expires_in: '2h',
      },
      cors: {
        origini: ['https://myapp.com', 'https://admin.myapp.com'],
        headers: ['Content-Type', 'Authorization', 'X-API-Key'],
      },
    },
    feature_flags: {
      nuova_ui: true,
      analytics: true,
      notifiche_push: true,
    },
  },
};

class GestoreConfigurazione {
  constructor(ambiente = 'sviluppo') {
    this.ambiente = ambiente;
    this.configurazione_finale = this.costruisciConfigurazione();
  }

  costruisciConfigurazione() {
    /**
     * Il tuo compito: implementa questo metodo usando destructuring per:
     *
     * 1. Estrarre la configurazione base completa
     * 2. Estrarre la configurazione specifica dell'ambiente
     * 3. Fare merge intelligente dove:
     *    - Le proprietà dell'ambiente sovrascrivono quelle base
     *    - Per oggetti annidati, fai merge ricorsivo (non sostituzione completa)
     *    - Per array, sostituisci completamente con quelli dell'ambiente
     *
     * 4. Restituire la configurazione finale mergata
     *
     * Suggerimenti:
     * - Usa destructuring con rest parameters per separare le configurazioni
     * - Implementa una funzione helper per il merge ricorsivo
     * - Gestisci il caso in cui l'ambiente non esista (usa solo base)
     */
    // Implementa qui la tua soluzione...
  }

  ottieniConfigurazioneServer() {
    /**
     * Usa destructuring per estrarre e restituire solo la configurazione
     * del server (applicazione) con nomi di variabili più descrittivi
     *
     * Restituisci un oggetto con:
     * - nome_app, versione_app, porta_server, host_server, debug_abilitato
     */
    // Implementa qui...
  }

  ottieniStringaConnessioneDB() {
    /**
     * Usa destructuring per costruire una stringa di connessione database
     * Formato atteso: "tipo://host:porta/nome" o ":memory:" per SQLite
     */
    // Implementa qui...
  }

  ottieniConfigurazioneLogging() {
    /**
     * Usa destructuring per estrarre la configurazione di logging
     * e determinare se la rotazione è configurata correttamente
     */
    // Implementa qui...
  }

  isFeatureAbilitata(nome_feature) {
    /**
     * Usa destructuring per controllare se una feature flag è abilitata
     */
    // Implementa qui...
  }

  ottieniRiassuntosicurezza() {
    /**
     * Usa destructuring per creare un riassunto delle impostazioni di sicurezza
     * includendo informazioni su JWT, CORS, e altre impostazioni
     */
    // Implementa qui...
  }
}

// Test del sistema di configurazione
function testGestoreConfigurazione() {
  console.log('=== Test Sistema Configurazione ===\n');

  ['sviluppo', 'test', 'produzione'].forEach(ambiente => {
    console.log(`\n--- Configurazione ${ambiente.toUpperCase()} ---`);

    const gestore = new GestoreConfigurazione(ambiente);

    console.log('Server:', gestore.ottieniConfigurazioneServer());
    console.log('DB Connection:', gestore.ottieniStringaConnessioneDB());
    console.log('Logging:', gestore.ottieniConfigurazioneLogging());
    console.log('Nuova UI abilitata:', gestore.isFeatureAbilitata('nuova_ui'));
    console.log('Sicurezza:', gestore.ottieniRiassuntosicurezza());
  });

  // Test con ambiente inesistente
  console.log('\n--- Test ambiente inesistente ---');
  const gestore_fallback = new GestoreConfigurazione('ambiente_inesistente');
  console.log(
    'Fallback funziona:',
    gestore_fallback.ottieniConfigurazioneServer(),
  );
}

// Esegui il test quando hai implementato la classe
// testGestoreConfigurazione();
```

## Conclusioni e Best Practices

Il destructuring assignment rappresenta una delle aggiunte più significative alla sintassi JavaScript, trasformando non solo il modo in cui scriviamo codice, ma anche il modo in cui pensiamo ai dati e alla loro manipolazione. Attraverso questa guida completa, hai esplorato tutti gli aspetti di questa potente caratteristica, dalle basi fondamentali ai pattern più avanzati.

Quando utilizzi il destructuring nei tuoi progetti, ricorda sempre questi principi fondamentali che ti aiuteranno a sfruttarne appieno il potenziale mantenendo il codice pulito e manutenibile.

Il destructuring dovrebbe sempre migliorare la leggibilità del tuo codice. Se ti trovi a scrivere destructuring così complessi da rendere difficile la comprensione, considera di spezzare l'operazione in passaggi più piccoli. La chiarezza del codice è sempre più importante della concisione a tutti i costi.

Usa sempre valori di default sensati quando gestisci dati che potrebbero essere incompleti o provenienti da fonti esterne. Questo rende il tuo codice più robusto e riduce la necessità di controlli espliciti per valori `undefined`. Ricorda però la distinzione tra `undefined` e altri valori falsy come `null` o stringhe vuote.

Nei parametri delle funzioni, il destructuring con valori di default crea interfacce molto più flessibili e auto-documentanti rispetto alle lunghe liste di parametri tradizionali. Questo pattern è particolarmente potente quando devi gestire oggetti di configurazione o opzioni.

Quando lavori con strutture dati complesse, usa il destructuring annidato per navigare ed estrarre solo i dati che effettivamente ti servono. Questo non solo riduce la quantità di codice necessaria, ma rende anche esplicito quali parti della struttura dati sono importanti per la logica della tua funzione.

Combina sempre il destructuring con altre caratteristiche moderne di JavaScript come template literals, arrow functions, e spread/rest operators per creare codice più espressivo e funzionale.

Gestisci sempre i casi edge, specialmente quando lavori con dati esterni o API. Usa il pattern `dati || {}` o `dati ?? {}` per evitare errori quando tenti di destrutturare valori potenzialmente `null` o `undefined`.

Il destructuring non è solo una sintassi alternativa, ma un nuovo paradigma che favorisce la programmazione dichiarativa rispetto a quella imperativa. Invece di dire al computer "come" estrarre i dati passo dopo passo, dichiari "cosa" vuoi estrarre, rendendo le tue intenzioni più chiare e il codice più maintainabile.

Con una comprensione profonda del destructuring assignment, sei ora equipaggiato con uno strumento potente che ti accompagnerà in tutto il tuo percorso di sviluppo JavaScript. Continua a praticare questi pattern nei tuoi progetti reali e vedrai come questa caratteristica del linguaggio può trasformare positivamente il modo in cui scrivi e ragioni sul codice.
